<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>anyesu's Blog</title>
        <link>https://anyesu.github.io</link>
        <description>这是 anyesu 的个人博客, 爱技术, 爱折腾</description>
        <lastBuildDate>Thu, 22 Oct 2020 18:02:02 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>anyesu's Blog</title>
            <url>https://anyesu.github.io/favicon.ico</url>
            <link>https://anyesu.github.io</link>
        </image>
        <copyright>Copyright © 2020 https://anyesu.github.io. All rights reserved.</copyright>
        <atom:link href="https://anyesu.github.io/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[使用 semantic-release 自动发版]]></title>
            <link>https://anyesu.github.io/blog/articles/37</link>
            <guid>37</guid>
            <pubDate>Thu, 22 Oct 2020 18:02:02 GMT</pubDate>
            <description><![CDATA[前言 最近新项目准备做自动发版，就去研究了一下 semantic-release 。 什么是 semantic-release Fully automated version management and package publishing semantic-release automates the whole package release workflow including: deter]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>最近新项目准备做自动发版，就去研究了一下 <strong>semantic-release</strong> 。</p>
<h3>什么是 <a href="https://github.com/semantic-release/semantic-release">semantic-release</a></h3>
<hr>
<blockquote>
<h3>Fully automated version management and package publishing</h3>
<p><strong>semantic-release</strong> automates the whole package release workflow including: determining the next version number, generating the release notes and publishing the package.</p>
<p>This removes the immediate connection between human emotions and version numbers, strictly following the <a href="http://semver.org/" rel="nofollow">Semantic Versioning</a> specification.</p>
</blockquote>
<p>用人话说就是一个完全自动化的工具，可以帮助你做版本号管理、生成 <strong>changelog</strong> ，并且发布到包管理器 ( 比如 <a href="https://npmjs.com" rel="nofollow">npm</a> ) 。</p>
<h3>如何使用 ( <a href="https://semantic-release.gitbook.io" rel="nofollow">官方文档</a> )</h3>
<hr>
<blockquote>
<ol>
<li>
<p>Install <strong>semantic-release</strong> in your project</p>
</li>
<li>
<p>Configure your Continuous Integration service to <code>run semantic-release</code></p>
</li>
<li>
<p>Configure your Git repository and package manager repository <strong>authentication</strong> in your Continuous Integration service</p>
</li>
<li>
<p>Configure <strong>semantic-release</strong> <strong>options and plugins</strong></p>
</li>
</ol>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">cd</span> your-module
npx semantic-release-cli setup

<span class="pl-c"><span class="pl-c">#</span> For Node modules projects</span>
npm install --save-dev semantic-release

<span class="pl-c"><span class="pl-c">#</span> Then in the CI environment</span>
npx semantic-release</pre></div>
<p>以上是官方文档的内容，操作真的是很简单，简单到不知道它是干嘛的，简单到后面步入一个个坑不知道怎么解决。我照着官方文档折腾了几个小时愣是没跑通，一直在 <strong>error</strong> 。要不是看在很多项目 ( 比如 <a href="https://github.com/octokit">octokit</a> ) 都在用它，我都想直接放弃了。</p>
<p>官方文档只是告诉你需要安装这么一个包，有哪些参数，剩下的都没细说，就算有也是藏在某个角落里生怕别人找到：</p>
<ol>
<li>
<p>是否需要新建 <strong>GitHub</strong> 仓库？</p>
</li>
<li>
<p>如何配置 <strong>GitHub</strong> 和 <strong>npm</strong> 的 <strong>token</strong> ?</p>
</li>
<li>
<p>何时触发 <strong>发布</strong> 操作的？手动执行命令？<strong>push</strong> ？</p>
</li>
<li>
<p>如何测试？一定要在 <strong>CI</strong> 环境中？</p>
</li>
</ol>
<h3>正确打开方式</h3>
<hr>
<blockquote>
<p>我特地建了一个新仓库 <a href="https://github.com/iewgggg/semantic-release-test">semantic-release-test</a> 来演示效果。感兴趣的朋友可以照着我的提交记录走一遍流程。</p>
</blockquote>
<ul>
<li>
<h4>本地新建一个项目，比如 <code>semantic-release-test</code></h4>
<p><strong>目录结构</strong></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">.</span>
├─.github
│  └─workflows
│    └─release.yml
├─src
│  └─index.js
├─.env
├─.releaserc.js
├─package.json</pre></div>
<p><strong>package.json</strong></p>
<blockquote>
<p>替换为自己的包名和仓库地址</p>
</blockquote>
<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>@anyesu/semantic-release-test<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>version<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>0.0.0-development<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>semantic-release-test<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>main<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>src/index.js<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>scripts<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>build<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>echo build success.<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>semantic-release<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>dotenv -c -- semantic-release<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>semantic-release:local<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>dotenv -c -- semantic-release --no-ci<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>publishConfig<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>registry<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>https://registry.npmjs.org/<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>access<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>public<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>repository<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>git<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>url<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>https://github.com/iewgggg/semantic-release-test.git<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>anyesu<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>license<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>MIT<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>bugs<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>url<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>https://github.com/iewgggg/semantic-release-test/issues<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>homepage<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>https://github.com/iewgggg/semantic-release-test#readme<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>files<span class="pl-pds">"</span></span>: [
    <span class="pl-s"><span class="pl-pds">"</span>src<span class="pl-pds">"</span></span>
  ],
  <span class="pl-s"><span class="pl-pds">"</span>devDependencies<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>^9.0.0<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>conventional-changelog-cmyr-config<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>^1.2.3<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>dotenv-cli<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>^4.0.0<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>semantic-release<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>^17.2.1<span class="pl-pds">"</span></span>
  }
}</pre></div>
<p><strong>.releaserc.js</strong></p>
<blockquote>
<p><strong>semantic-release</strong> 的配置文件，具体配置项见 <a href="https://semantic-release.gitbook.io/semantic-release/usage/configuration" rel="nofollow">文档</a> 。</p>
</blockquote>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">module</span><span class="pl-kos">.</span><span class="pl-c1">exports</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
  <span class="pl-c1">plugins</span>: <span class="pl-kos">[</span>
    <span class="pl-s">"@semantic-release/commit-analyzer"</span><span class="pl-kos">,</span>
    <span class="pl-kos">[</span>
      <span class="pl-s">"@semantic-release/release-notes-generator"</span><span class="pl-kos">,</span>
      <span class="pl-kos">{</span>
        <span class="pl-c1">config</span>: <span class="pl-s">"conventional-changelog-cmyr-config"</span><span class="pl-kos">,</span>
      <span class="pl-kos">}</span><span class="pl-kos">,</span>
    <span class="pl-kos">]</span><span class="pl-kos">,</span>
    <span class="pl-s">"@semantic-release/npm"</span><span class="pl-kos">,</span>
    <span class="pl-kos">[</span>
      <span class="pl-s">"@semantic-release/git"</span><span class="pl-kos">,</span>
      <span class="pl-kos">{</span>
        <span class="pl-c1">assets</span>: <span class="pl-kos">[</span><span class="pl-s">"package.json"</span><span class="pl-kos">]</span><span class="pl-kos">,</span>
      <span class="pl-kos">}</span><span class="pl-kos">,</span>
    <span class="pl-kos">]</span><span class="pl-kos">,</span>
    <span class="pl-s">"@semantic-release/github"</span><span class="pl-kos">,</span>
  <span class="pl-kos">]</span><span class="pl-kos">,</span>
<span class="pl-kos">}</span><span class="pl-kos">;</span></pre></div>
<p><strong>.env</strong></p>
<blockquote>
<p>环境变量配置文件，通过 <code>dotenv-cli</code> 在运行时读取</p>
<p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token">GITHUB_TOKEN</a></p>
<p><a href="https://docs.npmjs.com/creating-and-viewing-access-tokens" rel="nofollow">NPM_TOKEN</a> 如果是私有仓库或者不想发布到 <strong>npm</strong> 可以不填</p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>GITHUB_TOKEN=<span class="pl-k">******</span>
NPM_TOKEN=<span class="pl-k">******</span></pre></div>
<p><strong>.github/workflows/release.yml</strong></p>
<blockquote>
<p><strong>CI</strong> - <a href="https://docs.github.com/en/free-pro-team@latest/actions">GitHub Actions</a> 的配置文件，可选。</p>
<p><strong>GitHub Actions</strong> 会自动创建名为 <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/authentication-in-a-workflow">GITHUB_TOKEN</a> 的 <strong>secret</strong> ，不需要手动添加</p>
<p>只需要 <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository">添加</a> 额外的 <strong>NPM_TOKEN</strong></p>
</blockquote>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">name</span>: <span class="pl-s">Release</span>
<span class="pl-ent">on</span>:
  <span class="pl-ent">repository_dispatch</span>:
    <span class="pl-ent">types</span>: <span class="pl-s">[ semantic-release ]</span>
  <span class="pl-ent">push</span>:
    <span class="pl-ent">branches</span>:
      - <span class="pl-s">master</span>
      - <span class="pl-s">next</span>
      - <span class="pl-s">beta</span>
      - <span class="pl-s"><span class="pl-pds">"</span>*.x<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> maintenance releases such as 15.x</span>

<span class="pl-ent">jobs</span>:
  <span class="pl-ent">release</span>:
    <span class="pl-ent">name</span>: <span class="pl-s">release</span>
    <span class="pl-ent">runs-on</span>: <span class="pl-s">ubuntu-latest</span>
    <span class="pl-ent">steps</span>:
      - <span class="pl-ent">uses</span>: <span class="pl-s">actions/checkout@v2</span>
      - <span class="pl-ent">uses</span>: <span class="pl-s">actions/setup-node@v1</span>
        <span class="pl-ent">with</span>:
          <span class="pl-ent">node-version</span>: <span class="pl-c1">12</span>
      - <span class="pl-ent">run</span>: <span class="pl-s">npm i</span>
      - <span class="pl-ent">run</span>: <span class="pl-s">npm run build</span>
      - <span class="pl-ent">run</span>: <span class="pl-s">npx semantic-release</span>
        <span class="pl-ent">env</span>:
          <span class="pl-ent">GITHUB_TOKEN</span>: <span class="pl-s">${{ secrets.GITHUB_TOKEN }}</span>
          <span class="pl-ent">NPM_TOKEN</span>: <span class="pl-s">${{ secrets.NPM_TOKEN }}</span></pre></div>
</li>
<li>
<h4>初始化为 Git 项目，并提交初始化版本</h4>
<div class="highlight highlight-source-shell"><pre>git init
git add package.json .releaserc.js .github/workflows/release.yml
git commit -m <span class="pl-s"><span class="pl-pds">"</span>feat: :tada: Initial commit.<span class="pl-pds">"</span></span></pre></div>
</li>
<li>
<h4><a href="https://github.com/new">新建远程仓库</a> ( 比如 <a href="https://github.com/iewgggg/semantic-release-test">semantic-release-test</a> )</h4>
<blockquote>
<p>很重要，一定要有远程仓库</p>
</blockquote>
</li>
<li>
<h5>推送到 GitHub</h5>
<pre><code>git remote add origin https://{GITHUB_TOKEN}@github.com/{owner}/{repo}
git push -u origin master
</code></pre>
<p>如果按照上面步骤配置了 <strong>GitHub Actions</strong> ，那么打开 <strong>GitHub</strong> 中的项目可以看到已经成功生成了 <strong>release</strong> 。</p>
<p>同时还可以看到有一条新的提交记录</p>
<pre><code>chore(release): 1.0.0 [skip ci]
</code></pre>
</li>
<li>
<h4>本地测试</h4>
<p>安装项目</p>
<div class="highlight highlight-source-shell"><pre>git pull
npm i</pre></div>
<p>随便修改一个文件提交一条新记录</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">echo</span> <span class="pl-c1">test</span> <span class="pl-k">&gt;</span> test.txt

git add test.txt
git commit -m <span class="pl-s"><span class="pl-pds">"</span>fix: :apple: Fixing something on macOS.<span class="pl-pds">"</span></span></pre></div>
<p>测试效果</p>
<div class="highlight highlight-source-shell"><pre>npm run semantic-release</pre></div>
<details>
<summary>本地日志</summary>
<div class="highlight highlight-source-shell"><pre>[semantic-release] » i  Running semantic-release version 17.2.1
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>addChannel<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>addChannel<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>success<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>fail<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » ‼  This run was not triggered <span class="pl-k">in</span> a known CI environment, running <span class="pl-k">in</span> dry-run mode.
[semantic-release] » ‼  Run automated release from branch master on repository https://[secure]@github.com/iewgggg/semantic-release-test.git <span class="pl-k">in</span> dry-run mode
[semantic-release] » √  Allowed to push to the Git repository
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/github] » i  Verify GitHub authentication
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » i  Found git tag v1.0.0 associated with version 1.0.0 on branch master
[semantic-release] » i  Found 1 commits since last release
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/commit-analyzer] » i  Analyzing commit: fix: :apple: Fixing something on macOS.
[semantic-release] [@semantic-release/commit-analyzer] » i  The release <span class="pl-c1">type</span> <span class="pl-k">for</span> the commit is patch
[semantic-release] [@semantic-release/commit-analyzer] » i  Analysis of 1 commits complete: patch release
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] » i  The next release version is 1.0.1
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » ‼  Skip step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span> <span class="pl-k">in</span> dry-run mode
[semantic-release] » ‼  Skip step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span> <span class="pl-k">in</span> dry-run mode
[semantic-release] » ‼  Skip v1.0.1 tag creation <span class="pl-k">in</span> dry-run mode
[semantic-release] » ‼  Skip step <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span> <span class="pl-k">in</span> dry-run mode
[semantic-release] » ‼  Skip step <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span> <span class="pl-k">in</span> dry-run mode
[semantic-release] » ‼  Skip step <span class="pl-s"><span class="pl-pds">"</span>success<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span> <span class="pl-k">in</span> dry-run mode
[semantic-release] » √  Published release 1.0.1 on default channel
[semantic-release] » i  Release note <span class="pl-k">for</span> version 1.0.1:
<span class="pl-c"><span class="pl-c">#</span># 1.0.1 (https://github.com/iewgggg/semantic-release-test/compare/v1.0.0...v1.0.1) (2020-10-22)</span>

<span class="pl-c"><span class="pl-c">#</span>## � Bug Fixes</span>

    <span class="pl-k">*</span> �  Fixing something on macOS. (c83864b (https://github.com/iewgggg/semantic-release-test/commit/c83864b))</pre></div>
</details>
<p>已经可以看到根据 <strong>提交记录</strong> 生成的 <strong>changelog</strong> 的内容，由于不是在 <strong>CI</strong> 环境中运行的，所以实际并没有发布到 <strong>GitHub</strong> 和 <strong>npm</strong> 。</p>
<p>通过预览知道已经 OK 了，下面可以在本地进行发布</p>
<div class="highlight highlight-source-shell"><pre>npm run semantic-release:local</pre></div>
<details>
<summary>本地日志</summary>
<div class="highlight highlight-source-shell"><pre>[semantic-release] » i  Running semantic-release version 17.2.1
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>addChannel<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>addChannel<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>success<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Loaded plugin <span class="pl-s"><span class="pl-pds">"</span>fail<span class="pl-pds">"</span></span> from <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » √  Run automated release from branch master on repository https://[secure]@github.com/iewgggg/semantic-release-test.git
[semantic-release] » √  Allowed to push to the Git repository
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/github] » i  Verify GitHub authentication
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>verifyConditions<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/github<span class="pl-pds">"</span></span>
[semantic-release] » i  Found git tag v1.0.0 associated with version 1.0.0 on branch master
[semantic-release] » i  Found 1 commits since last release
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/commit-analyzer] » i  Analyzing commit: fix: :apple: Fixing something on macOS.
[semantic-release] [@semantic-release/commit-analyzer] » i  The release <span class="pl-c1">type</span> <span class="pl-k">for</span> the commit is patch
[semantic-release] [@semantic-release/commit-analyzer] » i  Analysis of 1 commits complete: patch release
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>analyzeCommits<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/commit-analyzer<span class="pl-pds">"</span></span>
[semantic-release] » i  The next release version is 1.0.1
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/npm] » i  Write version 1.0.1 to package.json <span class="pl-k">in</span> pathto<span class="pl-cce">\s</span>emantic-release-test
v1.0.1
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/git] » i  Found 1 file(s) to commit
[semantic-release] [@semantic-release/git] » i  Prepared Git release: v1.0.1
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>prepare<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/git<span class="pl-pds">"</span></span>
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Completed step <span class="pl-s"><span class="pl-pds">"</span>generateNotes<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/release-notes-generator<span class="pl-pds">"</span></span>
[semantic-release] » √  Created tag v1.0.1
[semantic-release] » i  Start step <span class="pl-s"><span class="pl-pds">"</span>publish<span class="pl-pds">"</span></span> of plugin <span class="pl-s"><span class="pl-pds">"</span>@semantic-release/npm<span class="pl-pds">"</span></span>
[semantic-release] [@semantic-release/npm] » i  Skip publishing to npm registry as package.json<span class="pl-s"><span class="pl-pds">'</span>s private property is true</span>
<span class="pl-s">[semantic-release] » √  Completed step "publish" of plugin "@semantic-release/npm"</span>
<span class="pl-s">[semantic-release] » i  Start step "publish" of plugin "@semantic-release/github"</span>
<span class="pl-s">[semantic-release] [@semantic-release/github] » i  Published GitHub release: https://github.com/iewgggg/semantic-release-test/releases/tag/v1.0.1</span>
<span class="pl-s">[semantic-release] » √  Completed step "publish" of plugin "@semantic-release/github"</span>
<span class="pl-s">[semantic-release] » i  Start step "success" of plugin "@semantic-release/github"</span>
<span class="pl-s">[semantic-release] » √  Completed step "success" of plugin "@semantic-release/github"</span>
<span class="pl-s">[semantic-release] » √  Published release 1.0.1 on default channel</span></pre></div>
</details>
<p>再打开 <strong>GitHub</strong> 中的项目可以看到 <strong>release v1.0.1</strong> 也生成了。</p>
<blockquote>
<p>Tip: 可以注意到两次 <strong>release</strong> 的作者是不一样的，因为使用了不同的 <strong>GITHUB_TOKEN</strong> 。</p>
</blockquote>
<p>此时虽然 <strong>GitHub Actions</strong> 中多了一个新的执行记录：</p>
<pre><code>chore(release): 1.0.1 [skip ci]
</code></pre>
<p>但不需要担心会重复发布，在日志中可以看到下面的内容：</p>
<pre><code>There are no relevant changes, so no new version is released.
</code></pre>
</li>
</ul>
<h3>原理分析</h3>
<hr>
<p>首先，我们结合 <code>semantic-release</code> 和 <code>semantic-release:local</code> 两个命令的日志看下它究竟做了什么</p>
<ol>
<li>
<p>加载插件。</p>
</li>
<li>
<p>判断是否在 <strong>CI</strong> 环境中，不是则跳过执行插件的一些生命周期。</p>
</li>
<li>
<p>检查远程仓库是否存在，以及合法的分支。</p>
</li>
<li>
<p>检查是否有仓库的写入权限。</p>
<p><strong>这一步比较坑爹，如果没有设置 GITHUB_TOKEN 报错竟然是版本落后？？？</strong></p>
<div class="highlight highlight-source-shell"><pre>Run automated release from branch master on repository https://github.com/iewgggg/semantic-release-test.git <span class="pl-k">in</span> dry-run mode
The <span class="pl-k">local</span> branch master is behind the remote one, therefore a new version won<span class="pl-s"><span class="pl-pds">'</span>t be published.</span></pre></div>
<p><strong>设置 GITHUB_TOKEN 后再看日志感受下区别</strong></p>
<div class="highlight highlight-source-shell"><pre>Run automated release from branch master on repository https://[secure]@github.com/iewgggg/semantic-release-test.git <span class="pl-k">in</span> dry-run mode
√  Allowed to push to the Git repository</pre></div>
<p>这个问题也是我 <strong>debug</strong> 源码后才发现的。</p>
</li>
<li>
<p>检查 <strong>NPM_TOKEN</strong> 是否存在，并写入到 <strong>temp</strong> 目录的 <strong>.npmrc</strong> 文件中。</p>
</li>
<li>
<p>检查当前分支是否存在符合 <a href="https://semver.org/" rel="nofollow">语义化版本</a> 的 <strong>tag</strong>，存在则为当前版本号。</p>
</li>
<li>
<p>对比 <strong>远程仓库</strong> 是否有新的提交记录，无则终止。</p>
</li>
<li>
<p>插件 <code>@semantic-release/commit-analyzer</code> 开始对 <strong>新的提交记录</strong> 逐条分析，筛选符合 <a href="https://semantic-release.gitbook.io/semantic-release/#commit-message-format" rel="nofollow">提交规范</a> 的记录， <strong>筛选结果</strong> 为空则终止。</p>
</li>
<li>
<p>如果存在 <strong>当前版本号</strong> ，则根据 <strong>筛选结果</strong> 确定升级类型 ( <strong>MAJOR / MINOR / PATCH</strong> ) 计算 <strong>新的版本号</strong> ，否则 <strong>新版本号</strong> 为 <code>1.0.0</code> 。</p>
</li>
<li>
<p>插件 <code>@semantic-release/release-notes-generator</code> 再对 <strong>新的提交记录</strong> 逐条分析生成 <strong>changelog</strong> 。</p>
</li>
<li>
<p>插件 <code>@semantic-release/npm</code> 将 <strong>新的版本号</strong> 重新写入到 <strong>package.json</strong> 文件中。</p>
</li>
<li>
<p>插件 <code>@semantic-release/git</code> 对修改后的 <strong>package.json</strong> 进行 <strong>提交</strong> 和 <strong>推送</strong> 。</p>
<blockquote>
<p>插件默认配置还会修改 <strong>CHANGELOG.md</strong> 文件，本文中配置为只修改 <strong>package.json</strong></p>
</blockquote>
</li>
<li>
<p>添加新版本号 <strong>tag</strong> 。</p>
</li>
<li>
<p><strong>npm</strong> <strong>打包</strong> 并 <strong>发布</strong> ，如果 <strong>package.json</strong> 设置了 <code>"private": true</code> 则跳过。</p>
</li>
<li>
<p>发布到 <strong>GitHub</strong> ，包括压缩包和 <strong>changelog</strong> 。</p>
</li>
</ol>
<p>整个流程比较清晰了，主要操作也是通过几个插件来完成，所以通过对插件的组合、配置来实现一些个性化的需求。</p>
<h3>缺点</h3>
<hr>
<ol>
<li>
<p><strong>semantic-release</strong> 强依赖于远程仓库的分支状态，所以在正式使用前测试会非常麻烦，反复测试需要反复重置远程仓库的状态，而且网络不好就更恶心了。</p>
</li>
<li>
<p><strong>release</strong> 中的 <strong>changelog</strong> 是发布一个版本生成一次的，这就意味着仓库迁移的话，历史记录就没有了，只剩下 <strong>tag</strong> 。</p>
<p>如果没有使用插件 <code>@semantic-release/git</code> 的话可以不断 <strong>reset HEAD</strong> 来恢复一个个版本，当然这也很麻烦。</p>
</li>
</ol>
<h3>FAQ</h3>
<hr>
<ul>
<li>
<p><strong>官方文档太烂怎么办？</strong></p>
<p>直接阅读源码 + debug ，以力破法。</p>
</li>
<li>
<p><strong>为何本地执行命令会卡住？</strong></p>
<p>因为分别需要连接到 <strong>GitHub</strong> 和 <strong>npm</strong> ，网络环境差就会卡住。</p>
</li>
<li>
<p><strong>如何不发布到 npm？</strong></p>
<ol>
<li>
<p>移除插件 <code>@semantic-release/npm</code> 即可，但这样 <strong>package.json</strong> 中的版本号得不到修改。</p>
</li>
<li>
<p>在 <strong>package.json</strong> 中设置 <code>"private": true</code> 。</p>
</li>
<li>
<p>插件 <code>@semantic-release/npm</code> 配置为 <code>npmPublish: false</code> 。</p>
</li>
</ol>
</li>
<li>
<p><strong>registry 设置为 <a href="https://registry.npm.taobao.org" rel="nofollow">https://registry.npm.taobao.org</a> 但需要发布到 npm？</strong></p>
<p>在 <strong>package.json</strong> 中设置</p>
<div class="highlight highlight-source-json"><pre><span class="pl-s"><span class="pl-pds">"</span>publishConfig<span class="pl-pds">"</span></span>: {
  <span class="pl-s"><span class="pl-pds">"</span>registry<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>https://registry.npmjs.org/<span class="pl-pds">"</span></span>
}</pre></div>
</li>
<li>
<p><strong>npm 发布报错？</strong></p>
<blockquote>
<p>npm ERR! 402 Payment Required - PUT <a href="https://registry.npmjs.org/" rel="nofollow">https://registry.npmjs.org/</a> - You must sign up for private packages</p>
</blockquote>
<p>第一次发布时会出现这个错误，因为 <strong>scoped packages</strong> 默认会被发布为 <strong>私有包</strong> ，需要将其发布为 <strong>公有包</strong> 。见 <a href="https://docs.npmjs.com/creating-and-publishing-scoped-public-packages#publishing-scoped-public-packages" rel="nofollow">官方文档</a> 。</p>
<p>下面有三种方案</p>
<ol>
<li>
<p>修改 <strong>命令行</strong> 参数</p>
<div class="highlight highlight-source-shell"><pre>npm publish --access public</pre></div>
</li>
<li>
<p>在 <strong>.npmrc</strong> 中设置</p>
<div class="highlight highlight-source-shell"><pre>access=public</pre></div>
</li>
<li>
<p>在 <strong>package.json</strong> 中设置</p>
<div class="highlight highlight-source-json"><pre><span class="pl-s"><span class="pl-pds">"</span>publishConfig<span class="pl-pds">"</span></span>: {
  <span class="pl-s"><span class="pl-pds">"</span>access<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>public<span class="pl-pds">"</span></span>
}</pre></div>
</li>
</ol>
</li>
<li>
<p><strong>npm 开启双因素认证 ( Two Factor Authentication ) 后发布报错？</strong></p>
<blockquote>
<p>The npm token (<a href="https://github.com/semantic-release/npm/blob/master/README.md#npm-registry-authentication">https://github.com/semantic-release/npm/blob/master/README.md#npm-registry-authentication</a>) configured in the NPM_TOKEN environment variable must be a valid token (<a href="https://docs.npmjs.com/getting-started/working_with_tokens" rel="nofollow">https://docs.npmjs.com/getting-started/working_with_tokens</a>) allowing to publish to<br>
the registry <a href="https://registry.npmjs.org/" rel="nofollow">https://registry.npmjs.org/</a>.</p>
<p>If you are using Two-Factor Authentication, make configure the auth-only level (<a href="https://docs.npmjs.com/getting-started/using-two-factor-authentication#levels-of-authentication" rel="nofollow">https://docs.npmjs.com/getting-started/using-two-factor-authentication#levels-of-authentication</a>) is supported. semantic-release cannot publish with the default auth-and-writes level.</p>
</blockquote>
<ol>
<li>
<p><strong>双因素认证</strong> 需要设置为 <strong>auth-only</strong> 级别 ( <a href="https://docs.npmjs.com/about-two-factor-authentication" rel="nofollow">文档</a> ) 。</p>
</li>
<li>
<p><strong>Access Tokens</strong> 类型选择 <strong>Publish</strong> 而不是 <strong>Automation</strong> 。</p>
</li>
</ol>
</li>
<li>
<p><strong>如何同步更新 <code>package.json</code> 中的版本号？</strong></p>
<p>默认不更新版本号，可以添加插件 <code>@semantic-release/git</code> 来额外提交。</p>
</li>
<li>
<p><strong>如何在 <code>1.0.0</code> 之前发布 prerelease 版本，如：1.0.0-beta.10 ？</strong></p>
<ol>
<li>
<p>项目不包含 <strong>release.yml</strong> 时初始化后推送到 <strong>master</strong> 分支，这样确保 <strong>远程仓库</strong> 有一个 <strong>release 分支</strong> 并且不会自动发布。</p>
</li>
<li>
<p>切到 <strong>beta</strong> 分支提交 <strong>release.yml</strong> 后推送，自动发布为 <code>1.0.0-beta.1</code> 。</p>
</li>
</ol>
<p>这样就生成 <strong>beta</strong> 版本了，后续迭代继续在 <strong>beta</strong> 分支上进行，发布正式版只需将 <strong>beta</strong> 分支合并到 <strong>master</strong> 分支，然后所有 <strong>beta</strong> 版的 <strong>changelog</strong> 都会合并到 <code>1.0.0</code> 中。( <a href="https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/pre-releases.md">参考</a> )</p>
</li>
<li>
<p><strong>如何手动管理版本？</strong></p>
<p>可以使用 <a href="https://github.com/conventional-changelog/standard-version">standard-version</a> ，二者区别：</p>
<blockquote>
<p><code>standard-version</code> takes a different approach by handling versioning, changelog generation, and git tagging for you <strong>without</strong> automatic pushing (to GitHub) or publishing (to an npm registry). Use of <code>standard-version</code> only affects your local git repo - it doesn't affect remote resources at all. After you run <code>standard-version</code>, you can review your release state, correct mistakes and follow the release strategy that makes the most sense for your codebase.</p>
</blockquote>
<div class="highlight highlight-source-json"><pre><span class="pl-s"><span class="pl-pds">"</span>scripts<span class="pl-pds">"</span></span>: {
  <span class="pl-s"><span class="pl-pds">"</span>release:beta<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>standard-version --release-as major --prerelease beta<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>release:major<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>standard-version --release-as major<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>release:minor<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>standard-version --release-as minor<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>release:patch<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>standard-version --release-as patch<span class="pl-pds">"</span></span>
},
<span class="pl-s"><span class="pl-pds">"</span>devDependencies<span class="pl-pds">"</span></span>: {
  <span class="pl-s"><span class="pl-pds">"</span>standard-version<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>^9.0.0<span class="pl-pds">"</span></span>
}</pre></div>
</li>
<li>
<p><strong>如何手动发布？</strong></p>
<ol>
<li>
<p>本地执行 <code>npm run semantic-release:local</code> 。</p>
</li>
<li>
<p>通过 <strong>GitHub Actions Hook</strong> 调用，详见 <a href="https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/github-actions.md#trigger-semantic-release-on-demand">文档</a> 。</p>
<p>也可以添加按钮 - <a href="https://github-action-button.web.app/" rel="nofollow">https://github-action-button.web.app</a></p>
</li>
</ol>
</li>
<li>
<p><strong>如何修改 changelog 的格式？</strong></p>
<p>这部分功能底层依赖于 <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a> ，已经内置几种预设 ( <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-angular"><code>angular</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-atom"><code>atom</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-codemirror"><code>codemirror</code></a>, <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-ember"><code>ember</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-eslint"><code>eslint</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-express"><code>express</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jquery"><code>jquery</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-jshint"><code>jshint</code></a> , <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-conventionalcommits"><code>conventionalcommits</code></a> ) 可供选择，我这里使用的是第三方配置 <a href="https://github.com/CaoMeiYouRen/conventional-changelog-cmyr-config">conventional-changelog-cmyr-config</a> ，需要更加个性化详见 <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-writer">conventional-changelog-writer</a> 包配置项。</p>
<p>本来我想配置成 <a href="https://github.com/ant-design/ant-design/releases">antd</a> 那样的双语 <strong>changelog</strong> ( 再复制一份用 <strong>翻译 API</strong> 翻译一下，再手动微调 )，但还要 <strong>fork</strong> 发包，那就先算了吧。</p>
</li>
</ul>
<h3>IDEA 插件推荐</h3>
<hr>
<ol>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/9861-git-commit-template" rel="nofollow">Git Commit Template</a></p>
<p>通过表单的形式结构化输入 <strong>commit message</strong> 。</p>
<p>符合 <a href="https://github.com/angular/angular.js">AngularJS</a> 的 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Git Commit Guidelines</a> 规范。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10315-gitmoji" rel="nofollow">Gitmoji</a></p>
<p>根据输入的内容来选择 <strong>emoji 表情</strong> 的表达式。</p>
<p><a href="https://gitmoji.carloscuesta.me/" rel="nofollow">Reference commit rules</a> / <a href="https://gitmoji.surge.sh/" rel="nofollow">中文提交规则</a></p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/14610-gitmoji-unicode" rel="nofollow">Gitmoji-Unicode</a></p>
<p><strong>Gitmoji</strong> 插件的 <strong>fork</strong> 版本，可以直接显示 <strong>emoji 表情</strong> 而非表达式。</p>
</li>
</ol>
<p>两个插件都挺不错的，缺点就是写死了不可配置，再加上几年没维护了，用起来有点尴尬。</p>
<h3>最后</h3>
<hr>
<p>按照文中的配置，基本上满足我的需求了：</p>
<ol>
<li>
<p>自动化版本管理，推送代码或者合并 <strong>PR</strong> 即可发版。</p>
</li>
<li>
<p>自动生成 <strong>changelog</strong> ，不再需要单独去写。</p>
</li>
<li>
<p>自动发布到 <strong>npm</strong> ( <g-emoji class="g-emoji" alias="sweat_smile" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png">😅</g-emoji> 直接省去了学习 <strong>npm</strong> 发包的步骤 ) 。</p>
</li>
<li>
<p>发布后对应的 <strong>PR</strong> 和 <strong>issue</strong> 下会添加 <strong>发布通知</strong> 的评论，就不需要自己再手动通知了。</p>
</li>
</ol>
<hr>
<h4>转载请注明出处：<a href="https://anyesu.github.io/blog/articles/37" rel="nofollow">https://github.com/anyesu/blog/issues/37</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[WSL 中 Docker 使用总结]]></title>
            <link>https://anyesu.github.io/blog/articles/36</link>
            <guid>36</guid>
            <pubDate>Sun, 29 Sep 2019 15:47:54 GMT</pubDate>
            <description><![CDATA[前言 最近看一篇文章中提到 WSL 中已经支持 Docker 运行了，最初不以为意以为还是千篇一律的标题党 ( Docker Client + Docker Desktop for Windows ) ，后来尝试之后发现确实可行，本文在此记录一些遇到的问题。 关于版本 系统最低版本要求: 1803 ( 17134 ) 。 1803 下可用 Docker 版本: 17.03.0 ~ 17.09.0 ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>最近看一篇文章中提到 <strong>WSL</strong> 中已经支持 <strong>Docker</strong> 运行了，最初不以为意以为还是千篇一律的标题党 ( <strong>Docker Client</strong> + <strong>Docker Desktop for Windows</strong> ) ，后来尝试之后发现确实可行，本文在此记录一些遇到的问题。</p>
<h3>关于版本</h3>
<hr>
<ul>
<li>
<p>系统最低版本要求: <strong>1803 ( <code>17134</code> )</strong> 。</p>
</li>
<li>
<p><strong>1803</strong> 下可用 <strong>Docker</strong> 版本: <code>17.03.0</code> ~ <code>17.09.0</code></p>
<p>使用高版本的 <strong>Docker</strong> 拉取镜像时会报下面的错误：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker pull hello-world</span>
Using default tag: latest
latest: Pulling from library/hello-world
1b930d010525: Extracting [<span class="pl-k">==================================================&gt;</span>]     977B/977B
failed to register layer: Error processing tar file(exit status 1): invalid argument</pre></div>
<p>原因见 <a href="https://www.reddit.com/r/bashonubuntuonwindows/comments/8cvr27/docker_is_running_natively_on_wsl/#t1_dxxn30d" rel="nofollow">这里</a> ，<a href="https://github.com/Microsoft/WSL/issues/2291#issuecomment-403273520" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2291/hovercard">issue</a> 中说这个问题应该在 <a href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-17666" rel="nofollow">17666</a> 版本已经修复了。</p>
</li>
<li>
<p><strong>1809</strong> 下可用 <strong>Docker</strong> 版本: <code>17.03.0</code> ~ <code>18.06.1</code></p>
<p>使用高版本的 <strong>Docker</strong> 创建容器时会报下面的错误：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker run -it hello-world</span>
docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused <span class="pl-s"><span class="pl-pds">"</span>process_linux.go:303: getting the final child's pid from pipe caused <span class="pl-cce">\"</span>EOF<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>: unknown.</pre></div>
<p>对应的 <strong>dockerd</strong> 日志：</p>
<div class="highlight highlight-source-shell"><pre>ERRO[2019-07-09T02:00:58.717968000+08:00] stream copy error: reading from a closed fifo
ERRO[2019-07-09T02:01:00.342200600+08:00] f91be3566b127aa49acc2021701035b2fadfa709a313d3f255999471ae309924 cleanup: failed to delete container from containerd: no such container
ERRO[2019-07-09T02:01:00.451686200+08:00] Handler <span class="pl-k">for</span> POST /v1.39/containers/f91be3566b127aa49acc2021701035b2fadfa709a313d3f255999471ae309924/start returned error: OCI runtime create failed: container_linux.go:345: starting container process caused <span class="pl-s"><span class="pl-pds">"</span>process_linux.go:303: getting the final child's pid from pipe caused <span class="pl-cce">\"</span>EOF<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>: unknown</pre></div>
<p>安装低版本的就好了</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 安装指定版本</span>
<span class="pl-c"><span class="pl-c">#</span> 参考 https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-engine---community-1</span>
apt-get install -y docker-ce=18.06.1~ce~3-0~ubuntu</pre></div>
</li>
</ul>
<h3>最终方案 ( <a href="https://github.com/Microsoft/WSL/issues/2291#issuecomment-495166758" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2291/hovercard">参考</a> )</h3>
<hr>
<ul>
<li>
<p>安装 <strong>Docker</strong></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 安装依赖</span>
sudo apt -y install cgroupfs-mount libltdl7
<span class="pl-c"><span class="pl-c">#</span> 下载安装包</span>
wget -O /tmp/docker-ce.deb https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/docker-ce_17.09.0~ce-0~ubuntu_amd64.deb
<span class="pl-c"><span class="pl-c">#</span> 安装</span>
sudo dpkg -i /tmp/docker-ce.deb
<span class="pl-c"><span class="pl-c">#</span> 卸载</span>
<span class="pl-c"><span class="pl-c">#</span> apt remove -y docker-ce</span>
<span class="pl-c"><span class="pl-c">#</span> 新建 docker 用户组 ( 安装 docker 的时候默认应该会添加这个用户组 )</span>
<span class="pl-c"><span class="pl-c">#</span> sudo groupadd docker</span>
<span class="pl-c"><span class="pl-c">#</span> 将当前用户加入docker组</span>
sudo usermod -aG docker <span class="pl-smi">${USER}</span>
<span class="pl-c"><span class="pl-c">#</span> 刷新 docker 组成员 ( 免 sudo 执行 docker 命令 )</span>
newgrp - docker</pre></div>
</li>
<li>
<p>修改配置文件</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 修改 /etc/default/docker</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>DOCKER_OPTS="-H=unix:///var/run/docker.sock -H=0.0.0.0:2375 --iptables=false"<span class="pl-pds">'</span></span> <span class="pl-k">&gt;&gt;</span> /etc/default/docker
<span class="pl-c"><span class="pl-c">#</span> 修改 docker.service</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>s#^ExecStart=.*#EnvironmentFile=-/etc/default/docker\nExecStart=/usr/bin/dockerd -H fd:// $DOCKER_OPTS#<span class="pl-pds">'</span></span> /lib/systemd/system/docker.service</pre></div>
</li>
<li>
<p>启动 <strong>Docker</strong> ( 使用 <strong>管理员权限</strong> 打开 <strong>CMD</strong> 或者 <strong>PowerShell</strong> 来运行 <strong>WSL</strong> )</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 加载 cgroupfs</span>
sudo cgroupfs-mount
<span class="pl-c"><span class="pl-c">#</span> 启动服务</span>
sudo service docker start
<span class="pl-c"><span class="pl-c">#</span> 配合计划任务，自行设置开机启动</span></pre></div>
<p>查看状态：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker version</span>
Client:
 Version:      17.09.0-ce
 API version:  1.32
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:42:18 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.09.0-ce
 API version:  1.32 (minimum version 1.12)
 Go version:   go1.8.3
 Git commit:   afdb6d4
 Built:        Tue Sep 26 22:40:56 2017
 OS/Arch:      linux/amd64
 Experimental: <span class="pl-c1">false</span>
 
<span class="pl-c"><span class="pl-c">#</span> docker info</span>
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 17.09.0-ce
Storage Driver: overlay2
 Backing Filesystem: <span class="pl-k">&lt;</span>unknown<span class="pl-k">&gt;</span>
 Supports d_type: <span class="pl-c1">true</span>
 Native Overlay Diff: <span class="pl-c1">true</span>
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: <span class="pl-k">local</span>
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 06b9cb35161009dcb7123345749fef02f7cea8e0
runc version: 3f2f8b84a77f73d38244dd690525642a72156c64
init version: 949e6fa
Kernel Version: 4.4.0-17134-Microsoft
Operating System: Ubuntu 16.04.2 LTS
OSType: linux
Architecture: x86_64
CPUs: 8
Total Memory: 15.89GiB
Name: DESKTOP-31U4I5S
ID: 35XV:BUEF:HFQE:DFHI:5HVO:Y40P:2E2V:DC3L:YBAK:JGKR:WD34:OYPZ
Docker Root Dir: /var/lib/docker
Debug Mode (client): <span class="pl-c1">false</span>
Debug Mode (server): <span class="pl-c1">false</span>
Registry: https://index.docker.io/v1/
Experimental: <span class="pl-c1">false</span>
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: <span class="pl-c1">false</span>

WARNING: No memory limit support
WARNING: No swap limit support
WARNING: No kernel memory limit support
WARNING: No oom <span class="pl-c1">kill</span> disable support
WARNING: No cpu cfs quota support
WARNING: No cpu cfs period support
WARNING: No cpu shares support
WARNING: No cpuset support</pre></div>
<p>启动容器看下效果：</p>
<div class="highlight highlight-source-shell"><pre>docker run -it --rm hello-world
docker run -it --rm --name nginx --network host nginx
curl 127.0.0.1</pre></div>
</li>
</ul>
<h3>启动服务遇到的问题</h3>
<hr>
<ul>
<li>
<p>最初，直接启动 <strong>dockerd</strong> 会报下面的错误：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> dockerd</span>
INFO[2019-07-05T16:46:00.707322400+08:00] libcontainerd: new containerd process, pid: 1573
WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=65536
INFO[2019-07-05T16:46:01.739948500+08:00] [graphdriver] using prior storage driver: overlay2
INFO[2019-07-05T16:46:01.782012800+08:00] Graph migration to content-addressability took 0.00 seconds
WARN[2019-07-05T16:46:01.782616800+08:00] Your kernel does not support cgroup memory limit
WARN[2019-07-05T16:46:01.782894700+08:00] Unable to find cpu cgroup <span class="pl-k">in</span> mounts
WARN[2019-07-05T16:46:01.783166700+08:00] Unable to find blkio cgroup <span class="pl-k">in</span> mounts
WARN[2019-07-05T16:46:01.783375800+08:00] Unable to find cpuset cgroup <span class="pl-k">in</span> mounts
WARN[2019-07-05T16:46:01.783676600+08:00] mountpoint <span class="pl-k">for</span> pids not found
Error starting daemon: Devices cgroup isn<span class="pl-s"><span class="pl-pds">'</span>t mounted</span></pre></div>
<p>解决办法：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 安装并挂载 cgroup</span>
sudo apt -y install cgroupfs-mount
sudo cgroupfs-mount</pre></div>
</li>
<li>
<p>再启动还会报错：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 使用非管理员权限运行</span>
Error starting daemon: Error initializing network controller: error obtaining controller instance: failed to create NAT chain: iptables failed: iptables -t nat -N DOCKER: iptables v1.6.0: can<span class="pl-s"><span class="pl-pds">'</span>t initialize iptables table `nat<span class="pl-pds">'</span></span>: Table does not exist (do you need to insmod<span class="pl-k">?</span>)
Perhaps iptables or your kernel needs to be upgraded.
 (exit status 3)
 
<span class="pl-c"><span class="pl-c">#</span> 使用管理员权限运行</span>
Error starting daemon: Error initializing network controller: Error creating default <span class="pl-s"><span class="pl-pds">"</span>bridge<span class="pl-pds">"</span></span> network: Failed to Setup IP tables: Unable to <span class="pl-c1">enable</span> NAT rule:  (iptables failed: iptables --wait -t nat -I POSTROUTING -s 172.19.0.0/16 <span class="pl-k">!</span> -o docker0 -j MASQUERADE: iptables: Invalid argument. Run <span class="pl-s"><span class="pl-pds">`</span>dmesg<span class="pl-s"><span class="pl-pds">'</span> for more information.</span></span>
<span class="pl-s"><span class="pl-s"> (exit status 1))</span></span></pre></div>
<p>原因是 <strong>iptables</strong> 功能缺失，禁用就好了 ( <a href="https://github.com/Microsoft/WSL/issues/2291#issuecomment-475894869" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2291/hovercard">参考</a> ) 。</p>
<div class="highlight highlight-source-shell"><pre>dockerd --iptables=false</pre></div>
<p>其实，只有针对 <strong>172.17.0.0/16</strong> 网段执行时不会报错的，而且 <strong>MASQUERADE</strong> 规则是可以生效的 ( 容器可以访问外网 ) 。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> iptables --wait -t nat -I POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span>
<span class="pl-c"><span class="pl-c">#</span> iptables --wait -t nat -I POSTROUTING -s 172.19.0.0/16 ! -o docker0 -j MASQUERADE</span>
iptables: No chain/target/match by that name.</pre></div>
<p>所以，安装完 <strong>docker</strong> 后先不禁用 <strong>iptables</strong> 来启动一遍 <strong>dockerd</strong> ，让它自动生成 <strong>docker0</strong> 网络并自动配置 <strong>SNAT</strong> ，之后就禁用 <strong>iptables</strong> 启动 <strong>dockerd</strong> ，这样用到 <strong>docker-compose</strong> 或者创建其他网桥网络时就不会报错了，只不过其他网络无法访问外网 ( 这个问题后面来解决 ) 。</p>
</li>
<li>
<p>然后还会报错：</p>
<div class="highlight highlight-source-shell"><pre>Error starting daemon: Error initializing network controller: Error creating default <span class="pl-s"><span class="pl-pds">"</span>bridge<span class="pl-pds">"</span></span> network: permission denied</pre></div>
<p>原因是创建网桥的命令权限不足，比如第一次创建的 <strong>docker0</strong> 和 之后使用 <code>docker network create</code> 命令创建的自定义网络都需要 <strong>管理员权限</strong> 。</p>
<p><strong>解决办法</strong>: 以 <strong>管理员权限</strong> 打开 <strong>CMD</strong> 来运行 <strong>dockerd</strong> 。</p>
<p>顺带提一点，<strong>WSL</strong> 下有些缺失的功能可能已经实现了部分实验功能 ( <a href="https://github.com/microsoft/WSL/issues/767#issuecomment-392944625" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/767/hovercard">比如</a> ) ，在 <strong>管理员权限</strong> 下可以试试看。</p>
</li>
</ul>
<h3>网络配置</h3>
<hr>
<ul>
<li>
<p><strong>ping</strong> 容器</p>
<p><strong>Windows</strong> 防火墙添加入站规则 - <strong>ICMPv4</strong> 类型的协议 ( <a href="https://blog.csdn.net/wy_bk/article/details/85013933" rel="nofollow">参考</a> )</p>
</li>
<li>
<p>端口映射的问题</p>
<p>比如启动一个 <strong>Nginx</strong> 服务，做端口映射，在 <strong>Win10 1803</strong> 上会发现无法访问 <strong>127.0.0.1:3000</strong></p>
<div class="highlight highlight-source-shell"><pre>docker run -it --rm -p 3000:80 nginx</pre></div>
<p>接着在 <strong>Win10 1809</strong> 上试了是可以访问的，然而换成 <strong>Tomcat</strong> 容器后就又不行了，而且 <strong>宿主机</strong> 也无法通过 <strong>容器</strong> 的 <strong>内网 IP + 端口</strong> 来访问，怀疑是网桥或者路由表的配置有缺失。于是定制了一个安装各种网络工具包的镜像进行各种测试，发现把 <strong>Tomcat</strong> 的监听端口改为 <strong>80</strong> 就可以了。通过这个现象想起来可能是防火墙的原因，而 <strong>WSL</strong> 中 <strong>iptables</strong> 功能有缺失应该是不起作用的，那么问题应该是出在 <strong>Win10</strong> 的防火墙上。果然，在防火墙中添加 <strong>入站规则</strong> 放行容器中的监听端口 ( 比如 <strong>8080</strong> ) 就解决了，我猜应该是容器中使用了 <strong>Windows</strong> 下的防火墙做拦截，而 <strong>宿主机</strong> 却被当成了外来者。</p>
<p><strong>注意：</strong></p>
<ul>
<li>可以简单粗暴的把 <strong>Windows</strong> 下的防火墙先关掉测试。</li>
<li>如果不生效，可以考虑重启 <strong>容器</strong> 、<strong>Docker 服务</strong> 或者电脑。</li>
</ul>
</li>
<li>
<p>容器访问外网</p>
<p>上面也提到了 <strong>iptables</strong> 功能缺失，就做不了 <strong>源网络地址转换 ( SNAT / MASQUERADE )</strong> ，这就导致了容器不能访问外网 ( 容器之间也无法跨网路访问 ) 。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 新建一个自定义网络</span>
docker network create --subnet 172.18.0.0/16 test_net</pre></div>
<p>目前有两种不是很完美的办法来临时解决：</p>
<ul>
<li>
<p>在宿主机搭建代理服务器，在容器中使用代理连接：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 注意: 使用 host 网络</span>
<span class="pl-c"><span class="pl-c">#</span> 另外，防火墙需要按上文方法设置，否则其他容器无法访问宿主机的 8888 端口</span>
docker run -d --name gost --restart always --network host ginuerzh/gost -L=:8888</pre></div>
<p>启动容器的时候配置环境变量 <code>http_proxy</code> 和 <code>https_proxy</code></p>
<div class="highlight highlight-source-shell"><pre>docker run -it --rm --network test_net --entrypoint sh -e http_proxy=http://172.18.0.1:8888 -e https_proxy=http://172.18.0.1:8888 appropriate/curl
curl https://baidu.com</pre></div>
<p>当然，也可以修改配置文件，对之后启动的所有容器生效 ( <a href="https://docs.docker.com/network/proxy/" rel="nofollow">参考</a> )</p>
<div class="highlight highlight-source-shell"><pre>cat <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/.docker/config.json <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s">{</span>
<span class="pl-s"> "proxies":</span>
<span class="pl-s"> {</span>
<span class="pl-s">   "default":</span>
<span class="pl-s">   {</span>
<span class="pl-s">     "httpProxy": "http://172.18.0.1:8888",</span>
<span class="pl-s">     "httpsProxy": "http://172.18.0.1:8888"</span>
<span class="pl-s">   }</span>
<span class="pl-s"> }</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<p>这种方式仅限于 <strong>HTTP</strong> 请求 ( 而且只能使用当前网络的网关 <strong>IP</strong> 来访问代理 ) ，换成低层次的 <strong>TCP</strong> 或者 <strong>UDP</strong> 通讯可能就不行了。</p>
</li>
<li>
<p>类似于 <strong>Windows</strong> 上开 <strong>WiFi 共享</strong> 的操作。</p>
<p><strong>Docker</strong> 创建网络时对应会在 <strong>Windows</strong> 下创建网卡 ( 比如 <strong>IP</strong> 为 <strong>172.18.0.1</strong> ) ，只要把无线网卡或者有线网卡的网络共享给这个新建的网卡，容器就可以通过本地网卡来访问外网了。</p>
<p>具体步骤：</p>
<div class="highlight highlight-source-shell"><pre>1. 在指定网络下启动一个容器 ( 先启动容器再共享网络很重要，否则后面可能不会起作用 )
   docker run -it --rm --network test_net --entrypoint sh -v /etc/resolv.conf:/etc/resolv.conf appropriate/curl
2. Windows 下进入<span class="pl-s"><span class="pl-pds">"</span>控制面板\网络和 Internet\网络连接<span class="pl-pds">"</span></span>
3. 查找网桥 ( 172.18.0.1 ) 对应的网卡，比如 {357fbf18-4a4d-4e22-bf01-43b601b650bd}
4. 选中可用的本地网卡 ( 有线或者无线 ) 右键属性
5. 点击<span class="pl-s"><span class="pl-pds">"</span>共享<span class="pl-pds">"</span></span>选项卡
6. 勾选<span class="pl-s"><span class="pl-pds">"</span>允许其他网络用户通过此计算机的 Internet 连接来连接<span class="pl-pds">"</span></span>，并在下拉框选择上面找到的那个网卡
7. 测试 curl baidu.com</pre></div>
<p>这种方式比起前一种方式支持的网络更完善，缺点就是只能共享网络给一个网卡，而且无法访问其他网络的容器。</p>
<p>如果使用域名无法访问，可能是容器内 <strong>DNS</strong> 解析失败，换个 <strong>DNS</strong> 服务器 ( <strong>/etc/resolv.conf</strong> ) 。</p>
</li>
</ul>
</li>
</ul>
<p>另外，还遇到过一个不是必现的问题，网桥有时候会变成 <strong>169.254.158.185/16</strong> 这种很神奇的 <strong>IP</strong> ，暂时还没找到原因。如果遇到这个问题，可以关掉 <strong>Docker</strong> 后手动删除网桥，让它重新创建。</p>
<p><strong>其实，网络问题的排查无非就是几个点：端口监听，IP 分配、路由表、防火墙、DNS、NAT 。</strong></p>
<h3>其他问题</h3>
<hr>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> <a href="https://www.daocloud.io/mirror#accelerator-doc" rel="nofollow">镜像加速器</a> 可能会不能正常使用 ( <code>1803</code> + <code>17.09.1+</code>  )</p>
<p>表现形式为 <strong>pull</strong> 镜像的时候先从 <strong>镜像站</strong> 下载一遍，再回 <strong>官方源站</strong> 下载一遍。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker pull hello-world</span>
Using default tag: latest
latest: Pulling from library/hello-world
1b930d010525: Extracting [<span class="pl-k">==================================================&gt;</span>]     977B/977B
latest: Pulling from library/hello-world
1b930d010525: Extracting [<span class="pl-k">==================================================&gt;</span>]     977B/977B
failed to register layer: Error processing tar file(exit status 1): invalid argument</pre></div>
<p>暂无解决办法，如果 <strong>源站</strong> 下载过慢可以使用 <strong>HTTP 代理</strong> 或者 <strong>VPN</strong> 。</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> 关于 <strong>WSL</strong> 下 <strong>docker-compose</strong> 的用法和问题参考我的另一篇 <a href="https://www.jianshu.com/p/410ea6e0b13a" rel="nofollow">文章</a> 。</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> 不支持 <strong>docker exec</strong> 命令</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker exec -it nginx sh</span>
oci runtime error: <span class="pl-c1">exec</span> failed: container_linux.go:265: starting container process caused <span class="pl-s"><span class="pl-pds">"</span>could not create session key: function not implemented<span class="pl-pds">"</span></span></pre></div>
<p>解决办法: 使用 <a href="https://github.com/jpetazzo/nsenter">nsenter</a> 命令进入容器 ( <a href="https://www.jianshu.com/p/8ba9a1a17673" rel="nofollow">参考</a> )</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 设置容器名或者id</span>
NAME=nginx
<span class="pl-c"><span class="pl-c">#</span> 进入容器</span>
sudo nsenter -p -i -u -m -n -t <span class="pl-s"><span class="pl-pds">`</span>docker inspect -f {{.State.Pid}} <span class="pl-smi">${NAME}</span><span class="pl-pds">`</span></span> sh</pre></div>
<p>应该已经内置 <code>nsenter</code> 命令了，如果没有的话自行安装。</p>
<p>可以写一个函数来简化调用：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 添加函数</span>
cat <span class="pl-k">&gt;&gt;</span> <span class="pl-k">~</span>/.bashrc <span class="pl-s"><span class="pl-k">&lt;&lt;</span> "<span class="pl-k">EOF</span>"</span>
<span class="pl-s"></span>
<span class="pl-s">function docker-exec {</span>
<span class="pl-s">    name=$1</span>
<span class="pl-s">    shift</span>
<span class="pl-s">    nsenter -p -i -u -m -n -t `docker inspect -f {{.State.Pid}} ${name}` "$@"</span>
<span class="pl-s">}</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c"><span class="pl-c">#</span> 重新加载配置</span>
<span class="pl-c1">.</span> <span class="pl-k">~</span>/.bashrc</pre></div>
<p>再次调用就简单多了：</p>
<div class="highlight highlight-source-shell"><pre>docker-exec nginx sh</pre></div>
</li>
<li class="task-list-item">
<p><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> 容器内文件读写权限有问题</p>
<p>可能是文件系统的问题也可能是容器用户的权限问题</p>
<p>比如运行数据库之类的容器会提示权限不足的错误，比如：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> docker run -it --rm --network host neo4j</span>
Active database: graph.db
/var/lib/neo4j/bin/neo4j: line 283: cannot create temp file <span class="pl-k">for</span> here-document: Permission denied</pre></div>
<p>从错误信息看出是 <strong>tmp</strong> 目录没有权限，可以在启动容器的时候使用 <strong>挂载数据卷</strong> 的方式来解决：</p>
<div class="highlight highlight-source-shell"><pre>docker run -it --rm --network host -v /tmp:/tmp -v <span class="pl-k">~</span>/.neo4j/certificates:/var/lib/neo4j/certificates neo4j</pre></div>
<p><strong>当然，权限不足的目录可能不止这么一个，需要自己一个个去排查，还是比较麻烦的。</strong></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> 非 <strong>docker0</strong> 网络下 <strong>--link</strong> 失效 ( 不会写入配置到 <strong>/etc/hosts</strong> 中 )</p>
</li>
</ul>
<h3>其他玩法</h3>
<hr>
<p>查资料的过程中发现了另一篇文章—— <a href="https://www.v2ex.com/t/559536" rel="nofollow">用 WSL 运行 Docker 镜像</a> ，虽然没有跑通文章中的例子，但是思路还是很有启发性的。从文章中用法来看，<strong>WSL</strong> 的架构和 <strong>Docker</strong> 还是比较类似的，<strong>WSL</strong> 提供基本的 <strong>内核</strong> ，商店中的各种 <strong>发行版</strong> 等价于 <strong>镜像</strong> 用来提供系统目录和软件包，而每个 <strong>WSL</strong> 实例则等价于 <strong>容器</strong> 。</p>
<p>如果 <strong>WSL</strong> 后续能够原生支持从 <strong>Docker Hub</strong> 下载镜像，同时支持类似于 <strong>Docker</strong> 一样的命令来管理 <strong>WSL</strong> 实例，岂不是一件很酷的事？</p>
<h3>参考文章</h3>
<hr>
<ul>
<li>
<p><a href="https://medium.com/faun/docker-running-seamlessly-in-windows-subsystem-linux-6ef8412377aa" rel="nofollow">Docker Running Seamlessly in Windows Subsystem Linux</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/LiangSW/p/9842295.html" rel="nofollow">wsl中使用原生docker</a></p>
</li>
<li>
<p><a href="https://github.com/Microsoft/WSL/issues/2291#issuecomment-383698720" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2291/hovercard">WSL/issues/2291#issuecomment-383698720</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/bashonubuntuonwindows/comments/8cvr27/docker_is_running_natively_on_wsl/" rel="nofollow">docker is running natively on wsl</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/nb/13876015" rel="nofollow">Docker 相关资料</a></p>
</li>
</ul>
<h3>写在最后</h3>
<hr>
<p>在 <strong>WSL</strong> 上成功运行 <strong>Docker</strong> 其实就几分钟的事，不过为了解决上面提到的一些问题又断断续续花了几天时间，重装了几十遍 <strong>WSL</strong>，也不断测试并修正了文中的例子，希望没有纰漏吧。</p>
<p>自从写完 <a href="https://www.jianshu.com/p/bc38ed12da1d" rel="nofollow">Windows10内置Linux子系统初体验</a> 一文已是两年过去了，见证了 <strong>WSL</strong> 从鸡肋到现在基本满足使用的过程，虽然还不是很完美，但它一直在不断完善，而我也会持续关注并更新下去。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/20ebdbf68744">https://www.jianshu.com/p/20ebdbf68744</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot 集成 Neo4j]]></title>
            <link>https://anyesu.github.io/blog/articles/35</link>
            <guid>35</guid>
            <pubDate>Sun, 29 Sep 2019 15:06:01 GMT</pubDate>
            <description><![CDATA[文档未完成，参考 源码]]></description>
            <content:encoded><![CDATA[<p>文档未完成，参考 <a href="https://github.com/anyesu/spring-boot-demo/tree/master/spring-boot-demo-neo4j">源码</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot 实体类巧用 JSON 类型字段]]></title>
            <link>https://anyesu.github.io/blog/articles/34</link>
            <guid>34</guid>
            <pubDate>Sun, 29 Sep 2019 15:03:16 GMT</pubDate>
            <description><![CDATA[前言 在上一篇 文章 中已经介绍了 枚举 类型字段的使用，本文接着介绍 JSON 类型字段的使用。 关于 JSON 类型 ( 参考 ) Mysql 5.7 版本 起增加了对 JSON 类型的支持，表现形式类似于加了 JSON 格式校验的 longtext 。有了这个类型我们就可以存储一些非固定的数据结构来灵活应对多变的业务。 使用 拿订单业务举例，一个订单允许购买多件商品，通常会定义两张表，一张 ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在上一篇 <a href="https://www.jianshu.com/p/34212407037e" rel="nofollow">文章</a> 中已经介绍了 <strong>枚举</strong> 类型字段的使用，本文接着介绍 <strong>JSON</strong> 类型字段的使用。</p>
<h3>关于 JSON 类型 ( <a href="https://www.cnblogs.com/ooo0/p/9309277.html" rel="nofollow">参考</a> )</h3>
<hr>
<p><strong>Mysql 5.7 版本</strong> 起增加了对 <strong>JSON</strong> 类型的支持，表现形式类似于加了 <strong>JSON</strong> 格式校验的 <strong>longtext</strong> 。有了这个类型我们就可以存储一些非固定的数据结构来灵活应对多变的业务。</p>
<h3>使用</h3>
<hr>
<p>拿订单业务举例，一个订单允许购买多件商品，通常会定义两张表，一张 <strong>订单表</strong> 和一张 <strong>订单商品表</strong> ，然后进行关联查询。</p>
<ul>
<li>
<p>如果用了 <strong>JSON</strong> 类型就只需一张表了：</p>
<div class="highlight highlight-source-sql"><pre><span class="pl-k">DROP</span> <span class="pl-k">TABLE</span> IF EXISTS <span class="pl-s"><span class="pl-pds">`</span>order<span class="pl-pds">`</span></span>;
<span class="pl-k">CREATE</span> <span class="pl-k">TABLE</span> `<span class="pl-en">order</span>` (
  id <span class="pl-k">int</span>(<span class="pl-c1">11</span>) <span class="pl-k">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="pl-s"><span class="pl-pds">'</span>主键<span class="pl-pds">'</span></span>,
  orderNo <span class="pl-k">varchar</span>(<span class="pl-c1">40</span>) <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>订单号<span class="pl-pds">'</span></span>,
  status <span class="pl-k">tinyint</span>(<span class="pl-c1">1</span>) <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>订单状态<span class="pl-pds">'</span></span>,
  address json <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>收货地址<span class="pl-pds">'</span></span>,
  orderGoods json <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>订单商品<span class="pl-pds">'</span></span>,
  <span class="pl-k">PRIMARY KEY</span> (id)
) ENGINE<span class="pl-k">=</span>InnoDB DEFAULT CHARSET<span class="pl-k">=</span>utf8;</pre></div>
<p><strong>注意: 请结合实际情况设计表结构，此处是为了演示效果。</strong></p>
</li>
<li>
<p>对应实体类 :</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Data</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Order</span> <span class="pl-k">implements</span> <span class="pl-e">Serializable</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 订单号</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> orderNo;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 订单状态</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">Status</span> status;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 收货地址</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">Address</span> address;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 订单商品</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">List&lt;<span class="pl-smi">OrderGoods</span>&gt;</span> orderGoods;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 序列化时显示状态描述</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@return</span></span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getStatusDesc</span>() {
        <span class="pl-k">return</span> status <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">null</span> <span class="pl-k">:</span> status<span class="pl-k">.</span>desc();
    }
    
}</pre></div>
</li>
<li>
<p>地址类：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Data</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Address</span> <span class="pl-k">implements</span> <span class="pl-e">Serializable</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 手机</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> mobile;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 收货人姓名</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> receiver;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 详细地址</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> adr;
    
}</pre></div>
</li>
</ul>
<h3>DAO 层处理</h3>
<hr>
<p>由于使用 <strong>Mybatis</strong> 作为 <strong>ORM</strong> 框架，这里使用 <strong>Mybatis</strong> 提供的 <strong>TypeHandler</strong> 实现 <strong>枚举类型</strong> 的 <strong>序列化</strong> 和 <strong>反序列化</strong> 。</p>
<ul>
<li>
<p>实现一个自定义的通用的 <strong>TypeHandler</strong></p>
<div class="highlight highlight-source-java"><pre><span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * JSON 类型-类型转换器</span>
<span class="pl-c"> * &lt;<span class="pl-ent">p</span>&gt;</span>
<span class="pl-c"> * 由于 Mybatis 对泛型嵌套做了处理，T 为泛型类型时会被转为 rawType，所以要注意以下两点：</span>
<span class="pl-c"> * &lt;<span class="pl-ent">p</span>&gt;</span>
<span class="pl-c"> * 1. 不要使用父类的 rawType 属性，使用本类的 type 属性来做类型转换</span>
<span class="pl-c"> * 2. 需要做类型转换的字段要指定 TypeHandler，而不能由 Mybatis 自动查找</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * <span class="pl-k">@author</span> anyesu</span>
<span class="pl-c"> * <span class="pl-k">@see</span> org.apache.ibatis.type.TypeReference#getSuperclassTypeParameter</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">@Slf4j</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">JsonTypeHandler</span>&lt;T&gt; <span class="pl-k">extends</span> <span class="pl-e">BaseTypeHandler&lt;<span class="pl-smi">T</span>&gt;</span> {

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">Type</span> type;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 只能由子类调用</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">protected</span> <span class="pl-en">JsonTypeHandler</span>() {
        type <span class="pl-k">=</span> <span class="pl-smi">GenericsUtils</span><span class="pl-k">.</span>getSuperClassGenericType(getClass());
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 由 Mybatis 根据类型动态生成实例</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> type</span>
<span class="pl-c">     * <span class="pl-k">@see</span> org.apache.ibatis.type.TypeHandlerRegistry#getInstance(Class, Class)</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">public</span> <span class="pl-en">JsonTypeHandler</span>(<span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-v">rawClass</span>) {
        <span class="pl-c1">this</span><span class="pl-k">.</span>type <span class="pl-k">=</span> rawClass;
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setNonNullParameter</span>(<span class="pl-smi">PreparedStatement</span> <span class="pl-v">ps</span>, <span class="pl-k">int</span> <span class="pl-v">i</span>, <span class="pl-smi">T</span> <span class="pl-v">parameter</span>, <span class="pl-smi">JdbcType</span> <span class="pl-v">jdbcType</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        ps<span class="pl-k">.</span>setString(i, <span class="pl-c1">this</span><span class="pl-k">.</span>toJson(parameter));
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">ResultSet</span> <span class="pl-v">rs</span>, <span class="pl-smi">String</span> <span class="pl-v">columnName</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> <span class="pl-c1">this</span><span class="pl-k">.</span>toObject(rs<span class="pl-k">.</span>getString(columnName));
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">ResultSet</span> <span class="pl-v">rs</span>, <span class="pl-k">int</span> <span class="pl-v">columnIndex</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> <span class="pl-c1">this</span><span class="pl-k">.</span>toObject(rs<span class="pl-k">.</span>getString(columnIndex));
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">CallableStatement</span> <span class="pl-v">cs</span>, <span class="pl-k">int</span> <span class="pl-v">columnIndex</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> <span class="pl-c1">this</span><span class="pl-k">.</span>toObject(cs<span class="pl-k">.</span>getString(columnIndex));
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> object</span>
<span class="pl-c">     * <span class="pl-k">@return</span></span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-en">toJson</span>(<span class="pl-smi">T</span> <span class="pl-v">object</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">JSON</span><span class="pl-k">.</span>toJSONString(object);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 反序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> content</span>
<span class="pl-c">     * <span class="pl-k">@return</span></span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">T</span> <span class="pl-en">toObject</span>(<span class="pl-smi">String</span> <span class="pl-v">content</span>) {
        <span class="pl-smi">T</span> object <span class="pl-k">=</span> <span class="pl-c1">null</span>;

        <span class="pl-k">if</span> (content <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> content<span class="pl-k">.</span>length() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">try</span> {
                object <span class="pl-k">=</span> <span class="pl-c1">JSON</span><span class="pl-k">.</span>parseObject(content, getType());
            } <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> e) {
                log<span class="pl-k">.</span>error(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, e);
            }
        }

        <span class="pl-k">return</span> object;
    }

    <span class="pl-k">public</span> <span class="pl-smi">Type</span> <span class="pl-en">getType</span>() {
        <span class="pl-k">return</span> type;
    }

}</pre></div>
</li>
<li>
<p>注册 <strong>JsonTypeHandler</strong></p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Configuration</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MybatisTypeHandlerConfiguration</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册 Mybatis 类型转换器</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@Autowired</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">registerTypeHandlers</span>() {
        jsonTypes()<span class="pl-k">.</span>forEach(<span class="pl-c1">this</span><span class="pl-k">::</span>registerJsonTypeHandler);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册 JSON 类型的类型转换器</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> javaTypeClass Java 类型</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">registerJsonTypeHandler</span>(<span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">javaTypeClass</span>) {
        register(javaTypeClass, <span class="pl-smi">JsonTypeHandler</span><span class="pl-k">.</span>class);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册类型转换器</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> javaTypeClass    Java 类型</span>
<span class="pl-c">     * <span class="pl-k">@param</span> typeHandlerClass 类型转换器类型</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">register</span>(<span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">javaTypeClass</span>, <span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">typeHandlerClass</span>) {
        <span class="pl-c1">this</span><span class="pl-k">.</span>typeHandlerRegistry<span class="pl-k">.</span>register(javaTypeClass, typeHandlerClass);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 简单 JSON 类型</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@return</span></span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">List&lt;<span class="pl-k">Class&lt;?&gt;</span>&gt;</span> <span class="pl-en">jsonTypes</span>() {
        <span class="pl-c"><span class="pl-c">//</span> TODO 这里为了方便就硬编码记录类型，自行替换扫描的方式</span>
        <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(<span class="pl-smi">Address</span><span class="pl-k">.</span>class);
    }

}</pre></div>
</li>
</ul>
<p>上面的方式只是注册了 <strong>Address</strong> 类的类型转换器，对于 <strong>List</strong> 这种 <strong>泛型类型</strong> 则无法使用这种方式注册，需要使用下面的方法：</p>
<ul>
<li>
<p>实现 <strong>JsonTypeHandler</strong> 的子类</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">OrderGoodsListTypeHandler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonTypeHandler&lt;<span class="pl-k">List&lt;<span class="pl-smi">OrderGoods</span>&gt;</span>&gt;</span> {
}</pre></div>
</li>
<li>
<p>然后修改 <strong>application.yml</strong> 让 <strong>Mybatis</strong> 去扫描注册自定义的 <strong>TypeHandler</strong> :</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">mybatis</span>:
  <span class="pl-ent">type-handlers-package</span>: <span class="pl-s">com.github.anyesu.common.typehandler</span></pre></div>
</li>
<li>
<p>然后在 <strong>Mapper</strong> 中显式指定 <strong>typeHandler</strong></p>
<div class="highlight highlight-source-sql"><pre><span class="pl-k">&lt;</span><span class="pl-k">update</span> id<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>updateByPrimaryKey<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
    <span class="pl-k">update</span> <span class="pl-s"><span class="pl-pds">`</span>order<span class="pl-pds">`</span></span>
    <span class="pl-k">set</span> orderNo <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{orderNo},</span>
        status <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{status},</span>
        address <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{address},</span>
        orderGoods <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{orderGoods, typeHandler=com.github.anyesu.common.typehandler.OrderGoodsListTypeHandler}</span>
    <span class="pl-k">where</span> id <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{id}</span>
<span class="pl-k">&lt;</span><span class="pl-k">/</span><span class="pl-k">update</span><span class="pl-k">&gt;</span></pre></div>
<p><strong>注意: 如果 orderGoods 字段不指定 typeHandler 会被识别为 Object 类型并使用 ObjectTypeHandler 来转换，因此会导致错误。</strong></p>
<p>另外，如果使用了 <strong>set 标签</strong>，<strong>orderGoods</strong> 能被为 <strong>List</strong> 类型，而 <strong>OrderGoodsListTypeHandler</strong> 被注册为 <strong>List</strong> 类型的类型转换器，所以能正常执行。( 最好还是显式指定 <strong>typeHandler</strong> )</p>
<div class="highlight highlight-source-sql"><pre><span class="pl-k">&lt;</span><span class="pl-k">update</span> id<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>updateByPrimaryKeySelective<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
    <span class="pl-k">update</span> <span class="pl-s"><span class="pl-pds">`</span>order<span class="pl-pds">`</span></span>
    <span class="pl-k">&lt;</span><span class="pl-k">set</span><span class="pl-k">&gt;</span>
        <span class="pl-k">&lt;</span>if test<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>orderNo != null<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
            orderNo <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{orderNo},</span>
        <span class="pl-k">&lt;</span><span class="pl-k">/</span>if<span class="pl-k">&gt;</span>
        <span class="pl-k">&lt;</span>if test<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>status != null<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
            status <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{status},</span>
        <span class="pl-k">&lt;</span><span class="pl-k">/</span>if<span class="pl-k">&gt;</span>
        <span class="pl-k">&lt;</span>if test<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>address != null<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
            address <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{address},</span>
        <span class="pl-k">&lt;</span><span class="pl-k">/</span>if<span class="pl-k">&gt;</span>
        <span class="pl-k">&lt;</span>!<span class="pl-c"><span class="pl-c">--</span> 包裹在 set 标签内被正确识别为 List 类型 --&gt;</span>
        <span class="pl-k">&lt;</span>!<span class="pl-c"><span class="pl-c">--</span> 最好还是显式指定类型转换器 --&gt;</span>
        <span class="pl-k">&lt;</span>if test<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>orderGoods != null<span class="pl-pds">"</span></span><span class="pl-k">&gt;</span>
            orderGoods <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{orderGoods}</span>
        <span class="pl-k">&lt;</span><span class="pl-k">/</span>if<span class="pl-k">&gt;</span>
    <span class="pl-k">&lt;</span><span class="pl-k">/</span><span class="pl-k">set</span><span class="pl-k">&gt;</span>
    <span class="pl-k">where</span> id <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">#</span>{id}</span>
<span class="pl-k">&lt;</span><span class="pl-k">/</span><span class="pl-k">update</span><span class="pl-k">&gt;</span></pre></div>
</li>
</ul>
<h3>源码</h3>
<hr>
<p>篇幅有限，上面代码并不完整，点击 <a href="https://github.com/anyesu/spring-boot-demo/tree/master/spring-boot-demo-customized-field-type">这里</a> 查看完整代码。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/7d24167ccf6d">https://www.jianshu.com/p/7d24167ccf6d</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot 实体类巧用枚举类型字段]]></title>
            <link>https://anyesu.github.io/blog/articles/33</link>
            <guid>33</guid>
            <pubDate>Sun, 29 Sep 2019 14:47:08 GMT</pubDate>
            <description><![CDATA[前言 定义表结构的时候经常会碰到一类字段：状态 ( status 或者 state ) 、类型 ( type ) ，而通常的做法一般是： 数据库 中定义 tinyint 类型。 比如：status tinyint(1) NOT NULL COMMENT '订单状态 1-待支付;2-待发货;3-待收货;4-已收货;5-已完结;' Java 实体类 中定义 Short 类型。( 也见识过用 Byte ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>定义表结构的时候经常会碰到一类字段：<strong>状态</strong> ( <strong>status</strong> 或者 <strong>state</strong> ) 、<strong>类型</strong> ( <strong>type</strong> ) ，而通常的做法一般是：</p>
<ul>
<li>
<p><strong>数据库</strong> 中定义 <strong>tinyint</strong> 类型。</p>
<p>比如：<strong>status tinyint(1) NOT NULL COMMENT '订单状态 1-待支付;2-待发货;3-待收货;4-已收货;5-已完结;'</strong></p>
</li>
<li>
<p><strong>Java 实体类</strong> 中定义 <strong>Short</strong> 类型。( 也见识过用 <strong>Byte</strong> 类型的，看着怪怪的 )</p>
<p>比如：<strong>private Short status</strong></p>
</li>
</ul>
<p>然后项目中可能会充斥着下面这样的代码：</p>
<div class="highlight highlight-source-java"><pre>order<span class="pl-k">.</span>setStatus((<span class="pl-k">short</span>) <span class="pl-c1">1</span>);

<span class="pl-k">if</span> (order<span class="pl-k">.</span>getStatus() <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
    order<span class="pl-k">.</span>setStatus((<span class="pl-k">short</span>) <span class="pl-c1">2</span>);
}

<span class="pl-k">if</span> (order<span class="pl-k">.</span>getStatus() <span class="pl-k">==</span> <span class="pl-c1">4</span>) {
    order<span class="pl-k">.</span>setStatusName(<span class="pl-s"><span class="pl-pds">"</span>已收货<span class="pl-pds">"</span></span>);
}</pre></div>
<p>这都是些什么魔鬼数字啊，没有注释根本没法看，如果手滑可能状态就设错了，而且不好排查是在哪处赋值的。</p>
<p>改进方案是用 <strong>常量</strong> ，但是又会产生另一种效果：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Short</span> <span class="pl-c1">WAIT_PAY</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-k">if</span> (<span class="pl-c1">WAIT_PAY</span><span class="pl-k">.</span>equals(order<span class="pl-k">.</span>getStatus())) {
    <span class="pl-c"><span class="pl-c">//</span> 混用了解下</span>
    order<span class="pl-k">.</span>setStatus((<span class="pl-k">short</span>) <span class="pl-c1">2</span>);
}</pre></div>
<p>这时候就该 <strong>枚举</strong> 出场了，<strong>枚举</strong> 的本质就是 <strong>类 + 常量</strong> ，可以使用 <strong>枚举</strong> 来定义 <strong>一组</strong> 相关的元数据 ( 值、描述及其他必要信息 ) ，使用 <strong>枚举</strong> 类型不仅减小了数据维护 ( 比如调整了值的定义 ) 的成本，还加强了代码的 <strong>约束力</strong> 。</p>
<p>下文就来介绍如何在项目中 "完美" 使用 <strong>枚举</strong> 类型。</p>
<h3>需要修改的地方</h3>
<hr>
<ul>
<li>
<p>解析 <strong>RequestParam</strong> 将值转为 <strong>枚举</strong> 类型。( 只做反序列化 )</p>
</li>
<li>
<p>解析 <strong>RequestBody</strong> 将相应字段值转为 <strong>枚举</strong> 类型，<strong>ResponseBody</strong> 将 <strong>枚举</strong> 字段转为 <strong>实际的值</strong> 。</p>
</li>
<li>
<p>保存到数据库的时候将 <strong>枚举</strong> 值转换为 <strong>实际的值</strong> ，从数据库读取数据的时候将 <strong>实际的值</strong> 转为 <strong>枚举</strong> 值。</p>
</li>
</ul>
<p>主要是这三处地方的改动，其他地方按需调整。</p>
<h3>准备工作</h3>
<hr>
<ul>
<li>
<p>表结构：</p>
<div class="highlight highlight-source-sql"><pre><span class="pl-k">DROP</span> <span class="pl-k">TABLE</span> IF EXISTS <span class="pl-s"><span class="pl-pds">`</span>order<span class="pl-pds">`</span></span>;
<span class="pl-k">CREATE</span> <span class="pl-k">TABLE</span> `<span class="pl-en">order</span>` (
  id <span class="pl-k">int</span>(<span class="pl-c1">11</span>) <span class="pl-k">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="pl-s"><span class="pl-pds">'</span>主键<span class="pl-pds">'</span></span>,
  orderNo <span class="pl-k">varchar</span>(<span class="pl-c1">40</span>) <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>订单号<span class="pl-pds">'</span></span>,
  status <span class="pl-k">tinyint</span>(<span class="pl-c1">1</span>) <span class="pl-k">NOT NULL</span> COMMENT <span class="pl-s"><span class="pl-pds">'</span>订单状态<span class="pl-pds">'</span></span>,
  <span class="pl-k">PRIMARY KEY</span> (id)
) ENGINE<span class="pl-k">=</span>InnoDB DEFAULT CHARSET<span class="pl-k">=</span>utf8;</pre></div>
</li>
<li>
<p>实体类：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Data</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Order</span> <span class="pl-k">implements</span> <span class="pl-e">Serializable</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 主键</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">Integer</span> id;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 订单号</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> orderNo;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 订单状态</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-smi">Status</span> status;
    
}</pre></div>
</li>
<li>
<p>枚举类：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@AllArgsConstructor</span>
<span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">Status</span> <span class="pl-k">implements</span> <span class="pl-e">EnumValue</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 已取消</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">CANCEL</span>((<span class="pl-k">short</span>) <span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>已取消<span class="pl-pds">"</span></span>),

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 待支付</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">WAIT_PAY</span>((<span class="pl-k">short</span>) <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>待支付<span class="pl-pds">"</span></span>),

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 待发货</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">WAIT_TRANSFER</span>((<span class="pl-k">short</span>) <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>待发货<span class="pl-pds">"</span></span>),

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 待收货</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">WAIT_RECEIPT</span>((<span class="pl-k">short</span>) <span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">"</span>待收货<span class="pl-pds">"</span></span>),

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 已收货</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">RECEIVE</span>((<span class="pl-k">short</span>) <span class="pl-c1">4</span>, <span class="pl-s"><span class="pl-pds">"</span>已收货<span class="pl-pds">"</span></span>),

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 已完结</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-c1">COMPLETE</span>((<span class="pl-k">short</span>) <span class="pl-c1">5</span>, <span class="pl-s"><span class="pl-pds">"</span>已完结<span class="pl-pds">"</span></span>);

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">Short</span> value;

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> desc;

    <span class="pl-k">public</span> <span class="pl-smi">Short</span> <span class="pl-en">value</span>() {
        <span class="pl-k">return</span> value;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">desc</span>() {
        <span class="pl-k">return</span> desc;
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">Object</span> <span class="pl-en">toValue</span>() {
        <span class="pl-k">return</span> value;
    }

}</pre></div>
</li>
<li>
<p>定义接口 <strong>EnumValue</strong> 来标识自定义的 <strong>枚举</strong> 类型。</p>
<p>同时它还负责 <strong>序列化</strong> 和 <strong>反序列化</strong> 枚举类，这是本文的 <strong>关键</strong> 。</p>
<div class="highlight highlight-source-java"><pre><span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 自定义枚举类型基础接口</span>
<span class="pl-c"> * &lt;<span class="pl-ent">p</span>&gt;</span>
<span class="pl-c"> * 用于扫描、序列化、反序列化实际枚举类</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * <span class="pl-k">@author</span> anyesu</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">EnumValue</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@return</span> 不允许返回 null</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-smi">Object</span> <span class="pl-en">toValue</span>();

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 反序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> enumType 实际枚举类型</span>
<span class="pl-c">     * <span class="pl-k">@param</span> value    当前值</span>
<span class="pl-c">     * <span class="pl-k">@param</span> &lt;T&gt;      枚举类型并且实现 {<span class="pl-k">@link</span> EnumValue} 接口</span>
<span class="pl-c">     * <span class="pl-k">@return</span> 枚举常量</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">static</span> <span class="pl-k">&lt;<span class="pl-smi">T</span> extends <span class="pl-k">Enum&lt;<span class="pl-smi">T</span>&gt;</span> &amp; <span class="pl-smi">EnumValue</span>&gt;</span> <span class="pl-smi">T</span> <span class="pl-en">valueOf</span>(<span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-v">enumType</span>, <span class="pl-smi">Object</span> <span class="pl-v">value</span>) {
        <span class="pl-k">if</span> (enumType <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">||</span> value <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }

        <span class="pl-k">T</span>[] enumConstants <span class="pl-k">=</span> enumType<span class="pl-k">.</span>getEnumConstants();
        <span class="pl-k">for</span> (<span class="pl-smi">T</span> enumConstant <span class="pl-k">:</span> enumConstants) {
            <span class="pl-smi">Object</span> enumValue <span class="pl-k">=</span> enumConstant<span class="pl-k">.</span>toValue();
            <span class="pl-k">if</span> (<span class="pl-smi">Objects</span><span class="pl-k">.</span>equals(enumValue, value)
                    <span class="pl-k">||</span> <span class="pl-smi">Objects</span><span class="pl-k">.</span>equals(enumValue<span class="pl-k">.</span>toString(), value<span class="pl-k">.</span>toString())) {
                <span class="pl-k">return</span> enumConstant;
            }
        }

        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

}</pre></div>
</li>
<li>
<p>用法：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-smi">Order</span> order <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Order</span>();

<span class="pl-c"><span class="pl-c">//</span> 设置订单状态</span>
order<span class="pl-k">.</span>setStatus(<span class="pl-smi">Status</span><span class="pl-c1"><span class="pl-k">.</span>COMPLETE</span>);

<span class="pl-c"><span class="pl-c">//</span> 打印订单状态描述</span>
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(order<span class="pl-k">.</span>getStatus()<span class="pl-k">.</span>desc());</pre></div>
</li>
</ul>
<h3>解析 RequestParam</h3>
<hr>
<p>这部分比较简单。</p>
<ul>
<li>
<p>实现一个自定义的 <strong>Spring  Converter</strong> 就可以实现 <strong>数字或者字符串类型</strong> 到 <strong>枚举类型</strong> 的转换。</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-k">class</span> <span class="pl-en">StringToEnumConverterFactory</span> <span class="pl-k">implements</span> <span class="pl-e">ConverterFactory&lt;<span class="pl-smi">String</span>, <span class="pl-smi">EnumValue</span>&gt;</span> {

    <span class="pl-k">@Override</span>
    <span class="pl-k">@SuppressWarnings</span>(<span class="pl-s"><span class="pl-pds">"</span>unchecked<span class="pl-pds">"</span></span>)
    <span class="pl-k">public</span> <span class="pl-k">&lt;<span class="pl-smi">T</span> extends <span class="pl-smi">EnumValue</span>&gt;</span> <span class="pl-k">Converter&lt;<span class="pl-smi">String</span>, <span class="pl-smi">T</span>&gt;</span> <span class="pl-en">getConverter</span>(<span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-v">targetType</span>) {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">StringToEnum</span>(targetType);
    }

    <span class="pl-k">private</span> <span class="pl-k">class</span> <span class="pl-en">StringToEnum</span>&lt;T <span class="pl-k">extends</span> <span class="pl-e">Enum&lt;<span class="pl-smi">T</span>&gt;</span> &amp; <span class="pl-e">EnumValue</span>&gt; <span class="pl-k">implements</span> <span class="pl-e">Converter&lt;<span class="pl-smi">String</span>, <span class="pl-smi">T</span>&gt;</span> {

        <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> enumType;

        <span class="pl-en">StringToEnum</span>(<span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-v">enumType</span>) {
            <span class="pl-c1">this</span><span class="pl-k">.</span>enumType <span class="pl-k">=</span> enumType;
        }

        <span class="pl-k">@Override</span>
        <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">convert</span>(<span class="pl-smi">String</span> <span class="pl-v">source</span>) {
            source <span class="pl-k">=</span> source<span class="pl-k">.</span>trim();<span class="pl-c"><span class="pl-c">//</span> 去除首尾空白字符</span>
            <span class="pl-k">return</span> source<span class="pl-k">.</span>isEmpty() <span class="pl-k">?</span> <span class="pl-c1">null</span> <span class="pl-k">:</span> <span class="pl-smi">EnumValue</span><span class="pl-k">.</span>valueOf(<span class="pl-c1">this</span><span class="pl-k">.</span>enumType, source);
        }
    }

}</pre></div>
</li>
<li>
<p>然后在 <strong>WebMvcConfigurer</strong> 中注册它</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Override</span>
<span class="pl-k">public</span> <span class="pl-k">void</span> addFormatters(<span class="pl-smi">FormatterRegistry</span> registry) {
    registry<span class="pl-k">.</span>addConverterFactory(<span class="pl-k">new</span> <span class="pl-smi">StringToEnumConverterFactory</span>());
}</pre></div>
<p><strong>Spring</strong> 本身已经集成了 <strong>StringToEnumConverterFactory</strong> 对 <strong>Enum</strong> 类型进行解析，不要和自己定义的 <strong>Converter</strong> 搞混了。</p>
</li>
<li>
<p>定义一个 <strong>RequestMapping</strong></p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@RestController</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestController</span> {

    <span class="pl-k">@RequestMapping</span>(<span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span>)
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">test</span>(<span class="pl-k">@RequestParam</span>(<span class="pl-c1">required</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>) <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
        <span class="pl-k">return</span> status <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">"</span>无值<span class="pl-pds">"</span></span> <span class="pl-k">:</span> status<span class="pl-k">.</span>desc();
    }
    
}</pre></div>
</li>
<li>
<p>访问看下效果：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> curl http://127.0.0.1:8080/test?status=2</span>
<span class="pl-s"><span class="pl-pds">"</span>待发货<span class="pl-pds">"</span></span></pre></div>
</li>
</ul>
<h3>处理 RequestBody 和 ResponseBody</h3>
<hr>
<p><strong>RequestBody</strong> 和 <strong>ResponseBody</strong> 的解析依赖于 <strong>HttpMessageConverter</strong>。因为我使用 <strong>FastJson</strong> 作为 <strong>序列化框架</strong>，所以只需要针对 <strong>FastJsonHttpMessageConverter</strong> 做配置。</p>
<ul>
<li>
<p>实现一个自定义的 <strong>序列化/反序列化器</strong> ( <a href="https://www.cnblogs.com/insaneXs/p/9515803.html" rel="nofollow">参考</a> ) :</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnumConverter</span> <span class="pl-k">implements</span> <span class="pl-e">ObjectSerializer</span>, <span class="pl-e">ObjectDeserializer</span> {

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * fastjson 序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> serializer</span>
<span class="pl-c">     * <span class="pl-k">@param</span> object</span>
<span class="pl-c">     * <span class="pl-k">@param</span> fieldName</span>
<span class="pl-c">     * <span class="pl-k">@param</span> fieldType</span>
<span class="pl-c">     * <span class="pl-k">@param</span> features</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">write</span>(<span class="pl-smi">JSONSerializer</span> <span class="pl-v">serializer</span>, <span class="pl-smi">Object</span> <span class="pl-v">object</span>, <span class="pl-smi">Object</span> <span class="pl-v">fieldName</span>, <span class="pl-smi">Type</span> <span class="pl-v">fieldType</span>, <span class="pl-k">int</span> <span class="pl-v">features</span>) {
        serializer<span class="pl-k">.</span>write(((<span class="pl-smi">EnumValue</span>) object)<span class="pl-k">.</span>toValue());
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getFastMatchToken</span>() {
        <span class="pl-k">return</span> <span class="pl-smi">JSONToken</span><span class="pl-c1"><span class="pl-k">.</span>LITERAL_STRING</span>;
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * fastjson 反序列化</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> parser</span>
<span class="pl-c">     * <span class="pl-k">@param</span> type</span>
<span class="pl-c">     * <span class="pl-k">@param</span> fieldName</span>
<span class="pl-c">     * <span class="pl-k">@param</span> &lt;T&gt;</span>
<span class="pl-c">     * <span class="pl-k">@return</span></span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@Override</span>
    <span class="pl-k">@SuppressWarnings</span>(<span class="pl-s"><span class="pl-pds">"</span>unchecked<span class="pl-pds">"</span></span>)
    <span class="pl-k">public</span> <span class="pl-k">&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-smi">T</span> <span class="pl-en">deserialze</span>(<span class="pl-smi">DefaultJSONParser</span> <span class="pl-v">parser</span>, <span class="pl-smi">Type</span> <span class="pl-v">type</span>, <span class="pl-smi">Object</span> <span class="pl-v">fieldName</span>) {
        <span class="pl-smi">Class</span> enumType <span class="pl-k">=</span> (<span class="pl-smi">Class</span>) type;

        <span class="pl-c"><span class="pl-c">//</span> 类型校验：枚举类型并且实现 EnumValue 接口</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>enumType<span class="pl-k">.</span>isEnum() <span class="pl-k">||</span> <span class="pl-k">!</span><span class="pl-smi">EnumValue</span><span class="pl-k">.</span>class<span class="pl-k">.</span>isAssignableFrom(enumType)) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }

        <span class="pl-k">final</span> <span class="pl-smi">JSONLexer</span> lexer <span class="pl-k">=</span> parser<span class="pl-k">.</span>lexer;
        <span class="pl-k">final</span> <span class="pl-k">int</span> token <span class="pl-k">=</span> lexer<span class="pl-k">.</span>token();
        <span class="pl-smi">Object</span> value <span class="pl-k">=</span> <span class="pl-c1">null</span>;
        <span class="pl-k">if</span> (token <span class="pl-k">==</span> <span class="pl-smi">JSONToken</span><span class="pl-c1"><span class="pl-k">.</span>LITERAL_INT</span>) {
            value <span class="pl-k">=</span> lexer<span class="pl-k">.</span>integerValue();
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (token <span class="pl-k">==</span> <span class="pl-smi">JSONToken</span><span class="pl-c1"><span class="pl-k">.</span>LITERAL_STRING</span>) {
            value <span class="pl-k">=</span> lexer<span class="pl-k">.</span>stringVal();
        } <span class="pl-k">else</span> <span class="pl-k">if</span> (token <span class="pl-k">!=</span> <span class="pl-smi">JSONToken</span><span class="pl-c1"><span class="pl-k">.</span>NULL</span>) {
            value <span class="pl-k">=</span> parser<span class="pl-k">.</span>parse();
        }

        <span class="pl-k">return</span> (<span class="pl-smi">T</span>) <span class="pl-smi">EnumValue</span><span class="pl-k">.</span>valueOf(enumType, value);
    }
}</pre></div>
</li>
<li>
<p>在 <strong>WebMvcConfigurer</strong> 中注册 <strong>类型转换器</strong> 。</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Bean</span>
<span class="pl-smi">FastJsonHttpMessageConverter</span> fastJsonHttpMessageConverter(<span class="pl-smi">FastJsonConfig</span> fastJsonConfig) {
    <span class="pl-smi">FastJsonHttpMessageConverter</span> converter <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">FastJsonHttpMessageConverter</span>();
    converter<span class="pl-k">.</span>setFastJsonConfig(fastJsonConfig);
    converter<span class="pl-k">.</span>setDefaultCharset(<span class="pl-smi">StandardCharsets</span><span class="pl-c1"><span class="pl-k">.</span>UTF_8</span>);
    converter<span class="pl-k">.</span>setSupportedMediaTypes(<span class="pl-smi">Collections</span><span class="pl-k">.</span>singletonList(<span class="pl-smi">MediaType</span><span class="pl-c1"><span class="pl-k">.</span>APPLICATION_JSON_UTF8</span>));
    <span class="pl-k">return</span> converter;
}

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * fastjson 配置</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * <span class="pl-k">@param</span> enumValues 自定义枚举类型 {<span class="pl-k">@link</span> MybatisTypeHandlerConfiguration#enumValues()}</span>
<span class="pl-c"> * <span class="pl-k">@return</span></span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">@Bean</span>
<span class="pl-k">public</span> <span class="pl-smi">FastJsonConfig</span> fastjsonConfig(<span class="pl-k">@Qualifier</span>(<span class="pl-s"><span class="pl-pds">"</span>enumValues<span class="pl-pds">"</span></span>) <span class="pl-k">List&lt;<span class="pl-k">Class&lt;?&gt;</span>&gt;</span> enumValues) {
    <span class="pl-smi">FastJsonConfig</span> config <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">FastJsonConfig</span>();
    config<span class="pl-k">.</span>setSerializerFeatures(<span class="pl-smi">SerializerFeature</span><span class="pl-k">.</span><span class="pl-smi">WriteDateUseDateFormat</span>);

    <span class="pl-c"><span class="pl-c">//</span> TODO 这里只是为了测试, 最好都通过扫描来查找而不是硬编码</span>
    <span class="pl-c"><span class="pl-c">//</span> enumValues.add(Sex.class);</span>

    <span class="pl-k">if</span> (enumValues <span class="pl-k">!=</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span> enumValues<span class="pl-k">.</span>size() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-c"><span class="pl-c">//</span> 枚举类型字段：序列化反序列化配置</span>
        <span class="pl-smi">EnumConverter</span> enumConverter <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">EnumConverter</span>();
        <span class="pl-smi">ParserConfig</span> parserConfig <span class="pl-k">=</span> config<span class="pl-k">.</span>getParserConfig();
        <span class="pl-smi">SerializeConfig</span> serializeConfig <span class="pl-k">=</span> config<span class="pl-k">.</span>getSerializeConfig();
        <span class="pl-k">for</span> (<span class="pl-k">Class&lt;?&gt;</span> clazz <span class="pl-k">:</span> enumValues) {
            parserConfig<span class="pl-k">.</span>putDeserializer(clazz, enumConverter);
            serializeConfig<span class="pl-k">.</span>put(clazz, enumConverter);
        }
    }

    <span class="pl-k">return</span> config;
}</pre></div>
<p>这里有两种方式：</p>
<ol>
<li>硬编码给所有 <strong>枚举类型</strong> 注册 <strong>类型转换器</strong> 。</li>
<li>扫描所有 <strong>枚举类型</strong> 并批量注册。( <strong>推荐</strong> )</li>
</ol>
</li>
</ul>
<h3>DAO 层处理</h3>
<hr>
<p>由于使用 <strong>Mybatis</strong> 作为 <strong>ORM</strong> 框架，这里使用 <strong>Mybatis</strong> 提供的 <strong>TypeHandler</strong> 实现 <strong>枚举类型</strong> 的 <strong>序列化</strong> 和 <strong>反序列化</strong> 。</p>
<ul>
<li>
<p>实现一个自定义的通用的 <strong>TypeHandler</strong></p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnumTypeHandler</span>&lt;T <span class="pl-k">extends</span> <span class="pl-e">Enum&lt;<span class="pl-smi">T</span>&gt;</span> &amp; <span class="pl-e">EnumValue</span>&gt; extends <span class="pl-e">BaseTypeHandler&lt;<span class="pl-smi">T</span>&gt;</span> {

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> type;

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 只能由子类调用</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@SuppressWarnings</span>(<span class="pl-s"><span class="pl-pds">"</span>unchecked<span class="pl-pds">"</span></span>)
    <span class="pl-k">protected</span> <span class="pl-en">EnumTypeHandler</span>() {
        type <span class="pl-k">=</span> <span class="pl-smi">GenericsUtils</span><span class="pl-k">.</span>getSuperClassGenericClass(getClass());
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 由 Mybatis 根据类型动态生成实例</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> type</span>
<span class="pl-c">     * <span class="pl-k">@see</span> org.apache.ibatis.type.TypeHandlerRegistry#getInstance(Class, Class)</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">public</span> <span class="pl-en">EnumTypeHandler</span>(<span class="pl-k">Class&lt;<span class="pl-smi">T</span>&gt;</span> <span class="pl-v">rawClass</span>) {
        <span class="pl-c1">this</span><span class="pl-k">.</span>type <span class="pl-k">=</span> rawClass;
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setNonNullParameter</span>(<span class="pl-smi">PreparedStatement</span> <span class="pl-v">ps</span>, <span class="pl-k">int</span> <span class="pl-v">i</span>, <span class="pl-smi">T</span> <span class="pl-v">parameter</span>, <span class="pl-smi">JdbcType</span> <span class="pl-v">jdbcType</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-smi">Object</span> value <span class="pl-k">=</span> parameter<span class="pl-k">.</span>toValue();
        <span class="pl-k">if</span> (jdbcType <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
            ps<span class="pl-k">.</span>setObject(i, value);
        } <span class="pl-k">else</span> {
            ps<span class="pl-k">.</span>setObject(i, value, <span class="pl-smi">jdbcType<span class="pl-k">.</span>TYPE_CODE</span>);
        }
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">ResultSet</span> <span class="pl-v">rs</span>, <span class="pl-smi">String</span> <span class="pl-v">columnName</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> valueOf(rs<span class="pl-k">.</span>getString(columnName));
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">ResultSet</span> <span class="pl-v">rs</span>, <span class="pl-k">int</span> <span class="pl-v">columnIndex</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> valueOf(rs<span class="pl-k">.</span>getString(columnIndex));
    }

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">T</span> <span class="pl-en">getNullableResult</span>(<span class="pl-smi">CallableStatement</span> <span class="pl-v">cs</span>, <span class="pl-k">int</span> <span class="pl-v">columnIndex</span>) <span class="pl-k">throws</span> <span class="pl-smi">SQLException</span> {
        <span class="pl-k">return</span> valueOf(cs<span class="pl-k">.</span>getString(columnIndex));
    }

    <span class="pl-k">private</span> <span class="pl-smi">T</span> <span class="pl-en">valueOf</span>(<span class="pl-smi">String</span> <span class="pl-v">s</span>) {
        <span class="pl-k">return</span> s <span class="pl-k">==</span> <span class="pl-c1">null</span> <span class="pl-k">?</span> <span class="pl-c1">null</span> <span class="pl-k">:</span> <span class="pl-smi">EnumValue</span><span class="pl-k">.</span>valueOf(type, s);
    }
}</pre></div>
</li>
<li>
<p>注册 <strong>EnumTypeHandler</strong></p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@Configuration</span>
<span class="pl-k">@ConditionalOnClass</span>({<span class="pl-smi">SqlSessionFactory</span><span class="pl-k">.</span>class})
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MybatisTypeHandlerConfiguration</span> {

    <span class="pl-k">private</span> <span class="pl-smi">TypeHandlerRegistry</span> typeHandlerRegistry;

    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">SpringClassScanner</span> springClassScanner;

    <span class="pl-k">public</span> <span class="pl-en">MybatisTypeHandlerConfiguration</span>(<span class="pl-smi">SqlSessionFactory</span> <span class="pl-v">sqlSessionFactory</span>, <span class="pl-smi">SpringClassScanner</span> <span class="pl-v">springClassScanner</span>) {
        <span class="pl-c1">this</span><span class="pl-k">.</span>typeHandlerRegistry <span class="pl-k">=</span> sqlSessionFactory<span class="pl-k">.</span>getConfiguration()<span class="pl-k">.</span>getTypeHandlerRegistry();
        <span class="pl-c1">this</span><span class="pl-k">.</span>springClassScanner <span class="pl-k">=</span> springClassScanner;
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册 Mybatis 类型转换器</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@Autowired</span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">registerTypeHandlers</span>() {
        enumValues()<span class="pl-k">.</span>forEach(<span class="pl-c1">this</span><span class="pl-k">::</span>registerEnumTypeHandler);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册 枚举 类型的类型转换器</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> javaTypeClass Java 类型</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">registerEnumTypeHandler</span>(<span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">javaTypeClass</span>) {
        register(javaTypeClass, <span class="pl-smi">EnumTypeHandler</span><span class="pl-k">.</span>class);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 注册类型转换器</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@param</span> javaTypeClass    Java 类型</span>
<span class="pl-c">     * <span class="pl-k">@param</span> typeHandlerClass 类型转换器类型</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">register</span>(<span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">javaTypeClass</span>, <span class="pl-k">Class&lt;?&gt;</span> <span class="pl-v">typeHandlerClass</span>) {
        <span class="pl-c1">this</span><span class="pl-k">.</span>typeHandlerRegistry<span class="pl-k">.</span>register(javaTypeClass, typeHandlerClass);
    }

    <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">     * 扫描所有的 {<span class="pl-k">@link</span> EnumValue} 实现类</span>
<span class="pl-c">     * 注册到 Spring 中</span>
<span class="pl-c">     *</span>
<span class="pl-c">     * <span class="pl-k">@return</span> 类集合</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>
    <span class="pl-k">@Bean</span>
    <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-k">Class&lt;?&gt;</span>&gt;</span> <span class="pl-en">enumValues</span>() {
        <span class="pl-c"><span class="pl-c">//</span> 过滤自定义枚举类</span>
        <span class="pl-k">Predicate&lt;<span class="pl-k">Class&lt;?&gt;</span>&gt;</span> filter <span class="pl-k">=</span> clazz <span class="pl-k">-</span><span class="pl-k">&gt;</span> clazz<span class="pl-k">.</span>isEnum() <span class="pl-k">&amp;&amp;</span> <span class="pl-smi">EnumValue</span><span class="pl-k">.</span>class<span class="pl-k">.</span>isAssignableFrom(clazz);
        <span class="pl-k">return</span> springClassScanner<span class="pl-k">.</span>scanClass(<span class="pl-c1">ENTITY_PACKAGE</span>, filter);
    }

}</pre></div>
<p>上面是全自动的方式，也可以定义一个具体类型的 <strong>EnumTypeHandler</strong> :</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StatusTypeHandler</span> <span class="pl-k">extends</span> <span class="pl-e">EnumTypeHandler&lt;<span class="pl-smi">Status</span>&gt;</span> {
}</pre></div>
</li>
<li>
<p>然后修改 <strong>application.yml</strong> 让 <strong>Mybatis</strong> 去扫描注册自定义的 <strong>TypeHandler</strong></p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">mybatis</span>:
  <span class="pl-ent">type-handlers-package</span>: <span class="pl-s">com.github.anyesu.common.typehandler</span></pre></div>
</li>
</ul>
<h3>源码</h3>
<hr>
<p>篇幅有限，上面代码并不完整，点击 <a href="https://github.com/anyesu/spring-boot-demo/tree/master/spring-boot-demo-customized-field-type">这里</a> 查看完整代码。</p>
<h3>结语</h3>
<hr>
<p>通过这个小小的优化，对于代码的简洁性和健壮性带来的效果还是不错的。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/34212407037e">https://www.jianshu.com/p/34212407037e</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[IntelliJ IDEA 使用 Docker 远程部署]]></title>
            <link>https://anyesu.github.io/blog/articles/32</link>
            <guid>32</guid>
            <pubDate>Sat, 28 Sep 2019 16:51:55 GMT</pubDate>
            <description><![CDATA[前言 通常，部署流程主要为下面几个步骤： 提交代码 ( SVN 或者 Git ) 。 在 构建服务器 上拉取代码进行构建打包。 将软件包发送到 部署服务器，或者打包后上传到仓库，由 部署服务器 进行下载。 部署服务器 停止现有服务，使用新的软件包进行启动。 上面的步骤很是繁琐，而且全程需要人工盯着以进行后续步骤，如果需要经常部署的话无疑是很浪费时间的。有人会说可以用 Jenkins 这样的 CI ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>通常，部署流程主要为下面几个步骤：</p>
<ul>
<li>
<p>提交代码 ( <strong>SVN</strong> 或者 <strong>Git</strong> ) 。</p>
</li>
<li>
<p>在 <strong>构建服务器</strong> 上拉取代码进行构建打包。</p>
</li>
<li>
<p>将软件包发送到 <strong>部署服务器</strong>，或者打包后上传到仓库，由 <strong>部署服务器</strong> 进行下载。</p>
</li>
<li>
<p><strong>部署服务器</strong> 停止现有服务，使用新的软件包进行启动。</p>
</li>
</ul>
<p>上面的步骤很是繁琐，而且全程需要人工盯着以进行后续步骤，如果需要经常部署的话无疑是很浪费时间的。有人会说可以用 <strong>Jenkins</strong> 这样的 <strong>CI</strong> 工具啊，这也是一种方法，但不是本文的目标。</p>
<h3>项目 Docker 化改造</h3>
<hr>
<p>既然要用 <a href="https://www.docker.com/" rel="nofollow">Docker</a> 进行部署，那就要对现有项目做一些简单的改造，如果项目结构之前已经比较规范了，那么改造起来也会比较简单。</p>
<p>先在项目 <strong>根目录</strong> ( 也可以放在一个 docker 文件夹下统一维护 ) 下添加几个文件：</p>
<table role="table">
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dockerfile</strong></td>
<td>镜像配置文件，用于配置程序运行时依赖的环境，比如 <strong>Java</strong> 、 <strong>Tomcat</strong></td>
</tr>
<tr>
<td><strong>.dockerignore</strong></td>
<td>使用 <strong>Docker</strong> 构建镜像的时候会将 <strong>上下文目录</strong> 中的文件复制到 <strong>Docker Engine</strong> 中，如果每次都要复制一遍 <strong>源码</strong> 和 <strong>构建中间产物</strong> 就会很浪费时间，<strong>.dockerignore</strong> 的作用就是用于忽略指定的文件，加快镜像构建速度。</td>
</tr>
<tr>
<td><strong>docker-compose.yml</strong></td>
<td>用于多个服务的编排。项目如果依赖了 <strong>数据库</strong> 、<strong>缓存</strong> 、<strong>消息队列</strong> 等，可以在这里配置依赖关系，还可以进行动态 <strong>扩缩容</strong> 。</td>
</tr>
<tr>
<td><strong>.env</strong></td>
<td><strong>docker-compose.yml</strong> 中可以使用 <strong>环境变量</strong> 进行参数化配置，一些默认的 <strong>环境变量</strong> 可以保存在这个文件中，实际构建时可以配置 <strong>环境变量</strong> 对其进行覆盖。</td>
</tr>
</tbody>
</table>
<p>之后将项目中一些 <strong>写死</strong> 的 <strong>配置</strong> 改为通过 <strong>环境变量</strong> 读取，这样就可以通过 <strong>docker-compose.yml</strong> 导入 <strong>环境变量</strong> ，在不同环境下 ( <strong>开发</strong> 、 <strong>测试</strong> 、 <strong>线上</strong> 等 ) 不用改文件就可以部署了。具体配置参考下面的测试项目。</p>
<h3>准备工作</h3>
<hr>
<ul>
<li>
<p>安装 <a href="https://www.jetbrains.com/idea/" rel="nofollow">IntelliJ IDEA</a> ( 目前最新版本是 <code>2019.1</code> ) 。</p>
</li>
<li>
<p>安装 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" rel="nofollow">Docker Desktop for Windows</a> 。</p>
<blockquote>
<p>不推荐安装 <strong>Docker Desktop for Windows</strong> ，本文只是用于测试。<br>
最好在其他的 <strong>Linux</strong> 主机上运行 <strong>Docker</strong> 。</p>
</blockquote>
</li>
<li>
<p>下载最新版的 <a href="https://github.com/docker/compose/releases/latest">Docker Compose</a> - <strong>docker-compose-Windows-x86_64.exe</strong> 。</p>
<blockquote>
<p><strong>Docker Desktop for Windows</strong> 已经集成了 <strong>Docker Compose</strong> ，一般不需要单独下载。</p>
</blockquote>
</li>
<li>
<p>下载 <a href="https://github.com/anyesu/test">测试项目</a> 。</p>
</li>
<li>
<p>先阅读完本文。</p>
</li>
</ul>
<h3>使用方法</h3>
<hr>
<ul>
<li>
<p>打开测试项目 <strong>JetBrains-Docker-Example/Springboot-Example</strong> 。</p>
</li>
<li>
<p>设置 <strong>Project JDK</strong> 。</p>
</li>
<li>
<p>导入 <strong>pom.xml</strong> ( 右键 <strong>Add as Maven Project</strong> 或者直接拖拽到 <strong>Maven 工具栏</strong> 中 ) 。</p>
</li>
<li>
<p>添加 <strong>Docker Daemon</strong> 。</p>
<p>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Docker -&gt; Add -&gt; 输入 <strong>Docker Daemon</strong> 的 URL</p>
<p><strong>Docker Daemon</strong> 的配置参考 <a href="https://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">这里</a> 。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/9809b89e445489c314da2bb36c08c5024fa35373/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353963363763623736623566643537342e706e67"><img src="https://camo.githubusercontent.com/9809b89e445489c314da2bb36c08c5024fa35373/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353963363763623736623566643537342e706e67" alt="添加 Docker Daemon" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-59c67cb76b5fd574.png" style="max-width:100%;"></a></p>
<blockquote>
<p>注意：如果要启用 TLS 安全连接，协议名需要填写 <strong>https</strong> 而不是命令行中使用的 <strong>tcp</strong> 。</p>
</blockquote>
</li>
<li>
<p>Add Run Configuration -&gt; New -&gt; Docker -&gt; Docker-compose</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/6b6e9728a4db2e3f0311769276513f063a044431/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613430643365376165316139336331332e706e67"><img src="https://camo.githubusercontent.com/6b6e9728a4db2e3f0311769276513f063a044431/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613430643365376165316139336331332e706e67" alt="添加 Run Configuration" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a40d3e7ae1a93c13.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>修改配置。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/627252be88e89810d28169ecb1abc64caac1f2c0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d376337316633626235346235393963342e706e67"><img src="https://camo.githubusercontent.com/627252be88e89810d28169ecb1abc64caac1f2c0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d376337316633626235346235393963342e706e67" alt="配置 Run Configuration" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-7c71f3bb54b599c4.png" style="max-width:100%;"></a></p>
<p>当然，也可以直接打开 <strong>docker-compose.yml</strong> ，点击左侧显示的 <strong>三角形按钮</strong> 自动生成运行配置。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/44edb364de5e318778bda8ab25e141f970932cd9/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653461366434343839356339343038652e706e67"><img src="https://camo.githubusercontent.com/44edb364de5e318778bda8ab25e141f970932cd9/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653461366434343839356339343038652e706e67" alt="通过 docker-compose.yml 运行" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-e4a6d44895c9408e.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>运行配置，可以看到容器已经启动了，访问看下效果：<strong>127.0.0.1:3000</strong> 。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/31ffd1b1cd01321133c022e470be367ff3180130/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d323131656332343463616363373733392e706e67"><img src="https://camo.githubusercontent.com/31ffd1b1cd01321133c022e470be367ff3180130/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d323131656332343463616363373733392e706e67" alt="docker 部署" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-211ec244cacc7739.png" style="max-width:100%;"></a></p>
<p>通过 <strong>Docker 插件</strong> 还可以可视化查看 <strong>容器</strong> 的 <strong>日志</strong> 、 <strong>环境变量</strong> 、 <strong>端口映射</strong> 、 <strong>数据卷</strong> 等配置信息，并且可以动态 <strong>修改配置</strong> 和 <strong>进入容器</strong> ，比起 <strong>敲命令</strong> 方便的不要太多。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/a60a8f37f0c5b8b01332ba0a9a5da4caa0842d10/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303830373934646437386562316563322e706e67"><img src="https://camo.githubusercontent.com/a60a8f37f0c5b8b01332ba0a9a5da4caa0842d10/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303830373934646437386562316563322e706e67" alt="docker 插件" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-080794dd78eb1ec2.png" style="max-width:100%;"></a></p>
</li>
</ul>
<p>上面的步骤就是 <strong>Docker 插件</strong> 的常规用法，已经实现了 <strong>一键部署</strong> 效果，只是需要自己配置 <strong>Run Configuration</strong> 。</p>
<p><strong>下面看下另一种使用方式：</strong></p>
<ul>
<li>
<p>打开另一个测试项目 <strong>JetBrains-Docker-Example/Node-Example</strong> 。</p>
</li>
<li>
<p>先使用命令 <code>npm install</code> 安装依赖。</p>
<p>最好先在命令行执行再打开 <strong>IDEA</strong> ，不然可能把 <strong>IDEA</strong> 卡死。</p>
</li>
<li>
<p>打开 <strong>package.json</strong> ，部署命令已经在 <strong>Docker</strong> 写好了，点击命令左侧显示的 <strong>三角形按钮</strong> 直接执行就行了。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d2a38f41a9d52457f3164f16e024f1cad6620bc6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333234633066353464306435386663612e706e67"><img src="https://camo.githubusercontent.com/d2a38f41a9d52457f3164f16e024f1cad6620bc6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333234633066353464306435386663612e706e67" alt="通过 package.json 运行" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-324c0f54d0d58fca.png" style="max-width:100%;"></a></p>
<p>如果需要部署到其他 <strong>远程 Docker Daemon</strong> ，可以修改 <strong>环境变量</strong> <code>DOCKER_HOST</code> 。</p>
</li>
<li>
<p>访问看下效果：<strong>127.0.0.1:8000</strong> 。</p>
</li>
</ul>
<p>这种方式也是 <strong>一键式</strong> 的，也比较适合在命令行中执行。</p>
<h3>Docker Desktop for Windows 的坑</h3>
<hr>
<ul>
<li>
<p>依赖于 <strong>Hyper-V</strong> 虚拟机，但是 <strong>Hyper-V</strong> 的兼容性不太好，容易出一些莫名其妙的问题，所以 <strong>不推荐安装</strong> 。</p>
</li>
<li>
<p>使用它 ( <code>2.0.0.3 (31259)</code> ) 自带的 <strong>docker-compose</strong> ( <a href="https://github.com/docker/compose/releases/tag/1.23.2">1.23.2</a> ) 在执行某些镜像构建操作的时候可能会出现下面的错误：</p>
<pre><code>Building api
[18576] Failed to execute script docker-compose
Traceback (most recent call last):
  File "docker-compose", line 6, in &lt;module&gt;
  File "compose\cli\main.py", line 71, in main
  File "compose\cli\main.py", line 127, in perform_command
  File "compose\cli\main.py", line 1080, in up
  File "compose\cli\main.py", line 1076, in up
  File "compose\project.py", line 475, in up
  File "compose\service.py", line 342, in ensure_image_exists
  File "compose\service.py", line 1082, in build
  File "site-packages\docker\api\build.py", line 150, in build
UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 10: illegal multibyte sequence
</code></pre>
<p>查看 <a href="https://github.com/docker/docker-py/blob/3.6.0/docker/api/build.py#L150">源码</a> 发现是因为 <strong>.dockerignore</strong> 文件中包含了中文导致乱码， <a href="https://github.com/docker/compose/releases/tag/1.19.0"><code>1.19.0</code></a> 及之前的版本没有这个问题。( 同样的版本，<strong>Linux</strong> 下没有这个问题 )</p>
</li>
<li>
<p>在 <strong>Windows</strong> 下使用旧版 <strong>docker-compose</strong> ( 比如 <code>1.19.0</code> ) 部署到 <strong>远程 Linux Docker Daemon</strong> 时，如果使用了 <strong>数据卷</strong> 会出现下面的错误：</p>
<pre><code>Creating api ... 
Creating api ... error
ERROR: for api  Cannot create container for service api: create \etc\localtime: "\\etc\\localtime" includes invalid characters for a local volume name, only "[a-zA-Z0-9][a-zA-Z0-9_.-]" are allowed. If you intended to pass a host directory, use absolute path

ERROR: for api  Cannot create container for service api: create \etc\localtime: "\\etc\\localtime" includes invalid characters for a local volume name, only "[a-zA-Z0-9][a-zA-Z0-9_.-]" are allowed. If you intended to pass a host directory, use absolute path
Encountered errors while bringing up the project.
</code></pre>
<p>使用 <code>docker-compose config</code> 命令可以看到 <strong>数据卷</strong> 源路径被改成了 <strong>Windows</strong> 下的 <strong>反斜杠</strong> 类型的路径格式 <code>\etc\localtime</code>。</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">services</span>:
  <span class="pl-ent">api</span>:
    <span class="pl-ent">build</span>:
      <span class="pl-ent">context</span>: <span class="pl-s">D:\github\test\JetBrains-Docker-Example\Springboot-Example</span>
    <span class="pl-ent">command</span>: <span class="pl-s">java -jar -Djava.security.egd=file:/dev/./urandom -server -XX:+DisableExplicitGC</span>
      <span class="pl-s">-Xms256m -Xmx256m -Dspring.profiles.active=docker /app.jar</span>
    <span class="pl-ent">container_name</span>: <span class="pl-s">api</span>
    <span class="pl-ent">hostname</span>: <span class="pl-s">api</span>
    <span class="pl-ent">ports</span>:
    - <span class="pl-s">3000:8080/tcp</span>
    <span class="pl-ent">privileged</span>: <span class="pl-c1">false</span>
    <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
    <span class="pl-ent">volumes</span>:
    - <span class="pl-s">\etc\localtime:/etc/localtime:rw</span>
<span class="pl-ent">version</span>: <span class="pl-s"><span class="pl-pds">'</span>3.0<span class="pl-pds">'</span></span></pre></div>
<p>通过阅读 <a href="https://github.com/docker/compose/blob/1.19.0/compose/config/config.py#L818">源码</a> 找到了方法：使用 <strong>docker-compose</strong> 的 <a href="https://docs.docker.com/compose/reference/envvars/" rel="nofollow">内置环境变量</a> - <code>COMPOSE_CONVERT_WINDOWS_PATHS=1</code></p>
</li>
</ul>
<h3>其他方案</h3>
<hr>
<p>上面提到了 <strong>Docker Desktop for Windows</strong> 的一些问题，所以我不推荐去安装它，单独下载 <strong>docker-compose</strong> 就好了。考虑到 <strong>Windows</strong> 到 <strong>Linux</strong> 之间交互可能会存在的问题，我还有一种方案：</p>
<ul>
<li>
<p>安装 <a href="https://www.jianshu.com/p/bc38ed12da1d" rel="nofollow">WSL</a> 。</p>
</li>
<li>
<p>在 <strong>WSL</strong> 中安装 <strong>Docker</strong>，但是只具备 <strong>客户端</strong> 功能而无法运行 <strong>Docker Daemon</strong> 。</p>
<p><strong>2019-07-12 追加：</strong> 目前 <strong>WSL</strong> 已经能够运行 <strong>Docker Daemon</strong> 了，参考我另一篇 <a href="https://www.jianshu.com/p/20ebdbf68744" rel="nofollow">文章</a> 。</p>
</li>
<li>
<p>在 <strong>WSL</strong> 中安装 <strong>docker-compose</strong> 。</p>
</li>
<li>
<p>在 <strong>Windows</strong> 下编写脚本 <code>docker-compose.bat</code> 。</p>
<div class="highlight highlight-source-powershell"><pre><span class="pl-smi">@echo</span> off

echo current dir: <span class="pl-k">%</span>cd<span class="pl-k">%</span>

:: 使用延迟变量
setlocal enabledelayedexpansion

:: 遍历所有参数，如果是 compose 文件则转换路径格式
:: 使用 wslpath 将 Windows 路径转为 wsl 中的路径
<span class="pl-k">for</span> <span class="pl-k">%</span><span class="pl-k">%</span>i <span class="pl-k">in</span> ( <span class="pl-k">%</span><span class="pl-k">*</span> ) <span class="pl-k">do</span> (
    :: 当前参数
    set arg<span class="pl-k">=</span><span class="pl-k">%</span><span class="pl-k">%</span>i
    :: 使用下面这种方式中文路径不会乱码
    <span class="pl-k">if</span> <span class="pl-k">!</span>last_arg<span class="pl-k">!</span><span class="pl-k">==</span><span class="pl-k">-f</span> <span class="pl-k">if</span> <span class="pl-k">!</span>arg<span class="pl-k">!</span> neq <span class="pl-k">-f</span>  set <span class="pl-s"><span class="pl-pds">"</span>arg=`wslpath '!arg!'<span class="pl-cce">`"</span></span>
<span class="pl-s">    :: 追加到新的参数列表中</span>
<span class="pl-s">    set <span class="pl-pds">"</span></span>args<span class="pl-k">=</span><span class="pl-k">!</span>args<span class="pl-k">!</span> <span class="pl-k">!</span>arg<span class="pl-k">!</span><span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">    :: 作为上一个参数保存</span>
<span class="pl-s">    set last_arg=%%i</span>
<span class="pl-s">)</span>
<span class="pl-s"></span>
<span class="pl-s">:: IDEA 部署到指定 Docker Daemon 的时候会设置下面的环境变量</span>
<span class="pl-s"></span>
<span class="pl-s">:: 设置环境变量 DOCKER_HOST 来指定 Docker Daemon 的 URL</span>
<span class="pl-s">if defined DOCKER_HOST set <span class="pl-pds">"</span></span>envs<span class="pl-k">=</span>export DOCKER_HOST<span class="pl-k">=%</span>DOCKER_HOST<span class="pl-k">%</span>;<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s"></span>
<span class="pl-s">:: 设置环境变量 DOCKER_TLS_VERIFY 和 DOCKER_CERT_PATH 指定 TLS 配置</span>
<span class="pl-s">:: DOCKER_CERT_PATH 为空时，wslpath 命令的结果是 '.'，要做处理</span>
<span class="pl-s">if defined DOCKER_CERT_PATH set <span class="pl-pds">"</span></span>envs<span class="pl-k">=%</span>envs<span class="pl-k">%</span>export DOCKER_CERT_PATH<span class="pl-k">=</span><span class="pl-k">`</span>wslpath <span class="pl-s"><span class="pl-pds">'</span>%DOCKER_CERT_PATH%<span class="pl-pds">'</span></span><span class="pl-k">`</span>;<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">set <span class="pl-pds">"</span></span>envs<span class="pl-k">=%</span>envs<span class="pl-k">%</span>export DOCKER_TLS_VERIFY<span class="pl-k">=%</span>DOCKER_TLS_VERIFY<span class="pl-k">%</span>;<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s"></span>
<span class="pl-s">:: 通过 WSL 调用 docker-compose</span>
<span class="pl-s">:: 如果 bash -c 命令参数中包含<span class="pl-smi">$则要转义</span>，否则在解析 bash -c 命令的时候就会对 shell 变量进行替换</span>
<span class="pl-s">:: 注意：.env 文件需要在当前命令的执行目录下</span>
<span class="pl-s">bash -c <span class="pl-pds">"</span></span><span class="pl-k">%</span>envs<span class="pl-k">%</span>env<span class="pl-k">|</span>grep DOCKER;set <span class="pl-k">-</span>x;docker<span class="pl-k">-</span>compose <span class="pl-k">%</span>args<span class="pl-k">%</span>;<span class="pl-s"><span class="pl-pds">"</span></span></pre></div>
<p><strong>IDEA</strong> 通过设置 <strong>环境变量</strong> : <strong>DOCKER_HOST</strong> 、<strong>DOCKER_TLS_VERIFY</strong> 、<strong>DOCKER_CERT_PATH</strong> 起到连接 <strong>远程 Docker Daemon</strong> 的目的。</p>
</li>
<li>
<p>修改 <strong>Docker Compose</strong> 的 <strong>可执行程序</strong> 为上面的脚本。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/ff65aae5490128a608f09f28928ff6d44e947ce3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d386465376239663632323961633663372e706e67"><img src="https://camo.githubusercontent.com/ff65aae5490128a608f09f28928ff6d44e947ce3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d386465376239663632323961633663372e706e67" alt="修改 docker 可执行程序" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-8de7b9f6229ac6c7.png" style="max-width:100%;"></a></p>
</li>
</ul>
<h3>结语</h3>
<hr>
<p>上面其实只是介绍一个很简单但又实用的功能，更多的是分享我在使用过程中遇到的一些问题，尤其是在写这篇文章的时候才发现自己之前有些认知是错误的，也是一种收获。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/410ea6e0b13a">https://www.jianshu.com/p/410ea6e0b13a</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-59c67cb76b5fd574.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Chrome 插件整理]]></title>
            <link>https://anyesu.github.io/blog/articles/31</link>
            <guid>31</guid>
            <pubDate>Thu, 26 Sep 2019 13:34:11 GMT</pubDate>
            <description><![CDATA[前言 记录一下自己使用的 Chrome 插件 。 注：下面的插件链接需要 科学上网 ，可以自行搜索插件名安装。 工具类 OneTab 可以理解是一个 临时的收藏夹 ，一键保存 当前窗口的标签页，用法很简单，自行体会。 找资料的过程中经常会遇到一些副产物 ( 有用的但是与当前目的相关性不大的资料 )，由于搜索引擎的尿性 ( 同样的关键字之后再也搜不出之前的结果 ) 就会把页面一直开着 ( 目前并没有]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>记录一下自己使用的 <a href="https://chrome.google.com/webstore/category/extensions" rel="nofollow">Chrome 插件</a> 。</p>
<p>注：下面的插件链接需要 <strong>科学上网</strong> ，可以自行搜索插件名安装。</p>
<h3>工具类</h3>
<hr>
<ul>
<li>
<p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" rel="nofollow">OneTab</a></p>
<p>可以理解是一个 <strong>临时的收藏夹</strong> ，<strong>一键保存</strong> 当前窗口的标签页，用法很简单，自行体会。</p>
<p>找资料的过程中经常会遇到一些副产物 ( 有用的但是与当前目的相关性不大的资料 )，由于搜索引擎的尿性 ( 同样的关键字之后再也搜不出之前的结果 ) 就会把页面一直开着 ( 目前并没有时间去细看，也不会去收藏 ) ，久而久之开着上百个标签页就是很常见的事，这是很费内存的 ( <strong>几个 G</strong> ) ，有了这个插件就可以节省很多内存，同时浏览器也清净了不少。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" rel="nofollow">Tampermonkey</a></p>
<p>油猴脚本。只要会前端就可以自行编写用户脚本对浏览的网页做修改 ( 美化、去广告等等 ) ，每个脚本都可以当作是轻量级的 <strong>插件</strong> 。下文会推荐一些我觉得实用的脚本。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" rel="nofollow">Vimium</a></p>
<p>使用快捷键控制浏览器。由于我习惯使用触摸板，只用到 <strong>快速关闭/还原标签页</strong> 的功能，其他功能没有深入使用过。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8chrome%E5%88%92%E8%AF%8D%E6%8F%92%E4%BB%B6/eopjamdnofihpioajgfdikhhbobonhbb" rel="nofollow">有道词典 Chrome 划词插件</a></p>
<p>用过最好用的一款 <strong>划词翻译</strong> 插件。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj" rel="nofollow">Awesome Screenshot: Screen Video Recorder</a></p>
<p>网页截图: 注释&amp;录屏 ( 不仅是浏览器截图 ) 。</p>
<p>顺带分享下 <strong>Chrome</strong> 原生支持的 <a href="https://sspai.com/post/42193" rel="nofollow">截图方法</a> 。</p>
</li>
</ul>
<h3>开发类</h3>
<hr>
<ul>
<li>
<p><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" rel="nofollow">React Developer Tools</a></p>
<p><strong>React</strong> 项目开发工具，可以看原始的 <strong>React Element 树</strong> ，类似于 <strong>DOM 树</strong>。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" rel="nofollow">Redux DevTools</a></p>
<p>如果在项目中使用 <a href="http://cn.redux.js.org/index.html" rel="nofollow">Redux</a> ，那么这个插件就很有用了，可以查看已执行的 <strong>action</strong> 和 <strong>state</strong> 值，这样就可以快速定位故障点而不用到处打印 <strong>log</strong> 了。具体用法见 <a href="https://github.com/zalmoxisus/redux-devtools-extension">插件官方文档</a> 。</p>
</li>
</ul>
<h3>阅读类</h3>
<hr>
<ul>
<li>
<p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" rel="nofollow">Octotree</a></p>
<p>为 <strong>GitHub 仓库</strong> 生成目录，可以快速定位文件而不用一级一级菜单盲点了。</p>
<p>类似的插件有 <a href="https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack" rel="nofollow">Sourcegraph</a> 。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll" rel="nofollow">简悦 - SimpRead</a></p>
<p>对浏览的网页提供阅读模式，可以更专注于内容的阅读。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/smart-toc/lifgeihcfpkmmlfjbailfpfhbahhibba" rel="nofollow">Smart TOC</a></p>
<p>为网页生成目录菜单，适合长页面的跳转。</p>
</li>
</ul>
<h3>广告类</h3>
<hr>
<p>使用过几款所谓的去广告插件，但是都没什么用，所以还是跑题推荐下 <a href="http://www.ad-safe.com" rel="nofollow">ADSafe</a> ，官网下载的版本 ( <code>5.3.629.6500</code> ) 是没有用的。可以下载 <a href="http://pan.baidu.com/s/1pK7yvEj" rel="nofollow">历史版本</a> ，亲测 <code>5.3.209.1800</code> 还是可以用的。</p>
<h3>油猴脚本</h3>
<hr>
<p>可以在这个 <a href="https://greasyfork.org" rel="nofollow">网站</a> 搜索自己需要的脚本。</p>
<p>下面是我用过的脚本：</p>
<ul>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/370811-%E5%B7%B2%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%80%E5%B9%B4-%E6%94%BE%E5%BF%83%E4%BD%BF%E7%94%A8-%E7%BD%91%E7%9B%98%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99-%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E8%87%AA%E5%8A%A8%E6%9F%A5%E8%AF%A2%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%88%86%E4%BA%AB%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8F%90%E5%8F%96%E7%A0%81-%E5%85%A8%E7%BD%91vip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%92%AD%E6%94%BE-%E5%85%A8%E7%BD%91%E4%BB%98%E8%B4%B9%E9%9F%B3%E4%B9%90%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD-%E6%B7%98%E5%AE%9D-%E6%8B%BC%E5%A4%9A%E5%A4%9A%E5%A4%A7%E9%A2%9D%E8%B4%AD%E7%89%A9%E4%BC%98%E6%83%A0%E5%88%B8%E9%A2%86%E5%8F%96-%E6%94%AF%E6%8C%81%E5%8E%86%E5%8F%B2%E4%BB%B7%E6%A0%BC%E6%9F%A5%E8%AF%A2" rel="nofollow">百度网盘万能钥匙</a></p>
</li>
<li>
<p><a href="https://www.baiduyun.wiki/install.html" rel="nofollow">百度网盘直链下载助手</a></p>
<p><del>需要登录百度账号</del></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/375311-%E7%AE%80%E4%B9%A6%E5%8E%BB%E5%B9%BF%E5%91%8A-%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%B0%BE%E9%83%A8%E4%BC%98%E5%8C%96-%E5%8E%BB%E9%99%A4%E6%97%A0%E6%84%8F%E4%B9%89%E6%8E%A8%E8%8D%90" rel="nofollow">简书去广告，剪贴板尾部优化、去除无意义推荐</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/367724-%E7%9F%A5%E4%B9%8E-%E7%AE%80%E4%B9%A6-csdn-%E5%AE%9E%E9%AA%8C%E6%A5%BC%E5%89%AA%E5%88%87%E6%9D%BF%E6%B6%88%E6%AF%92" rel="nofollow">知乎、简书、csdn、实验楼剪切板消毒</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/372452-csdn%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80-%E5%8E%BB%E5%B9%BF%E5%91%8A-%E5%87%80%E5%8C%96%E5%89%AA%E8%B4%B4%E6%9D%BF-%E5%85%8D%E7%99%BB%E9%99%86" rel="nofollow">CSDN 自动展开+去广告+净化剪贴板+免登陆</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/34479-%E7%9B%AE%E5%BD%95%E6%A0%91%E5%AF%BC%E8%88%AA" rel="nofollow">目录树导航</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/377099-%E7%AE%80%E4%B9%A6%E5%A4%96%E9%93%BE%E5%8E%BB%E9%99%A4%E9%87%8D%E5%AE%9A%E5%90%91" rel="nofollow">简书外链去除重定向</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/371815-%E7%AE%80%E4%B9%A6%E5%AF%BC%E5%87%BA%E6%96%87%E7%AB%A0" rel="nofollow">简书导出文章</a></p>
</li>
<li>
<p><a href="https://greasyfork.org/zh-CN/scripts/34952-%E5%85%A8%E7%BD%91vip%E4%BC%9A%E5%91%98%E8%A7%86%E9%A2%91%E5%85%8D%E8%B4%B9%E7%9C%8B-2019%E5%B9%B45%E6%9C%8824%E6%97%A5%E6%9B%B4%E6%96%B0-%E6%94%AF%E6%8C%81%E7%88%B1%E5%A5%87%E8%89%BA%E6%AD%A3%E7%A1%AE%E9%80%89%E9%9B%86" rel="nofollow">全网VIP会员视频免费看</a></p>
</li>
</ul>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/6fd2c88560a8">https://www.jianshu.com/p/6fd2c88560a8</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub 拉取指定子目录]]></title>
            <link>https://anyesu.github.io/blog/articles/30</link>
            <guid>30</guid>
            <pubDate>Thu, 26 Sep 2019 13:10:11 GMT</pubDate>
            <description><![CDATA[前言 无意间发现 GitHub 竟然支持 SVN 的方式拉取代码，于是有了使用 SVN 客户端 拉取 项目子目录 代码的想法，本文做个记录。 关于拉取子目录的意图 一个项目大了之后通常会划分多个 子模块，还会加入一些 sample 项目 和 测试用例 等等，有些甚至会包含多种语言的代码，总而言之就是有很多互不相关的东西。对于使用者来说，有时候可能只用到其中一部分而其他都是无关的，拉取全部代码不仅会]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>无意间发现 <a href="https://github.com">GitHub</a> 竟然支持 <strong>SVN</strong> 的方式拉取代码，于是有了使用 <strong>SVN 客户端</strong> 拉取 <strong>项目子目录</strong> 代码的想法，本文做个记录。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/b1e8361cf7757a63918723faf0e4c308ba12c4eb/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d366238343230633731396539303464362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/b1e8361cf7757a63918723faf0e4c308ba12c4eb/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d366238343230633731396539303464362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="github svn support" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-6b8420c719e904d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>关于拉取子目录的意图</h3>
<hr>
<p>一个项目大了之后通常会划分多个 <strong>子模块</strong>，还会加入一些 <strong>sample 项目</strong> 和 <strong>测试用例</strong> 等等，有些甚至会包含多种语言的代码，总而言之就是有很多互不相关的东西。对于使用者来说，有时候可能只用到其中一部分而其他都是无关的，拉取全部代码不仅会对阅读造成干扰，还会有时间和空间上的浪费。</p>
<h3>正文</h3>
<hr>
<p>用法参考 <a href="https://help.github.com/en/articles/support-for-subversion-clients">官方文档</a> ( 可切换为 <strong>简体中文</strong> ) 。<strong>SVN</strong> 方式的仓库地址和 <strong>浏览器地址栏</strong> 中看到的项目 <strong>URL</strong> 是一致的。</p>
<p>先 <strong>checkout</strong> 一个完整的项目：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> svn co 是 svn checkout 的缩写</span>
svn co https://github.com/anyesu/websocket</pre></div>
<p>看下目录结构</p>
<pre><code>websocket
├── branches
│   └── dev
├── tags
│   └── 0.0.1
└── trunk
    ├── LICENSE
    ├── README.md
    ├── pom.xml
    ├── websocket-chat
    ├── websocket-core
    ├── websocket-parent
    └── websocket-samples
</code></pre>
<ul>
<li>
<p><strong>trunk</strong> 代表主分支</p>
</li>
<li>
<p><strong>branches</strong> 下是其余的分支</p>
</li>
<li>
<p><strong>tags</strong> 下是所有的标签</p>
</li>
</ul>
<p>整个目录结构还是很清晰的，所以想拉取指定子目录的代码只要仓库路径跟上对应的子路径就好了。</p>
<p>比如要拉取 <a href="https://github.com/anyesu/websocket/tree/master/websocket-samples/Tomcat-Websocket">Tomcat-Websocket</a> 这个子项目：</p>
<div class="highlight highlight-source-shell"><pre>svn co https://github.com/anyesu/websocket/trunk/websocket-samples/Tomcat-Websocket</pre></div>
<p>查看提交记录可以看到只剩下当前目录相关的修改了，很干净。</p>
<p>又比如要拉取 <code>0.0.1</code> 这个版本的代码：</p>
<div class="highlight highlight-source-shell"><pre>svn co https://github.com/anyesu/websocket/tags/0.0.1 websocket-0.0.1</pre></div>
<p><strong>tag</strong> 和 <strong>branch</strong> 不一样，只有一条提交记录。</p>
<h3>其他用法</h3>
<hr>
<p>功能当然不仅仅是上面说的 <strong>checkout</strong>，而是支持 <strong>SVN</strong> 的大部分用法 ( <strong>好吧，我也不保证，自己试试吧</strong> ) ，其中就包括通过 <strong>版本库浏览器</strong> ，可以在线查看项目而不用拉代码到本地。</p>
<p><strong>IDEA</strong> 中 <strong>版本库浏览器</strong> 使用方法：</p>
<p><strong>菜单栏 VCS -&gt; Browse VCS Repository -&gt; Browse Subversion Repository -&gt; Add</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/75a5b6aca79c1237c4930d0171cd93781945eae4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623733366137626632633564383935612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/75a5b6aca79c1237c4930d0171cd93781945eae4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623733366137626632633564383935612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="svn browser" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-b736a7bf2c5d895a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/685d1d0a35c7b24eb4352822e4165413dfd7a804/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656632343135346135306663363263342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/685d1d0a35c7b24eb4352822e4165413dfd7a804/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656632343135346135306663363263342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="svn browser" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-ef24154a50fc62c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/e6628700826493c1b6bd650cd2eb7145cb6ccc8c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663363646536363334366330323863362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/e6628700826493c1b6bd650cd2eb7145cb6ccc8c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663363646536363334366330323863362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="svn browser" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-f3cde66346c028c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>结语</h3>
<hr>
<p>上述方法 <strong>仅</strong> 适用于 <strong>GitHub</strong> ，目前还未发现其他 <strong>Git 托管平台</strong> 支持这种操作，可以参照 <a href="https://blog.csdn.net/xuyaqun/article/details/49275477" rel="nofollow">这里</a> 的方法解决。我猜，<strong>GitHub</strong> 上应该是实现 <strong>SVN 到 Git</strong> 的协议转换或者简单粗暴的建立了一个 <strong>SVN</strong> 的镜像仓库。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/20205df72001">https://www.jianshu.com/p/20205df72001</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-6b8420c719e904d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Lumia 950 XL 刷入 Windows 10 ARM 体验]]></title>
            <link>https://anyesu.github.io/blog/articles/29</link>
            <guid>29</guid>
            <pubDate>Thu, 26 Sep 2019 12:57:35 GMT</pubDate>
            <description><![CDATA[前言 几个月来，关于 Windows 10 ARM 的消息一直在持续更新，还是没忍住决定尝试一波。虽然手上已经有一台 Lumia 950 了，还是淘了一台新的 Lumia 950 XL 用来做实验，在这里分享一些我的经验。 微软 Lumia 950 XL 老树新花，Windows 10 ARM 暗埋火种 IT 之家学院：微软 Lumia 950 XL 刷 Windows 10 ARM64 教程增补]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>几个月来，关于 <strong>Windows 10 ARM</strong> 的消息一直在持续更新，还是没忍住决定尝试一波。虽然手上已经有一台 <strong>Lumia 950</strong> 了，还是淘了一台新的 <strong>Lumia 950 XL</strong> 用来做实验，在这里分享一些我的经验。</p>
<ul>
<li>
<p><a href="https://www.ithome.com/0/407/645.htm" rel="nofollow">微软 Lumia 950 XL 老树新花，Windows 10 ARM 暗埋火种</a></p>
</li>
<li>
<p><a href="https://www.ithome.com/0/407/902.htm" rel="nofollow">IT 之家学院：微软 Lumia 950 XL 刷 Windows 10 ARM64 教程增补进阶版</a></p>
</li>
<li>
<p><a href="https://www.ithome.com/0/421/272.htm" rel="nofollow">神速度！刷了 Windows 10 ARM 的微软 Lumia 950 XL 正式支持 LTE 网络</a></p>
</li>
</ul>
<h3>环境</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>设备</th>
<th>系统</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PC</strong></td>
<td><strong>Windows 10 专业版 1809</strong></td>
</tr>
<tr>
<td><strong>Lumia 950 XL</strong></td>
<td><strong>Windows 10 Mobile 10586.13169</strong></td>
</tr>
</tbody>
</table>
<h3>注意事项</h3>
<hr>
<ul>
<li>
<p><strong>下面的操作可能会导致不可挽回的数据丢失甚至手机不可用，请做好数据备份。</strong></p>
</li>
<li>
<p><strong>请仔细阅读本文和 <a href="https://github.com/WOA-Project/WOA-Deployer-Lumia">官网文档</a> ，确保理解每一步操作的目的之后再谨慎操作。如果真的损坏了我也无能为力。</strong></p>
</li>
<li>
<p>原则上只适用于 <strong>Lumia 950</strong> 和 <strong>Lumia 950 XL</strong> ，考虑到性能问题，还是推荐 <strong>Lumia 950 XL</strong> 。为了避免未知的问题，不建议使用 <strong>主力机</strong> 和 不可靠的 <strong>二手机</strong> 。</p>
</li>
<li>
<p>下面所有操作中最耗时的就是联网下载，所以网络很重要。另外，发现半夜 <strong>0 点</strong> 以后网络会好很多。有条件的请自备 <strong>VPN</strong> ，其实主要还是取决于服务端的网络情况，<strong>空闲时间段</strong> 会好点。</p>
</li>
<li>
<p>在操作前请保持 <strong>充足的电量</strong> ，避免带来不必要的问题。</p>
<p>( 有些操作过程中 <strong>USB</strong> 可能不会供电 )</p>
</li>
<li>
<p>注意下面操作的顺序，不按顺序操作可能会导致一些未知的问题。</p>
</li>
</ul>
<h3>解锁手机启动引导程序 ( <a href="https://github.com/WOA-Project/guides/blob/master/BL-unlock.md">参考官方文档</a> )</h3>
<hr>
<h5>准备工作</h5>
<ul>
<li>
<p>下载 <a href="https://wpinternals.net/index.php/downloads" rel="nofollow">WPInternals</a> - 解锁工具。</p>
<p>目前最新版是 <code>2.8</code> 。</p>
</li>
<li>
<p>下载 <a href="https://support.microsoft.com/en-us/help/12379/windows-10-mobile-device-recovery-tool-faq" rel="nofollow">Windows Device Recovery Tools</a> - 刷机工具，用于安装电脑驱动和手机恢复。</p>
<p>目前最新版是 <code>3.14.7501</code> 。</p>
</li>
<li>
<p>一个良好的网络，因为之后需要下载约 <strong>3 GB</strong> 大小的数据。</p>
</li>
<li>
<p>检查手机的 <strong>Windows 10 Mobile</strong> 版本，如果版本号大于 <code>10.0.15254.547</code> 则无法进行解锁，只能等待新版本的 <strong>WPInternals</strong> 或者将手机刷回旧版本的系统。</p>
</li>
</ul>
<h5>操作步骤</h5>
<ul>
<li>
<p>安装 <strong>Windows Device Recovery Tools</strong> ( 会下载安装一些 <strong>后面需要用到的驱动</strong> ) ，安装后不需要打开。这个过程网络不好会很慢，请耐心等待 ( 在这个过程中可以同时去下载系统镜像 ) 。</p>
</li>
<li>
<p>手机移除 <strong>SD 卡</strong> ，并连接到电脑上。虽然不知道插卡会带来什么问题，还是照做比较好。</p>
</li>
<li>
<p>解压并打开 <strong>WPInternals</strong> ，选择 <strong>Platform - Download</strong> 菜单，在 <strong>Model</strong> 部分会列出手机的设备类型和相关编码 ( 输入框如果没有自动填写则需要自己手动填写，内容见 <strong>Phone - Info</strong> 菜单 ) 。点击 <strong>Search</strong> 按钮，下面会列出相关的文件，再点击 <strong>Download all</strong> 按钮进行下载。下载路径默认为 <strong>C:\ProgramData\WPinternals\Repository</strong> ，可自定义为其他目录，后面需要用到这些文件 ( <strong>三个</strong> ) 。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/bad9276eb531fce3df9640bf8a7eb2e59e4b3a81/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383837316339346638663737323933612e706e67"><img src="https://camo.githubusercontent.com/bad9276eb531fce3df9640bf8a7eb2e59e4b3a81/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383837316339346638663737323933612e706e67" alt="WPInternals" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-8871c94f8f77293a.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>上一步的文件下载完毕就可以开始解锁了：选择 <strong>Unlock - Unlock bootloader</strong> 菜单，点击 <strong>OK</strong> 按钮，手机将重启切换到 <strong>刷机模式</strong> ( 深蓝色背景只显示一个 <strong>循环图标</strong> 的界面 ) 。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/bee9fe0fe0476b24403fd6de057bc0ba56fe14fd/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d386264343432323065366132613461352e706e67"><img src="https://camo.githubusercontent.com/bee9fe0fe0476b24403fd6de057bc0ba56fe14fd/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d386264343432323065366132613461352e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-8bd44220e6a2a4a5.png" style="max-width:100%;"></a></p>
</li>
<li>
<p><strong>WPinternals</strong> 在随后显示的页面中选择上一步的下载文件路径 ( 如果之前没有修改下载目录则不用动了 ) ，点击 <strong>Unlock</strong> 按钮开始解锁。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d2eb92e4953269e1d55f74752b4c1fe08d11f3f6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303132326464623531376537343662382e706e67"><img src="https://camo.githubusercontent.com/d2eb92e4953269e1d55f74752b4c1fe08d11f3f6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303132326464623531376537343662382e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-0122ddb517e746b8.png" style="max-width:100%;"></a></p>
<p>这个步骤会反复重启写入数据，手机屏幕显示红色背景。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/18110bbdf191db4b1e91f0e3ee372e10a49ddcf6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613230316435396562393239386563322e706e67"><img src="https://camo.githubusercontent.com/18110bbdf191db4b1e91f0e3ee372e10a49ddcf6/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613230316435396562393239386563322e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a201d59eb9298ec2.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/daf9ed01c51e65d9e94d47b6338ae97475607315/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d336461356134376164643732643638642e706e67"><img src="https://camo.githubusercontent.com/daf9ed01c51e65d9e94d47b6338ae97475607315/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d336461356134376164643732643638642e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-3da5a47add72d68d.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/629b0f61e31311007ba651f3648ab5ac22cfb71b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d306238333761303734306537356638662e706e67"><img src="https://camo.githubusercontent.com/629b0f61e31311007ba651f3648ab5ac22cfb71b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d306238333761303734306537356638662e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-0b837a0740e75f8f.png" style="max-width:100%;"></a></p>
<p>中间过程会出现下面的界面，需要 <strong>手动</strong> 重启手机 ( <strong>长按电源键 10 秒左右直到震动</strong> )  以继续。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/2c20d6646c13755950f34ce4e14c3d98df2b08d7/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383265346335663533663166663738322e706e67"><img src="https://camo.githubusercontent.com/2c20d6646c13755950f34ce4e14c3d98df2b08d7/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383265346335663533663166663738322e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-82e4c5f53f1ff782.png" style="max-width:100%;"></a></p>
<p>继续刷入数据。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1ed56601141e3f064a87a115aa57f50a538c72e1/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d633962616436353439656136386439652e706e67"><img src="https://camo.githubusercontent.com/1ed56601141e3f064a87a115aa57f50a538c72e1/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d633962616436353439656136386439652e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-c9bad6549ea68d9e.png" style="max-width:100%;"></a></p>
<p>解锁成功，手机会自动重启。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/b4937c06aa11ae93a2498d5b0f74e68b82e56e3f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373963643033383732346633623461342e706e67"><img src="https://camo.githubusercontent.com/b4937c06aa11ae93a2498d5b0f74e68b82e56e3f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373963643033383732346633623461342e706e67" alt="WPInternals-unlock" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-79cd038724f3b4a4.png" style="max-width:100%;"></a></p>
<p><strong>上面步骤多次执行可能会遇到一些不一样的情况，请根据提示进行处理。</strong></p>
<p>想重新 <strong>锁定手机启动引导程序</strong> ，选择 <strong>Unlock - Restore bootloader</strong> 菜单， 类似于上面的解锁步骤。</p>
</li>
</ul>
<h3>下载 Windows 10 ARM64 系统镜像 ( <a href="https://github.com/WOA-Project/guides/blob/master/GettingWOA.md">参考官方文档</a> )</h3>
<hr>
<ul>
<li>
<p>进入这个网站：<a href="https://uup.rg-adguard.net" rel="nofollow">https://uup.rg-adguard.net</a> 。</p>
</li>
<li>
<p>选择镜像的版本，注意要 <strong>arm64</strong> 版本的。这里我选择最新的 <strong>1903 专业版 [arm64]</strong> 。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/8297194b8935e99c591e21a6051d462bf8cbc7b4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653363663531616466363331316364392e706e67"><img src="https://camo.githubusercontent.com/8297194b8935e99c591e21a6051d462bf8cbc7b4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653363663531616466363331316364392e706e67" alt="镜像下载页面" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-e3cf51adf6311cd9.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>选择右边的脚本链接，点击直接下载脚本。</p>
</li>
<li>
<p>双击运行下载好的脚本 ( <strong>creatingISO_xxx_arm64_professional.cmd</strong> ) ，会在脚本目录下下载并编译 <strong>ISO</strong> 文件。<strong>最好有 10 GB 以上的可用空间</strong> 。</p>
</li>
</ul>
<h3>安装 Windows 10 ARM64</h3>
<hr>
<ul>
<li>
<p>手机连接到电脑。</p>
</li>
<li>
<p>打开 <strong>WPinternals</strong> ，选择 <strong>Phone - Manual mode</strong> 菜单，点击 <strong>Switch to Mass-Storage-mode</strong> 按钮切换手机到 <strong>大容量存储模式</strong> ( 手机会一直黑屏 ) 。</p>
</li>
<li>
<p>加载上一步下载的系统镜像到虚拟光驱：右键镜像文件 ( .ISO ) -&gt; 打开方式 -&gt; Windows 资源管理器。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/17118e02be3a0a7acb49f808176cb245c92a18da/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653635353061633830653264383864362e706e67"><img src="https://camo.githubusercontent.com/17118e02be3a0a7acb49f808176cb245c92a18da/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653635353061633830653264383864362e706e67" alt="系统镜像加载到虚拟光驱" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-e6550ac80e2d88d6.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>下载最新版的 <a href="https://github.com/WOA-Project/WOA-Deployer-Lumia/releases">WOA Deployer for Lumia</a> 。</p>
<p>目前最新版是 <code>2.5.2</code> 。</p>
</li>
<li>
<p>解压 <strong>WOA.Deployer.zip</strong> ，进入文件夹打开 <strong>WoaDeployer.exe</strong> 。</p>
</li>
<li>
<p><strong>WIM file</strong> 项选择刚才的镜像虚拟光驱，进入 <strong>sources</strong> 目录，选择文件 <strong>install.wim</strong> 。</p>
</li>
<li>
<p>点击 <strong>Deploy</strong> 按钮开始部署。这个过程会去下载相关的手机固件和驱动，速度取决于网络情况。</p>
</li>
<li>
<p>安装好之后会出现下面的弹框，点击 <strong>CONTINUE</strong> 按钮以继续。之后杀毒软件可能会报警，请允许操作。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/08d2ed09ddac485b8b625bef57170e6aa128c6e4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643464663362376565663362646664392e706e67"><img src="https://camo.githubusercontent.com/08d2ed09ddac485b8b625bef57170e6aa128c6e4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643464663362376565663362646664392e706e67" alt="WoaDeployer" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-d4df3b7eef3bdfd9.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>之后会进行 <strong>分区配置</strong> 、<strong>数据写入</strong> 和 <strong>驱动安装</strong> ，完毕会出现下面两个弹框，点击 <strong>CLOSE</strong> 即可。谨慎起见可以仔细阅读相关的内容。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/38f6d9f2558ee168f562914310980bc7aa26127e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d343535353936353430643564636533352e706e67"><img src="https://camo.githubusercontent.com/38f6d9f2558ee168f562914310980bc7aa26127e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d343535353936353430643564636533352e706e67" alt="WoaDeployer" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-455596540d5dce35.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/916bd9fdfec004fae30962791b20e7496da48a49/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303239333638656436373437373436312e706e67"><img src="https://camo.githubusercontent.com/916bd9fdfec004fae30962791b20e7496da48a49/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303239333638656436373437373436312e706e67" alt="WoaDeployer" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-029368ed67477461.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>重启手机 ( <strong>长按电源键 10 秒左右直到震动</strong> ) 。</p>
</li>
<li>
<p>这时手机出现了 <strong>PC</strong> 上的那种启动引导界面，选择默认的 <strong>Windows 10</strong> 项启动。</p>
<p>操作方式：<strong>音量键</strong> - 上下切换，<strong>拍照键</strong> - 确定。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/4e89719660e69a11ad31d37d90a36fcdf0240e89/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616365656635363534623464363461382e706e67"><img src="https://camo.githubusercontent.com/4e89719660e69a11ad31d37d90a36fcdf0240e89/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616365656635363534623464363461382e706e67" alt="手机启动引导程序界面" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-aceef5654b4d64a8.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>之后就是熟悉的 <strong>Windows 安装过程</strong> 了，不详细讲了，耐心等待即可。<strong>需要注意</strong>：中间会有几分钟的 <strong>黑屏</strong> 过程，请耐心等待，不要手贱重启手机 ( 会导致安装出错，就要重新安装了 ) 。</p>
</li>
<li>
<p>安装完毕会自动 <strong>重启</strong> 手机，重新进入 <strong>Windows 10</strong> ，开头会提示是否要安装驱动，选择 <strong>确定</strong> 就好，之后按照自己的需求进行配置。</p>
</li>
</ul>
<h3>设置 Win10 ARM 和 Win10 Mobile 双系统切换</h3>
<hr>
<p>通过上面的步骤我们已经成功安装了 <strong>Windows 10 ARM64</strong> ，这并不会覆盖默认的手机系统，只是屏蔽了而已，通过下面的步骤我们可以开启双系统切换。</p>
<ul>
<li>
<p>重启手机，启动引导界面选择 <strong>Developer - USB Mass Storage Mode</strong> ，切换到 <strong>大容量存储模式</strong> 。</p>
</li>
<li>
<p>打开 <strong>WOA Deployer for Lumia</strong></p>
</li>
<li>
<p>选择 <strong>Dual Boot</strong> 菜单</p>
</li>
<li>
<p>点击 <strong>Check Status</strong> 按钮检查状态。</p>
</li>
<li>
<p>点击 <strong>Enable Dual Boot</strong> 按钮，开启成功会弹框提示。</p>
</li>
<li>
<p>电脑移除手机，再重启手机，这时引导界面已经能看到 <strong>Windows 10 Phone</strong> 选项了。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/98d71476b1a0ad0510c76ed73019f0d4613b418c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383539663630623131323962346431392e706e67"><img src="https://camo.githubusercontent.com/98d71476b1a0ad0510c76ed73019f0d4613b418c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383539663630623131323962346431392e706e67" alt="手机启动引导程序界面-双系统" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-859f60b1129b4d19.png" style="max-width:100%;"></a></p>
</li>
</ul>
<h3>关于卸载 Windows 10 ARM64</h3>
<hr>
<p>目前没找到纯粹的卸载方法，只能选择重置手机。</p>
<ul>
<li>
<p><del>方案一</del></p>
<p>如果手机一切正常，进入 <strong>Windows 10 Phone</strong> 系统，使用自带的方式来 <strong>重置</strong> :</p>
<p><strong>设置 -&gt; 系统 -&gt; 关于 -&gt; 重置手机</strong></p>
<p>额，打脸了。这个方式重试了几遍都不行，也是无限重启的节奏。。</p>
</li>
<li>
<p>方案二</p>
<p>如果手机已经无法正常启动了，可以用这个方案 ( 手机正常也可以用这个方案 )</p>
<p>使用 <strong>Windows Device Recovery Tools</strong> 工具刷机，速度很快，具体步骤见下文。</p>
</li>
</ul>
<h3>关于手机恢复</h3>
<hr>
<p>按照官方文档的教程，本来已经一次性完美结束上面的步骤。后来为了写这篇教程，想反向操作 ( 重新锁定然后再解锁 ) 后重走一遍流程，结果一波瞎操作把手机弄挂了，还好可以通过 <strong>Windows Device Recovery Tools</strong> 刷机来恢复手机。<strong>所以，在这里再次提醒大家，操作需谨慎。</strong></p>
<p>恢复步骤很简单：</p>
<ul>
<li>
<p>打开 <strong>Windows Device Recovery Tools</strong> 。</p>
</li>
<li>
<p>正常情况下会自动识别，但是手机挂了就不行了，这时点击 <strong>未检测到我的手机</strong> ，选择 <strong>Lumia</strong>，等待连接。</p>
</li>
<li>
<p>连接手机并重启手机。像我的手机会无限重启，重启后被 <strong>Windows Device Recovery Tools</strong> 识别到就会自动切换 <strong>模式</strong> 而退出这种死循环。</p>
</li>
<li>
<p>连接上手机就会显示类似下面的内容</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/26460fb843cde600ad7c7e3fcd4f46da36f5ef63/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613864636365316361353233643238332e706e67"><img src="https://camo.githubusercontent.com/26460fb843cde600ad7c7e3fcd4f46da36f5ef63/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613864636365316361353233643238332e706e67" alt="Windows Device Recovery Tools" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a8dcce1ca523d283.png" style="max-width:100%;"></a></p>
</li>
<li>
<p>点击 <strong>安装软件</strong> 即可。之后会自动联网搜索可用的软件包并下载安装。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/58061a6f09d6bdf232518cd5bd4349f48893973e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643165303037613162353137323832392e706e67"><img src="https://camo.githubusercontent.com/58061a6f09d6bdf232518cd5bd4349f48893973e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643165303037613162353137323832392e706e67" alt="Windows Device Recovery Tools" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-d1e007a1b5172829.png" style="max-width:100%;"></a></p>
<p>软件包只有第一次不存在的时候才会去联网下载，之后就可以直接用下载好的软件包刷机即可，不用反复下载。</p>
<p>点击 <strong>Windows Device Recovery Tools</strong> 窗口右下角的 <strong>三个点</strong> 按钮可以展开底部菜单，点击里面的 <strong>设置</strong> 按钮，选择 <strong>软件包</strong> 菜单，设置自定义下载路径，方便之后备份和迁移。</p>
<p>值得一提的是，打开下载路径可以发现，里面有一个 <strong>.ffu</strong> 文件，它和 <strong>WPinternals</strong> 解锁步骤下载的文件是同一个，所以复制过来就好了，不用再下载了。</p>
</li>
<li>
<p>整个刷机过程 ( 手机显示 <strong>红色</strong> 背景色，最后可能会亮一下 <strong>绿色</strong> ) 大概 <strong>5 分钟</strong> 左右，成功后手机会自动重启并进入初始系统配置界面，按引导进行设置即可。</p>
<p><strong>有时候一次可能不成功，重新再刷一遍就好了。</strong></p>
</li>
</ul>
<p>刷机恢复的过程还是很简单的，但不代表就可以 <strong>随意</strong> 操作了，这只是个 <strong>备用方案</strong> ，最好还是期望 <strong>不要</strong> 用到它。如果出现 <strong>未知问题</strong> 或者 <strong>硬件损坏</strong>，那么 <strong>恢复工具</strong> 也无解了。所以还是那句话，要 <strong>谨慎操作</strong> 。</p>
<h3>使用感受</h3>
<hr>
<ul>
<li>
<p>开机启动非常慢。</p>
</li>
<li>
<p>整体还算流畅，触摸稍微有点卡，<strong>平板模式</strong> 下可以弹出屏幕键盘。</p>
</li>
<li>
<p>触摸不是很方便，买了一个 <strong>OTG 转接头 ( Type-C )</strong> ，打算连接 <strong>键鼠</strong> 进行操作。不过，发现目前还不支持 <strong>USB</strong> 。</p>
</li>
<li>
<p>手机 <strong>SIM</strong> 卡能识别，但是无法使用 <strong>移动数据</strong> 上网。据最新消息显示应该是已经支持 <strong>LTE</strong> 网络了，难道和我的 <strong>移动 4G</strong> 有关系？</p>
</li>
<li>
<p>声音只能开启或者关闭，不能调节大小。</p>
</li>
<li>
<p>不要使用 <strong>Boot Manager</strong> 提供的 <strong>重置模式</strong> 来重置手机，会导致无限重启。不相信的可以试试。</p>
</li>
</ul>
<h3>结语</h3>
<hr>
<p><strong>伪 · Surface Phone</strong> 已经出来了，<strong>真 · Surface Phone</strong> 还会远吗？</p>
<h5>未完待续...</h5>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/1a336b3053f4">https://www.jianshu.com/p/1a336b3053f4</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-8871c94f8f77293a.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[IntelliJ IDEA 插件和经验分享]]></title>
            <link>https://anyesu.github.io/blog/articles/28</link>
            <guid>28</guid>
            <pubDate>Wed, 25 Sep 2019 14:22:54 GMT</pubDate>
            <description><![CDATA[前言 工欲善其事必先利其器，用 IntelliJ IDEA 开发几年了，它带来工作效率上的提升是很显著的。本文分享一些好用的插件和经验。 插件 activate-power-mode 酷炫的代码编辑效果。玩玩就行了。 Alibaba Java Coding Guidelines 基于 Java 开发手册 的 Java 代码规约扫描插件 。对于不符合规范的代码会提示 推荐用法 或 快捷修复 ，有代码]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>工欲善其事必先利其器，用 <strong>IntelliJ IDEA</strong> 开发几年了，它带来工作效率上的提升是很显著的。本文分享一些好用的插件和经验。</p>
<h3>插件</h3>
<hr>
<ul>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/8330-activate-power-mode" rel="nofollow">activate-power-mode</a></p>
<p>酷炫的代码编辑效果。玩玩就行了。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" rel="nofollow">Alibaba Java Coding Guidelines</a></p>
<p>基于 <a href="https://github.com/alibaba/p3c">Java 开发手册</a> 的 <strong>Java 代码规约扫描插件</strong> 。对于不符合规范的代码会提示 <strong>推荐用法</strong> 或 <strong>快捷修复</strong> ，有代码洁癖的小伙伴赶紧去用吧。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/4230-bashsupport" rel="nofollow">BashSupport</a></p>
<p>提供对 <strong>Bash</strong> 语言的支持，支持运行配置、语法高亮、改名重构、查看注释文档、语法检查、命令提示，最主要还是可以做 <strong>代码跳转</strong>。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/12321-battery-status" rel="nofollow">Battery Status</a></p>
<p>在 <strong>IDEA 状态栏</strong> 显示 <strong>电池状态</strong> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7275-codeglance" rel="nofollow">CodeGlance</a></p>
<p>在滚动条边上显示代码文件内容缩略图，可以快速定位到指定位置。玩玩就行了。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/8580-cpu-usage-indicator" rel="nofollow">CPU Usage Indicator</a></p>
<p>在 <strong>IDEA 状态栏</strong> 显示 <strong>CPU 使用率</strong> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10524-element" rel="nofollow">element</a></p>
<p>提供对 <a href="https://element.eleme.cn/" rel="nofollow">饿了么 Element UI 组件库</a> 的支持。前端开发有用。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/9525--env-files-support" rel="nofollow">.env files support</a></p>
<p>提供对 <strong>.env</strong> 文件的支持。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7296-ejs" rel="nofollow">EJS</a></p>
<p>提供对 <a href="https://ejs.bootcss.com/" rel="nofollow">EJS 模板引擎</a> 的支持。前端开发有用。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7494-eslint" rel="nofollow">ESLint</a></p>
<p>提供 <a href="https://cn.eslint.org/" rel="nofollow">ESLint</a> 的支持，用于前端代码的检查和快速修复。前端开发有用。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7177-file-watchers" rel="nofollow">File Watchers</a></p>
<p>用于监听文件变化，可以用于 <a href="https://prettier.io/docs/en/webstorm.html#running-prettier-on-save-using-file-watcher" rel="nofollow">前端代码保存的时候自动格式化</a> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7125-grep-console" rel="nofollow">Grep Console</a></p>
<p>主要用于日志输出颜色控制 ( 但是 error 日志打印只有首行有颜色 ) 。</p>
<p>配色清单 ( 只设置前景色，不设置背景色 ) ：</p>
<table role="table">
<thead>
<tr>
<th>日志级别</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>.*VERBOSE.*</td>
<td>BBBBBB</td>
</tr>
<tr>
<td>.*DEBUG.*</td>
<td>0070BB</td>
</tr>
<tr>
<td>.*INFO.*</td>
<td>48BB31</td>
</tr>
<tr>
<td>.*WARN.*</td>
<td>BBBB23</td>
</tr>
<tr>
<td>.*ERROR.*</td>
<td>FF6464</td>
</tr>
<tr>
<td>.*ASSERT.*</td>
<td>8F0005</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7495--ignore" rel="nofollow">.ignore</a></p>
<p>提供对 <strong>.ignore</strong> 文件的支持。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/9195-jb-sdk-bintray-downloader" rel="nofollow">JB SDK Bintray Downloader</a></p>
<p>用于切换 <strong>IDEA</strong> 自带的 <strong>JVM</strong> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/4441-jrebel-for-intellij" rel="nofollow">JRebel for IntelliJ</a></p>
<p><strong>Java 热部署插件</strong> ，大部分场景下修改了代码只要 <code>Ctrl + B</code> 编译下代码就即时生效了，无需频繁重启项目。比起 <strong>SpringBoot</strong> 的 <strong>devtools</strong> 好用多了。<strong>另外，不建议开启自动编译，很消耗性能。</strong></p>
<p><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/jrebel-setup.html" rel="nofollow">安装教程</a>   <a href="https://www.hexianwei.com/2019/07/10/jrebel%E6%BF%80%E6%B4%BB/" rel="nofollow">破解教程</a></p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/6317-lombok" rel="nofollow">Lombok</a></p>
<p>提供对 <a href="https://projectlombok.org/features/all" rel="nofollow">Lombok</a> 的支持。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7793-markdown-support" rel="nofollow">Markdown support</a></p>
<p>默认集成的 <strong>Markdown</strong> 插件，除了不支持 <strong>emoji</strong> 表情，其他都够用了。</p>
<p><strong>win10</strong> 下高分辨率设置了 <strong>显示缩放</strong> 会导致 <strong>Markdown 的预览效果页面</strong> 文字很模糊。</p>
<p>解决办法：使用 <strong>JB SDK Bintray Downloader</strong> 插件升级到最新的 <strong>JB SDK</strong>  ( <a href="https://blog.csdn.net/zdxxinlang/article/details/78391060" rel="nofollow">参考</a> ) ，或者使用自己下载的 <strong>JDK</strong> ( <a href="https://blog.csdn.net/zaemyn2015/article/details/84584458" rel="nofollow">参考</a> ) 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui" rel="nofollow">Material Theme UI</a></p>
<p>主题插件，用于配置 <strong>IDEA</strong> 的 <strong>UI 组件</strong> 的显示效果。刚开始用可能会比较刺眼，一个月使用下来已经习惯了。</p>
<p>我的配置方案：</p>
<pre><code>File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; Material Theme
( 当然也可以直接点击状态栏的小图标直接进入 )

基础模版选择 Material Oceanic

Compact: 勾选 StatusBar / Table Cells / Dropdown Lists / Menus
Project View: Sidebar Height 设置为 22
Components: 取消勾选 Uppercase buttons

另外编辑区的背景色改成和主体背景色一样的 #263238
</code></pre>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" rel="nofollow">Maven Helper</a></p>
<p>用于 <strong>Maven</strong> 依赖冲突检查 ( <a href="https://blog.csdn.net/keketrtr/article/details/52513671" rel="nofollow">参考</a> ) 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/7293-mybatis-plugin" rel="nofollow">MyBatis plugin</a></p>
<p>提供对 <strong>MyBatis</strong> 的支持，支持 <strong>Mapper.java</strong> 和 <strong>Mapper.xml</strong> 之间相互的代码跳转，根据 <strong>Mapper.java</strong> 自动生成对应的 <strong>Mapper.xml</strong> 和 <strong>SQL</strong> 等功能。这个插件是收费的，破解方法参考 <a href="https://github.com/myoss/profile/blob/master/idea/plugin/MybatisPlugin/Mybatis-Plugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.txt">这里</a> ，破解版虽然能用，但是启动的时候还是会花几十秒联网校验，导致 <strong>IDEA</strong> 启动很慢。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx" rel="nofollow">MyBatisX</a></p>
<p><strong>MyBatis plugin</strong> 的免费替代品，功能相对少一点。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin" rel="nofollow">MyBatis Log Plugin</a></p>
<p>用于将 <strong>MyBatis</strong> 输出的日志转为实际执行的具体 <strong>SQL</strong> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/4415-nginx-support" rel="nofollow">nginx Support</a></p>
<p>提供对 <strong>Nginx</strong> 配置文件的支持，支持 <strong>语法高亮</strong> 和 <strong>语法提示</strong> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10456-prettier" rel="nofollow">Prettier</a></p>
<p>提供对 <strong>Prettier</strong> 的支持 ( <a href="http://web.jobbole.com/94786/" rel="nofollow">参考</a> ) 。需要自己设置格式化快捷键或者配合上面的 <strong>File Watchers</strong> 使用。前端开发有用。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit" rel="nofollow">RestfulToolkit</a></p>
<p>通过快捷键 <code>Ctrl + \</code> 快速检索项目中定义的 <strong><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/RequestMapping/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/RequestMapping">@RequestMapping</a></strong> ，支持模糊搜索。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation" rel="nofollow">String Manipulation</a></p>
<p>字符串格式转换工具，比如大小写，驼峰与下划线互转，自己试试就知道了。快捷键 <code>Alt + M</code> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/8579-translation" rel="nofollow">Translation</a></p>
<p>翻译插件，对于英语渣渣来说很有用，看源码不用再切出去百度了。我设置的翻译快捷键是 <code>Alt + Z</code> 。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/183-upperlowercapitalize" rel="nofollow">UpperLowerCapitalize</a></p>
<p>大小写切换插件， <code>Alt + P</code> 切换到全大写， <code>Alt + L</code> 切换到全小写。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/9442-vue-js" rel="nofollow">Vue.js</a></p>
<p>提供对 <a href="https://vuejs.org/" rel="nofollow">Vue.js</a> 的支持。前端开发有用。</p>
</li>
<li>
<p><a href="https://plugins.jetbrains.com/plugin/11269-who-did-it" rel="nofollow">who did it</a></p>
<p>目录树文件名后面像 <strong>Eclipse</strong> 一样显示 <strong>版本控制 ( Git / SVN )</strong> 的最后修改人/时间，没必要还是不要开了，有点卡。</p>
</li>
</ul>
<p>把 <a href="https://plugins.jetbrains.com/search?pr=idea&amp;pr_productId=idea&amp;orderBy=downloads&amp;correctionAllowed=false&amp;offset=0&amp;max=10" rel="nofollow">插件市场</a> 3000+ 的插件都大概浏览了一遍，稍微实用点的都列在上面了 ( <strong>按名称排序</strong> ) ，剩下还有一些 <strong>其他语言</strong> 、<strong>框架</strong> 相关的插件自己去搜一下吧。</p>
<h3>使用经验</h3>
<hr>
<ul>
<li>
<p><strong>关于激活</strong></p>
<p><del>注册码点击 <a href="http://idea.lanyus.com/" rel="nofollow">这里</a> 获取</del> ( 目前已暂停提供激活码 ) ，需要把下面的配置加入到 <strong>hosts</strong> 文件中。有条件的还是支持下正版吧。</p>
<pre><code>0.0.0.0 account.jetbrains.com
# 下面这个是官网，2019.1版本起，IDEA启动的时候会从官网校验注册码，所以需要屏蔽，需要访问官网时再注释掉配置
0.0.0.0 www.jetbrains.com
</code></pre>
</li>
<li>
<p><strong>关于升级</strong></p>
<p>建议一直保持最新版，官网的 <a href="https://www.jetbrains.com/idea/whatsnew/" rel="nofollow">更新日志</a> 写的很详细了，可以好好阅读下。如果不放心，可以迟几小个版本。更新前最好做好配置文件的备份 ( <strong>Windows</strong> 在 <code>%HOMEPATH%</code> 目录下，比如 <code>.IntelliJIdea2019.1</code> ) 。</p>
</li>
<li>
<p><strong>全局检索</strong></p>
<p><code>2018.3</code> 版本起，双击 <code>shift</code> 即可调出全新的 <strong>Search Everywhere</strong> ，合并了原先 <strong>类、文件、符号、Action</strong> 的搜索。</p>
</li>
<li>
<p><strong>运行一切</strong></p>
<p><code>2018.3</code> 版本起，双击 <code>Ctrl</code> 调出窗口，可以执行 <strong>运行配置</strong> 或者 <strong>终端命令</strong>。在这个窗口下按 <code>shift</code> 切换 <code>run/debug</code> 模式。</p>
</li>
<li>
<p><strong>关于配色方案</strong></p>
<p>我的 <strong>配色方案</strong> 用了几年了，还不错，不过找不到原始地址了。分享一个 <a href="http://www.easycolor.cc/" rel="nofollow">项目</a> ，自己选一个合适的 <strong>配色方案</strong> 吧，不刺眼不太暗的，眼睛看着舒服点的比较好。</p>
</li>
<li>
<p><strong>关于快捷键</strong></p>
<p>File -&gt; Settings -&gt; Keymap，我更习惯 <strong>eclipse</strong> 风格的快捷键。</p>
</li>
<li>
<p><strong>启动时不打开工程</strong></p>
<p>File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Startup/Shutdown 标签项 -&gt; 去掉 Reopen last project on startup 。</p>
</li>
<li>
<p><strong>备份个性化设置</strong></p>
<p>File -&gt; Export Settings 。</p>
</li>
<li>
<p><strong>Project 目录隐藏无关的配置文件</strong></p>
<p>File -&gt; Settings -&gt; Editor -&gt; File Types -&gt; Ignore files and folders 追加下面内容 ( 注意分号隔开 ) 。</p>
<pre><code>*.log;*.iml;.idea;.classpath;.project;.settings;
</code></pre>
</li>
<li>
<p><strong>打开之后自动启动项目</strong></p>
<p>File -&gt; Settings -&gt; Tools -&gt; Startup Tasks 自行添加运行配置。</p>
</li>
<li>
<p><strong>Version Control</strong></p>
<p>集成各种 <strong>版本控制</strong> 工具的客户端，也是我用过 <strong>Windows</strong> 平台下最好用的 <strong>Git</strong> 客户端 ，没有之一。</p>
</li>
<li>
<p><strong>Decompiler</strong></p>
<p>反编译 <strong>class</strong> 专用，谁用谁知道。要是整个 <strong>Jar 包</strong> 反编译还是用 <a href="https://github.com/java-decompiler/jd-gui">JD-GUI</a> 吧。</p>
</li>
<li>
<p><strong>Terminal</strong></p>
<p>轻量好用的终端工具，不仅支持本地命令执行，还能连接远程主机，可以 <code>Ctrl + C/V</code> 二连很重要。</p>
</li>
<li>
<p>搭配 <strong>Docker</strong> 使用</p>
<p>详见 <a href="https://www.jianshu.com/p/410ea6e0b13a" rel="nofollow">IntelliJ IDEA 使用 Docker 远程部署</a> 。</p>
</li>
<li>
<p><a href="https://blog.csdn.net/aaashen/article/details/46740817" rel="nofollow">不识别文件类型的解决方案</a></p>
</li>
<li>
<p><a href="https://jingyan.baidu.com/article/f96699bb040a63894e3c1bde.html" rel="nofollow">IntelliJ IDEA 如何查看或显示实时内存</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/mingjie1212/article/details/52281847" rel="nofollow">配置 Tomcat 远程调试</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/u014424628/article/details/49429393" rel="nofollow">IDEA 环境下设置 jvm 默认编码</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/lfm601508022/p/6529118.html" rel="nofollow">关于 IntelliJ IDEA 文档无法编辑的解决办法</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/wenston/p/5286150.html" rel="nofollow">支持 ES6 语法</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/lilovfly/article/details/77659541" rel="nofollow">idea 下字符串的长度太大</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/zhyh1986/article/details/46469173" rel="nofollow">设置忽略部分类编译错误</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/wangjun5159/article/details/71250367" rel="nofollow">版本控制下 修改文件后，父文件夹也标注修改</a> ( 项目级配置 )</p>
</li>
<li>
<p><a href="https://blog.csdn.net/xu_joy/article/details/54139070" rel="nofollow">行注释设置 ( 不显示在行首 )</a></p>
<p>可以勾上 <code>Add a space at comment start</code></p>
</li>
<li>
<p><a href="https://blog.csdn.net/chenhaifeng2016/article/details/54315472" rel="nofollow">使用 Docker</a></p>
</li>
<li>
<p><a href="https://jingyan.baidu.com/article/154b463108b81928cb8f417b.html" rel="nofollow">使用自带插件显示 java 类的字节码</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/huanxianglove/article/details/80743376" rel="nofollow">自动删除类中无用的 import 包</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/cgl125167016/article/details/78754246" rel="nofollow">文件代码模板的使用</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/yuanhang1996/article/details/86030070" rel="nofollow">文件模板变量</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_35170213/article/details/82953837" rel="nofollow">idea 查看一个类的所有子类以及子类的子类并以层级关系显示</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/52537364" rel="nofollow">IntelliJ IDEA 中如何设置同时打开多个文件且分行显示 --- 即如何设置 tabs</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/deng-cc/p/6927447.html" rel="nofollow">使用 IntelliJ IDEA 查看类的继承关系图形</a></p>
</li>
<li>
<p><a href="https://www.itcodemonkey.com/article/10886.html" rel="nofollow">2018.3 更新内容</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/77449117" rel="nofollow">IntelliJ IDEA 使用教程（总目录篇）</a></p>
</li>
</ul>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/e3f83c4c2d7e">https://www.jianshu.com/p/e3f83c4c2d7e</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[树莓派快速入门配置]]></title>
            <link>https://anyesu.github.io/blog/articles/27</link>
            <guid>27</guid>
            <pubDate>Mon, 23 Sep 2019 17:02:26 GMT</pubDate>
            <description><![CDATA[前言 最近刚入坑树莓派，在这里做个分享。 购物清单 设备 价格 说明 Raspberry Pi 3B+ ( 单独主板 ) ￥228 按网上的说法，E14 和 RS 除了产地没区别 树莓派 5V3A 电源 + 开关电源线 ￥29.7 大功率电源可以接更多设备，开关可以减少插拔 闪迪 32g 内存卡 class10 存储 sd卡 ￥28.50 已有十年前的 8G TF 卡和读卡器，为了保险起见还是买了]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>最近刚入坑树莓派，在这里做个分享。</p>
<h3>购物清单</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>设备</th>
<th>价格</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Raspberry Pi 3B+ ( 单独主板 )</td>
<td>￥228</td>
<td>按网上的说法，E14 和 RS 除了产地没区别</td>
</tr>
<tr>
<td>树莓派 5V3A 电源 + 开关电源线</td>
<td>￥29.7</td>
<td>大功率电源可以接更多设备，开关可以减少插拔</td>
</tr>
<tr>
<td>闪迪 32g 内存卡 class10 存储 sd卡</td>
<td>￥28.50</td>
<td>已有十年前的 8G TF 卡和读卡器，为了保险起见还是买了张新卡</td>
</tr>
<tr>
<td>树莓派3B+ 彩虹层叠外壳 + 散热片 + 风扇</td>
<td>￥31</td>
<td>看中的是不一样的外观</td>
</tr>
</tbody>
</table>
<p><strong>其他已有的调试必备硬件：</strong></p>
<ul>
<li>
<p>显示器 + HDMI 线</p>
</li>
<li>
<p>USB 键鼠</p>
</li>
<li>
<p>TF 读卡器</p>
</li>
<li>
<p>网线 ( 非必须 )</p>
</li>
</ul>
<p>淘宝链接就不给了，自己去货比三家吧，都差不多。如果不清楚要买什么，还是推荐购买卖家提供的基础套件大礼包。对了，我买的主板 <strong>电源指示灯</strong> 是不亮的 ( 应该是硬件坏了 ) ，折腾完系统才发现这茬事，虽然能正常使用还是有点不爽。</p>
<h3>安装系统</h3>
<hr>
<h5>1. 下载镜像</h5>
<ul>
<li>
<p><a href="https://www.raspberrypi.org/downloads/raspbian/" rel="nofollow">Raspbian</a> ( 官方镜像 )</p>
</li>
<li>
<p><a href="https://www.raspberrypi.org/downloads/noobs/" rel="nofollow">NOOBS</a> ( 只要解压到 TF 卡根目录，无须烧录，<a href="https://blog.csdn.net/diandianxiyu_geek/article/details/78949393" rel="nofollow">参考</a> )</p>
</li>
<li>
<p><a href="https://ubuntu-mate.org/raspberry-pi/" rel="nofollow">Ubuntu MATE</a></p>
</li>
</ul>
<p>上面都是亲测可用的系统，下文以 <strong>2019-04-08-raspbian-stretch-full</strong> 举例。使用迅雷通过种子方式下载还是比较快的，下载后要 <strong>解压</strong> 。<strong>Ubuntu MATE</strong> 对于 <strong>WiFi</strong> 的兼容性不太好，家里旧的路由器只有小概率能连上。</p>
<h5>2. TF 卡格式化</h5>
<p>使用 <strong>SDFormatter</strong> 格式化 <strong>TF 卡</strong> ( 报错失败就重试 ) ，<a href="http://dl-t1.wmzhe.com/14/14937/PanasonicSDFormatter_ha.zip" rel="nofollow">点此下载</a></p>
<h5>3. 烧录系统</h5>
<p>使用 <a href="https://nchc.dl.sourceforge.net/project/win32diskimager/Archive/win32diskimager-1.0.0-install.exe" rel="nofollow">win32diskimager</a> 或者官网推荐的 <a href="https://www.balena.io/etcher/" rel="nofollow">Etcher</a> ，烧录速度取决于 <strong>TF 卡</strong> 的写入速度。烧录完成由于系统无法识别 <strong>TF 卡</strong>，会弹框提示 <strong>格式化</strong>，千万别手贱去点。<strong>重新</strong> 烧录系统前记得先 <strong>格式化 TF 卡</strong> 。</p>
<h3>系统配置</h3>
<hr>
<p>由于安装的系统默认都没有开启 <strong>SSH</strong> , 所以还得先用上显示器、键鼠和网线。</p>
<h5>1.  树莓派插入 TF 卡，连接显示器、网线、键鼠，再启动树莓派</h5>
<p>注意顺序，先通电再连显示器可能会无法识别显示器。</p>
<h5>2. 根据开机引导设置国家和密码，其他设置跳过，重启树莓派</h5>
<h5>3. 开启 SSH 和 <a href="http://shumeipai.nxez.com/2018/08/31/raspberry-pi-vnc-viewer-configuration-tutorial.html" rel="nofollow">VNC</a> ，现在可以摆脱显示器和键鼠，通过电脑远程连接了</h5>
<p>点击任务栏左上角的 <strong>草莓图标</strong> -&gt; <strong>首选项</strong> -&gt; <strong>Raspberry Pi Configuration</strong> -&gt; <strong>Interfaces 选项卡</strong> ，对应项选择 <strong>Enable</strong> ，点击 <strong>OK</strong> 保存。</p>
<h5>4. 修改为中科大的软件源</h5>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1. 备份原来的数据源配置文件</span>
sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup
<span class="pl-c"><span class="pl-c">#</span> 2. 修改数据源配置文件</span>
sudo sh -c <span class="pl-s"><span class="pl-pds">'</span>echo "deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi" &gt; /etc/apt/sources.list<span class="pl-pds">'</span></span>
<span class="pl-c"><span class="pl-c">#</span> 3. 更新配置</span>
sudo apt-get update</pre></div>
<h5>5. 自带的 vi 编辑器有点问题，可以安装 vim 或者使用 nano 代替</h5>
<div class="highlight highlight-source-shell"><pre>sudo apt-get install -y vim</pre></div>
<h5>6. 设置 WiFi ( <a href="https://www.cnblogs.com/playboysnow/p/4987103.html" rel="nofollow">参考</a> )</h5>
<p>任务栏点击 <strong>WiFi</strong> 图标选择自己的网络即可。配置文件为 <strong>/etc/wpa_supplicant/wpa_supplicant.conf</strong> 中，可自己手动添加配置，如果 <strong>WiFi</strong> 禁用了广播 <strong>SSID</strong> ，还需要添加配置项 <code>scan_ssid=1</code> ( 重启树莓派后自动连接 )</p>
<h5>7. 安装 zsh</h5>
<p>这个看个人需求了，不需要的请略过此步骤。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 安装 zsh</span>
sudo apt-get -y install zsh
<span class="pl-c"><span class="pl-c">#</span> 修改账户的默认 shell</span>
chsh -s <span class="pl-s"><span class="pl-pds">`</span>which zsh<span class="pl-pds">`</span></span>
<span class="pl-c"><span class="pl-c">#</span> 下载配置 ~/.zshrc</span>
curl -L https://raw.githubusercontent.com/skywind3000/vim/30b702725847bac4708de34664bb68454b54e0c0/etc/zshrc.zsh <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/.zshrc

<span class="pl-c"><span class="pl-c">#</span> 修改主题, 参考：https://github.com/robbyrussell/oh-my-zsh/wiki/themes</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>s$# antigen theme fishy$antigen theme ys$<span class="pl-pds">'</span></span> <span class="pl-k">~</span>/.zshrc

<span class="pl-c"><span class="pl-c">#</span> zsh 按键补齐</span>
cat <span class="pl-k">&gt;&gt;</span> <span class="pl-k">~</span>/.zshrc <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s"># key bindings</span>
<span class="pl-s">bindkey "\e[1~" beginning-of-line</span>
<span class="pl-s">bindkey "\e[4~" end-of-line</span>
<span class="pl-s">bindkey "\e[5~" beginning-of-history</span>
<span class="pl-s">bindkey "\e[6~" end-of-history</span>
<span class="pl-s"></span>
<span class="pl-s"># for rxvt</span>
<span class="pl-s">bindkey "\e[8~" end-of-line</span>
<span class="pl-s">bindkey "\e[7~" beginning-of-line</span>
<span class="pl-s"># for non RH/Debian xterm, can't hurt for RH/DEbian xterm</span>
<span class="pl-s">bindkey "\eOH" beginning-of-line</span>
<span class="pl-s">bindkey "\eOF" end-of-line</span>
<span class="pl-s"># for freebsd console</span>
<span class="pl-s">bindkey "\e[H" beginning-of-line</span>
<span class="pl-s">bindkey "\e[F" end-of-line</span>
<span class="pl-s"># completion in the middle of a line</span>
<span class="pl-s">bindkey '^i' expand-or-complete-prefix</span>
<span class="pl-s"></span>
<span class="pl-s"># Fix numeric keypad  </span>
<span class="pl-s"># 0 . Enter  </span>
<span class="pl-s">bindkey -s "^[Op" "0"</span>
<span class="pl-s">bindkey -s "^[On" "."</span>
<span class="pl-s">bindkey -s "^[OM" "^M"</span>
<span class="pl-s"># 1 2 3  </span>
<span class="pl-s">bindkey -s "^[Oq" "1"</span>
<span class="pl-s">bindkey -s "^[Or" "2"</span>
<span class="pl-s">bindkey -s "^[Os" "3"</span>
<span class="pl-s"># 4 5 6  </span>
<span class="pl-s">bindkey -s "^[Ot" "4"</span>
<span class="pl-s">bindkey -s "^[Ou" "5"</span>
<span class="pl-s">bindkey -s "^[Ov" "6"</span>
<span class="pl-s"># 7 8 9  </span>
<span class="pl-s">bindkey -s "^[Ow" "7"</span>
<span class="pl-s">bindkey -s "^[Ox" "8"</span>
<span class="pl-s">bindkey -s "^[Oy" "9"</span>
<span class="pl-s"># + - * /  </span>
<span class="pl-s">bindkey -s "^[Ol" "+"</span>
<span class="pl-s">bindkey -s "^[Om" "-"</span>
<span class="pl-s">bindkey -s "^[Oj" "*"</span>
<span class="pl-s">bindkey -s "^[Oo" "/"</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c"><span class="pl-c">#</span> 配置修改完重新执行 zsh</span>
zsh</pre></div>
<h3>备份系统</h3>
<hr>
<p>上面辛辛苦苦终于配置完系统了，还剩下一个问题：如果系统玩坏了或者买了新设备，难道又要花一堆时间重复上面的步骤？当然不必，我们可以针对配置好的系统进行备份，方便以后快速恢复。</p>
<p>备份前先清空下历史命令</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">echo</span> <span class="pl-k">&gt;</span> .bash_history
<span class="pl-c"><span class="pl-c">#</span> echo &gt; .zsh_history</span></pre></div>
<ul>
<li>
<p><strong>方案一</strong>：使用 <strong>Raspbian</strong> 系统自带的工具 <strong>SD Card Copier</strong></p>
<p>将另一张 <strong>TF 卡</strong> 通过读卡器插入树莓派的 <strong>USB 接口</strong>，点击任务栏左上角的 <strong>草莓图标</strong> -&gt; <strong>附件</strong> -&gt; <strong>SD Card Copier</strong> ，<strong>Copy From Device</strong> 选择 <code>/dev/mmcblk0</code> ，<strong>Copy To Device</strong> 选择 <code>/dev/sda</code> , 点击 <strong>Start</strong> 开始备份，时间约 10 ~ 30 分钟。这个方案比较简单快速，但需要一张额外的 <strong>TF 卡</strong>。</p>
</li>
<li>
<p><strong>方案二</strong>：使用 <strong>win32diskimager</strong></p>
<p>上文中烧录系统使用 <strong>win32diskimager</strong> 的写入功能，备份就是使用它的读取功能，将 <strong>TF 卡</strong> 中的数据备份到指定的文件中。新建一个txt文件，<strong>带后缀名</strong> 一起重命名为 <strong>backup.img</strong>，然后在 <strong>win32diskimager</strong> 中选择这个空文件，插入装好系统的 <strong>TF 卡</strong>，开始读取。备份结束就可以使用这个镜像来烧录系统了。这个方法也比较简单，但是比较浪费空间和时间，因为卡容量有多大，备份的镜像就有多大，所以还是尽量选容量小一点的卡 ( 8G ) 来备份。</p>
</li>
<li>
<p><strong>方案三</strong>：<del>在树莓派中借助别人写好的脚本导出备份到镜像中 ( <a href="https://www.jianshu.com/p/c6055f9545fd" rel="nofollow">参考</a> )</del></p>
<p>该方法能成功导出镜像，但是启动会卡在四个草莓的界面，所以该方法无效。</p>
</li>
</ul>
<h3>扩展阅读</h3>
<hr>
<p>上文中到一些概念没有细讲如：<strong>SSH</strong> 、<strong>VNC</strong> 、<strong>ZSH</strong>，还有一些 <strong>Linux</strong> 相关的使用，可以参考我的另一篇文章 - <a href="https://www.jianshu.com/p/bc38ed12da1d" rel="nofollow">Windows10内置Linux子系统初体验</a></p>
<h3>结语</h3>
<hr>
<p>经过上面的配置，树莓派已经正式成为了一台微型家用服务器了，如果止步于此的话还不如买一台云服务器玩玩呢。树莓派于我的意义在于丰富的硬件和传感器控制，再配合天猫精灵还有云服务器，打造属于自己的智能家居场景。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/742c2697a007">https://www.jianshu.com/p/742c2697a007</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[搬瓦工 SS 和 VPN 一键配置脚本]]></title>
            <link>https://anyesu.github.io/blog/articles/26</link>
            <guid>26</guid>
            <pubDate>Mon, 23 Sep 2019 16:30:36 GMT</pubDate>
            <description><![CDATA[背景 工作需要，买了一台 搬瓦工 VPS 用于科学上网。但是，目前已经不支持在 VPS 管理面板直接 配置 SS 和 VPN 服务了，需要自己手动安装服务。 购买 VPS 购买教程见 这里 ，不再赘述了。需要提一点，之前 最低配 已经没库存了或者说是下架了，目前能购买的 最低配 是 300 RMB / 年。 配置操作系统 由于 CentOS 和 Docker 会产生一些莫名其妙的问题，所以我选择 ]]></description>
            <content:encoded><![CDATA[<h3>背景</h3>
<hr>
<p>工作需要，买了一台 <strong>搬瓦工 VPS</strong> 用于科学上网。但是，目前已经不支持在 <strong>VPS</strong> 管理面板直接 <a href="http://blog.sina.com.cn/s/blog_19a25efa60102ymhb.html" rel="nofollow">配置</a> <strong>SS</strong> 和 <strong>VPN</strong> 服务了，需要自己手动安装服务。</p>
<h3>购买 VPS</h3>
<hr>
<p>购买教程见 <a href="https://www.banwago.com/922.html" rel="nofollow">这里</a> ，不再赘述了。需要提一点，之前 <a href="https://bwh8.net/cart.php?a=add&amp;pid=43" rel="nofollow">最低配</a> 已经没库存了或者说是下架了，目前能购买的 <a href="https://bwh8.net/cart.php?a=confproduct&amp;i=0" rel="nofollow">最低配</a> 是 <strong>300 RMB / 年</strong>。</p>
<h3>配置操作系统</h3>
<hr>
<p>由于 <strong>CentOS</strong> 和 <strong>Docker</strong> 会产生一些莫名其妙的问题，所以我选择 <strong>Ubuntu 18.04 x86_64</strong></p>
<p>安装完系统记得修改 <strong>root</strong> 密码，<strong>Ubuntu</strong> 记得执行下面的命令安装 <strong>curl</strong></p>
<div class="highlight highlight-source-shell"><pre>apt-get update
apt-get install -y curl</pre></div>
<h3>一键配置脚本</h3>
<hr>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 搬瓦工 SS 和 VPN 一键配置脚本</span>

<span class="pl-c"><span class="pl-c">#</span> 安装 docker</span>
curl -sSL https://get.docker.com <span class="pl-k">|</span> sh

<span class="pl-c"><span class="pl-c">#</span> 设置开机启动</span>
systemctl <span class="pl-c1">enable</span> docker.service
systemctl is-enabled docker.service

<span class="pl-c"><span class="pl-c">#</span> 启动 docker</span>
service docker start

<span class="pl-c"><span class="pl-c">#</span> 安装 docker-compose</span>
curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-<span class="pl-s"><span class="pl-pds">`</span>uname -s<span class="pl-pds">`</span></span>-<span class="pl-s"><span class="pl-pds">`</span>uname -m<span class="pl-pds">`</span></span> <span class="pl-k">&gt;</span> /tmp/docker-compose
chmod +x /tmp/docker-compose
mv /tmp/docker-compose /usr/local/bin/docker-compose

mkdir -p /root/proxy
<span class="pl-c1">cd</span> /root/proxy

<span class="pl-c"><span class="pl-c">#</span> 写配置</span>
cat <span class="pl-k">&gt;</span> .env <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s"># SS 密码</span>
<span class="pl-s">SHADOWSOCKS_PASSWORD=sspasswd</span>
<span class="pl-s"># vpn 帐号密码</span>
<span class="pl-s">USERS=vpn:vpn</span>
<span class="pl-s"># vpn 管理员密码</span>
<span class="pl-s">SPW=vpn123456</span>
<span class="pl-s"># vpn 预共享密钥</span>
<span class="pl-s">PSK=vpn</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

cat <span class="pl-k">&gt;</span> docker-compose.yml <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s">version: '2'</span>
<span class="pl-s"></span>
<span class="pl-s">services:</span>
<span class="pl-s"></span>
<span class="pl-s">  # 创建 shadowsocks 服务器 ( 提供 shadowsocks 协议的代理 )</span>
<span class="pl-s">  ss:</span>
<span class="pl-s">    image: easypi/shadowsocks-libev:3.2.3</span>
<span class="pl-s">    container_name: ss</span>
<span class="pl-s">    ports:</span>
<span class="pl-s">    - "9001:8388/tcp"</span>
<span class="pl-s">    - "9001:8388/udp"</span>
<span class="pl-s">    environment:</span>
<span class="pl-s">    - METHOD=aes-256-cfb</span>
<span class="pl-s">    - PASSWORD=\$SHADOWSOCKS_PASSWORD</span>
<span class="pl-s">    restart: always</span>
<span class="pl-s"></span>
<span class="pl-s">  # 创建 vpn</span>
<span class="pl-s">  vpn:</span>
<span class="pl-s">    image: siomiz/softethervpn</span>
<span class="pl-s">    container_name: vpn</span>
<span class="pl-s">    privileged: true</span>
<span class="pl-s">    ports:</span>
<span class="pl-s">    - "5555:5555"</span>
<span class="pl-s">    - "500:500/udp"</span>
<span class="pl-s">    - "4500:4500/udp"</span>
<span class="pl-s">    - "1701:1701"</span>
<span class="pl-s">    - "1194:1194/udp"</span>
<span class="pl-s">    environment:</span>
<span class="pl-s">    - USERS=\$USERS</span>
<span class="pl-s">    - SPW=\$SPW</span>
<span class="pl-s">    - PSK=\$PSK</span>
<span class="pl-s">    restart: always</span>
<span class="pl-s">    cap_add:</span>
<span class="pl-s">    - NET_ADMIN</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c"><span class="pl-c">#</span> 启动</span>
docker-compose up -d</pre></div>
<p>复制粘贴上面的命令即可一键完成配置，配置完成后会 <code>/root/proxy</code> 目录下生成配置文件 <code>.env </code> ，在里面配置各帐号密码，修改完配置记得执行 <code>cd /root/proxy &amp;&amp; docker-compose up -d</code> 重启服务。</p>
<h3>2019 - 09 - 24 更新</h3>
<hr>
<p>最近 <strong>搬瓦工 VPS</strong> 的 IP 老是被墙，还是要另谋出路 —— <a href="https://justmysocks1.net/members/cart.php" rel="nofollow">Just My Socks</a> 。<strong>Just My Socks</strong> 是搬瓦工官方出品的 <strong>SS</strong> 服务，开箱即用，基于域名访问，有效解决 IP 被封的问题，参考 <a href="https://blog.sprov.xyz/2019/03/18/just-my-socks/" rel="nofollow">购买教程</a> 。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/ee2b53e8f6d6">https://www.jianshu.com/p/ee2b53e8f6d6</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ant Design Pro 使用之 表单组件再封装]]></title>
            <link>https://anyesu.github.io/blog/articles/25</link>
            <guid>25</guid>
            <pubDate>Mon, 23 Sep 2019 16:04:03 GMT</pubDate>
            <description><![CDATA[背景 使用 Ant Design Pro 开发有一段时间了，表单作为后台系统常见的功能当然很有必要封装一下，减少代码重复量。虽说 antd 的表单组件已经很不错了，但是使用上还是太麻烦了 ( 我就是懒 ) ，所以我就基于一些小小的约定封装了它的上层业务组件，更方便调用： 常用表单场景主要分四类：搜索条件、详情页、弹出式窗口、其他混合型 表单布局主要分三类：水平排列、垂直排列、复杂混合型 弹窗类型分]]></description>
            <content:encoded><![CDATA[<h3>背景</h3>
<hr>
<p>使用 <a href="https://pro.ant.design/index-cn" rel="nofollow">Ant Design Pro</a> 开发有一段时间了，表单作为后台系统常见的功能当然很有必要封装一下，减少代码重复量。虽说 <a href="https://pro.ant.design/index-cn" rel="nofollow">antd</a> 的表单组件已经很不错了，但是使用上还是太麻烦了 ( 我就是懒 ) ，所以我就基于一些小小的约定封装了它的上层业务组件，更方便调用：</p>
<ul>
<li>
<p>常用表单场景主要分四类：搜索条件、详情页、弹出式窗口、其他混合型</p>
</li>
<li>
<p>表单布局主要分三类：水平排列、垂直排列、复杂混合型</p>
</li>
<li>
<p>弹窗类型分两类：模态对话框、屏幕边缘滑出的浮层面板 ( 抽屉 )</p>
</li>
<li>
<p>封装尽可能不引入新的语法，兼容 antd 原有配置方式</p>
</li>
<li>
<p>调用尽可能简单，减少重复关键字的使用。(  比如：<code>getFieldDecorator</code> )</p>
</li>
</ul>
<h3>基础表单组件</h3>
<hr>
<ul>
<li>
<p>组件定义</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span>, { <span class="pl-smi">Component</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">Form</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>antd<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PropTypes</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>prop-types<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">renderFormItem</span>, <span class="pl-smi">fillFormItems</span>, <span class="pl-smi">submitForm</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./extra<span class="pl-pds">'</span></span>;

<span class="pl-k">const</span> <span class="pl-smi">defaultFormLayout</span> <span class="pl-k">=</span> { <span class="pl-c1"><span class="pl-s">labelCol</span>:</span> { <span class="pl-c1"><span class="pl-s">span</span>:</span> <span class="pl-c1">5</span> }, <span class="pl-c1"><span class="pl-s">wrapperCol</span>:</span> { <span class="pl-c1"><span class="pl-s">span</span>:</span> <span class="pl-c1">15</span> } };

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 基础表单</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
@<span class="pl-ent">Form</span><span class="pl-k">.</span><span class="pl-en">create</span>({
  <span class="pl-c"><span class="pl-c">//</span> 表单项变化时调用</span>
  <span class="pl-s"><span class="pl-en">onValuesChange</span></span>({ <span class="pl-smi">onValuesChange</span>, <span class="pl-k">...</span><span class="pl-smi">restProps</span> }, <span class="pl-smi">changedValues</span>, <span class="pl-smi">allValues</span>) {
    <span class="pl-k">if</span> (<span class="pl-smi">onValuesChange</span>) <span class="pl-en">onValuesChange</span>(<span class="pl-smi">restProps</span>, <span class="pl-smi">changedValues</span>, <span class="pl-smi">allValues</span>);
  },
})
<span class="pl-k">class</span> <span class="pl-en">BaseForm</span> <span class="pl-k">extends</span> <span class="pl-smi">Component</span> {
  <span class="pl-k">static</span> <span class="pl-smi">propTypes</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">dataSource</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">array</span>,
    <span class="pl-c1"><span class="pl-s">formValues</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">renderItem</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c1"><span class="pl-s">onSubmit</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c"><span class="pl-c">//</span> eslint-disable-next-line react/no-unused-prop-types</span>
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
  };

  <span class="pl-k">static</span> <span class="pl-smi">defaultProps</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>horizontal<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-c1">false</span>,
    <span class="pl-c1"><span class="pl-s">dataSource</span>:</span> [],
    <span class="pl-c1"><span class="pl-s">formValues</span>:</span> {},
    <span class="pl-c1"><span class="pl-s">renderItem</span>:</span> <span class="pl-smi">renderFormItem</span>,
    <span class="pl-en"><span class="pl-s">onSubmit</span></span>: () <span class="pl-k">=&gt;</span> {},
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-c1">undefined</span>,
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 表单提交时触发</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param e</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">onSubmit</span> <span class="pl-k">=</span> <span class="pl-smi">e</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-k">if</span> (<span class="pl-smi">e</span>) <span class="pl-smi"><span class="pl-smi">e</span></span><span class="pl-k">.</span><span class="pl-en">preventDefault</span>(); <span class="pl-c"><span class="pl-c">//</span> 阻止默认行为</span>
    <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">submit</span>();
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 调用表单提交</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">submit</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">form</span>, <span class="pl-smi">formValues</span>, <span class="pl-smi">onSubmit</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-en">submitForm</span>(<span class="pl-smi">form</span>, <span class="pl-smi">formValues</span>, <span class="pl-smi">onSubmit</span>);
  };

  <span class="pl-en"><span class="pl-s">render</span></span>() {
    <span class="pl-k">const</span> {
      <span class="pl-smi">children</span>,
      <span class="pl-smi">layout</span>,
      <span class="pl-smi">formLayout</span> <span class="pl-k">=</span> <span class="pl-smi">layout</span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>vertical<span class="pl-pds">'</span></span> <span class="pl-k">?</span> <span class="pl-c1">null</span> : <span class="pl-smi">defaultFormLayout</span>,
      <span class="pl-smi">hideRequiredMark</span>,
      <span class="pl-smi">renderItem</span>,
      <span class="pl-c1"><span class="pl-s">form</span>:</span> { <span class="pl-smi">getFieldDecorator</span> },
      <span class="pl-smi">formValues</span>,
      <span class="pl-smi">dataSource</span>,
    } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">return</span> (
      &lt;<span class="pl-ent">Form</span> <span class="pl-e">layout</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">layout</span><span class="pl-pse">}</span> <span class="pl-e">onSubmit</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onSubmit</span><span class="pl-pse">}</span> <span class="pl-e">hideRequiredMark</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">hideRequiredMark</span><span class="pl-pse">}</span>&gt;
        <span class="pl-pse">{</span><span class="pl-smi">children</span> <span class="pl-k">||</span>
          <span class="pl-en">fillFormItems</span>(<span class="pl-smi">dataSource</span>, <span class="pl-smi">formValues</span>)<span class="pl-k">.</span><span class="pl-en">map</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span>
            <span class="pl-en">renderItem</span>(<span class="pl-smi">item</span>, <span class="pl-smi">getFieldDecorator</span>, <span class="pl-smi">formLayout</span>)
          )<span class="pl-pse">}</span>
      &lt;/<span class="pl-ent">Form</span>&gt;
    );
  }
}

<span class="pl-k">export</span> <span class="pl-k">*</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./extra<span class="pl-pds">'</span></span>;
<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-smi">BaseForm</span>;</pre></div>
</li>
<li>
<p>调用示例</p>
<div class="highlight highlight-source-js-jsx"><pre>&lt;<span class="pl-ent">BaseForm</span>
  <span class="pl-e">hideRequiredMark</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">false</span><span class="pl-pse">}</span>
  <span class="pl-e">layout</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>vertical<span class="pl-pds">"</span></span>
  <span class="pl-e">formLayout</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">null</span><span class="pl-pse">}</span>
  <span class="pl-e">dataSource</span><span class="pl-k">=</span><span class="pl-pse">{</span>[
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key3<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name3<span class="pl-pds">'</span></span> },
  ]<span class="pl-pse">}</span>
  <span class="pl-e">formValues</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">name2</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>default<span class="pl-pds">'</span></span> }<span class="pl-pse">}</span>
  <span class="pl-e">onSubmit</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> {}<span class="pl-pse">}</span>
  <span class="pl-e">onValuesChange</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> {}<span class="pl-pse">}</span>
  <span class="pl-e">wrappedComponentRef</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">form</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">form</span> <span class="pl-k">=</span> <span class="pl-smi">form</span>;
  }<span class="pl-pse">}</span>
/&gt;</pre></div>
</li>
</ul>
<p>比起 <strong>antd</strong> 表单组件的调用应该简洁不少吧</p>
<h3>弹出式表单组件</h3>
<hr>
<ul>
<li>
<p>组件定义</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span>, { <span class="pl-smi">PureComponent</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">ReactDOM</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react-dom<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PropTypes</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>prop-types<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">BaseComponent</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>../BaseComponent<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">BaseForm</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>../BaseForm<span class="pl-pds">'</span></span>;

<span class="pl-k">const</span> <span class="pl-smi">destroyFns</span> <span class="pl-k">=</span> []; <span class="pl-c"><span class="pl-c">//</span> 保存所有弹框的引用</span>

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 弹出式表单</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">class</span> <span class="pl-en">PopupForm</span> <span class="pl-k">extends</span> <span class="pl-smi">PureComponent</span> {
  <span class="pl-k">static</span> <span class="pl-smi">propTypes</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-en">oneOfType</span>([<span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>, <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">number</span>]),
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">onClose</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
  };

  <span class="pl-k">static</span> <span class="pl-smi">defaultProps</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>vertical<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-c1">null</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-c1">false</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-c1">720</span>,
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>确定<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>取消<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-c1">true</span>,
    <span class="pl-c1"><span class="pl-s">onClose</span>:</span> <span class="pl-c1">undefined</span>,
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 显示通过getInstance创建的组件</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param formValues 表单初始值</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">static</span> <span class="pl-en"><span class="pl-s">show</span></span>(<span class="pl-smi">formValues</span>) {
    <span class="pl-k">const</span> { <span class="pl-smi">instance</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span>;
    <span class="pl-k">if</span> (<span class="pl-smi">instance</span>) {
      <span class="pl-k">const</span> { <span class="pl-c1">root</span> } <span class="pl-k">=</span> <span class="pl-smi"><span class="pl-smi">instance</span></span><span class="pl-k">.</span><span class="pl-smi">props</span>;
      <span class="pl-k">if</span> (<span class="pl-c1">root</span> <span class="pl-k">instanceof</span> <span class="pl-smi">BaseComponent</span>) {
        <span class="pl-c1">root</span><span class="pl-k">.</span><span class="pl-en">showPopup</span>(<span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">name</span>, <span class="pl-c1">true</span>, <span class="pl-smi">formValues</span>);
      }
    }
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 创建一个该类型表单组件的实例，配合show显示/关闭</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param root  表单组件引用的父组件，用于统一管理表单组件的状态</span>
<span class="pl-c">   * @param props 组件属性</span>
<span class="pl-c">   * @returns {*}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">static</span> <span class="pl-en"><span class="pl-s">getInstance</span></span>(<span class="pl-smi">root</span>, <span class="pl-smi">props</span>) {
    <span class="pl-k">if</span> (<span class="pl-c1">root</span> <span class="pl-k">instanceof</span> <span class="pl-smi">BaseComponent</span>) {
      <span class="pl-k">const</span> { <span class="pl-smi">forms</span> <span class="pl-k">=</span> {} } <span class="pl-k">=</span> <span class="pl-c1">root</span><span class="pl-k">.</span><span class="pl-smi">state</span> <span class="pl-k">||</span> {};
      <span class="pl-k">const</span> <span class="pl-smi">form</span> <span class="pl-k">=</span> <span class="pl-smi"><span class="pl-smi">forms</span></span>[<span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">getFormName</span>()] <span class="pl-k">||</span> {};
      <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">instance</span> <span class="pl-k">=</span> &lt;<span class="pl-ent">this</span> <span class="pl-e">root</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">root</span><span class="pl-pse">}</span> <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">form</span><span class="pl-pse">}</span> <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">props</span><span class="pl-pse">}</span> /&gt;;
      <span class="pl-k">return</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">instance</span>;
    }
    <span class="pl-k">return</span> <span class="pl-c1">null</span>;
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 接口方式创建并显示一个表单组件，独立于App容器之外</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param props      组件属性</span>
<span class="pl-c">   * @param decorators 要给组件附加的高阶组件</span>
<span class="pl-c">   * @returns {*}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">static</span> <span class="pl-en"><span class="pl-s">open</span></span>(<span class="pl-smi">props</span>, <span class="pl-smi">decorators</span>) {
    <span class="pl-k">const</span> <span class="pl-smi">Com</span> <span class="pl-k">=</span> <span class="pl-smi">decorators</span> <span class="pl-k">?</span> []<span class="pl-k">.</span><span class="pl-en">concat</span>(<span class="pl-smi">decorators</span>)<span class="pl-k">.</span><span class="pl-en">reduce</span>((<span class="pl-smi">pre</span>, <span class="pl-smi">item</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">item</span>(<span class="pl-smi">pre</span>), <span class="pl-c1">this</span>) : <span class="pl-c1">this</span>;
    <span class="pl-k">const</span> <span class="pl-smi">div</span> <span class="pl-k">=</span> <span class="pl-c1">document</span><span class="pl-k">.</span><span class="pl-en">createElement</span>(<span class="pl-s"><span class="pl-pds">'</span>div<span class="pl-pds">'</span></span>);
    <span class="pl-k">const</span> <span class="pl-en">close</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
      <span class="pl-k">const</span> <span class="pl-smi">unmountResult</span> <span class="pl-k">=</span> <span class="pl-smi">ReactDOM</span><span class="pl-k">.</span><span class="pl-en">unmountComponentAtNode</span>(<span class="pl-smi">div</span>);
      <span class="pl-k">if</span> (<span class="pl-smi">unmountResult</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-smi"><span class="pl-smi">div</span></span><span class="pl-k">.</span><span class="pl-smi">parentNode</span>) {
        <span class="pl-smi"><span class="pl-smi">div</span></span><span class="pl-k">.</span><span class="pl-smi">parentNode</span><span class="pl-k">.</span><span class="pl-en">removeChild</span>(<span class="pl-smi">div</span>);
      }
      <span class="pl-k">const</span> <span class="pl-smi">pos</span> <span class="pl-k">=</span> <span class="pl-smi"><span class="pl-smi">destroyFns</span></span><span class="pl-k">.</span><span class="pl-en">findIndex</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">item</span> <span class="pl-k">===</span> <span class="pl-smi">close</span>);
      <span class="pl-k">if</span> (<span class="pl-smi">pos</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) <span class="pl-smi"><span class="pl-smi">destroyFns</span></span><span class="pl-k">.</span><span class="pl-en">splice</span>(<span class="pl-smi">pos</span>, <span class="pl-c1">1</span>);
    };
    <span class="pl-c"><span class="pl-c">//</span> 使用DvaContainer作为新的根组件，保证子组件正常使用redux</span>
    <span class="pl-k">const</span> <span class="pl-smi">rootContainer</span> <span class="pl-k">=</span> <span class="pl-c1">window</span><span class="pl-k">.</span><span class="pl-smi">g_plugins</span><span class="pl-k">.</span><span class="pl-en">apply</span>(<span class="pl-s"><span class="pl-pds">'</span>rootContainer<span class="pl-pds">'</span></span>, {
      <span class="pl-c1"><span class="pl-s">initialValue</span>:</span> &lt;<span class="pl-ent">Com</span> <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">props</span><span class="pl-pse">}</span> <span class="pl-e">visible</span> <span class="pl-e">onClose</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">close</span><span class="pl-pse">}</span> /&gt;,
    });
    <span class="pl-smi">ReactDOM</span><span class="pl-k">.</span><span class="pl-en">render</span>(<span class="pl-smi">rootContainer</span>, <span class="pl-smi">div</span>);

    <span class="pl-smi"><span class="pl-smi">destroyFns</span></span><span class="pl-k">.</span><span class="pl-en">push</span>(<span class="pl-smi">close</span>);

    <span class="pl-c"><span class="pl-c">//</span> 返回一个对象，通过这个对象来显式关闭组件</span>
    <span class="pl-k">return</span> { <span class="pl-smi">close</span> };
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 销毁全部弹框</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">static</span> <span class="pl-en"><span class="pl-s">destroyAll</span></span>() {
    <span class="pl-k">while</span> (<span class="pl-smi"><span class="pl-smi">destroyFns</span></span><span class="pl-k">.</span><span class="pl-smi">length</span>) {
      <span class="pl-k">const</span> <span class="pl-smi">close</span> <span class="pl-k">=</span> <span class="pl-smi"><span class="pl-smi">destroyFns</span></span><span class="pl-k">.</span><span class="pl-en">pop</span>();
      <span class="pl-k">if</span> (<span class="pl-smi">close</span>) <span class="pl-en">close</span>();
    }
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 获取表单名称，用于父组件对表单组件的控制，默认取组件类名</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {string}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">static</span> <span class="pl-en"><span class="pl-s">getFormName</span></span>() {
    <span class="pl-k">return</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">name</span>;
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 表单提交时触发</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param fieldsValue</span>
<span class="pl-c">   * @param form</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">onSubmit</span> <span class="pl-k">=</span> (<span class="pl-smi">fieldsValue</span>, <span class="pl-smi">form</span>) <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">onSubmit</span>, <span class="pl-smi">closeOnSubmit</span> <span class="pl-k">=</span> <span class="pl-c1">false</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">if</span> (<span class="pl-smi">closeOnSubmit</span> <span class="pl-k">===</span> <span class="pl-c1">true</span>) {
      <span class="pl-c"><span class="pl-c">//</span> 表单提交时关闭当前组件</span>
      <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">close</span>();
    }
    <span class="pl-en">onSubmit</span>(<span class="pl-smi">fieldsValue</span>, <span class="pl-smi">form</span>);
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 点击Ok按钮时触发</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param e</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">onOk</span> <span class="pl-k">=</span> <span class="pl-smi">e</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-k">if</span> (<span class="pl-smi">e</span>) <span class="pl-smi"><span class="pl-smi">e</span></span><span class="pl-k">.</span><span class="pl-en">preventDefault</span>(); <span class="pl-c"><span class="pl-c">//</span> 阻止默认行为</span>
    <span class="pl-k">const</span> { <span class="pl-c1"><span class="pl-s">form</span>:</span> { <span class="pl-smi">submit</span> } <span class="pl-k">=</span> {} } <span class="pl-k">=</span> <span class="pl-c1">this</span>;
    <span class="pl-k">if</span> (<span class="pl-smi">submit</span>) {
      <span class="pl-c"><span class="pl-c">//</span> 通过子组件暴露的方法，显式提交表单</span>
      <span class="pl-en">submit</span>();
    }
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 点击Cancel按钮时触发</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param e</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">onCancel</span> <span class="pl-k">=</span> <span class="pl-smi">e</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-k">if</span> (<span class="pl-smi">e</span>) <span class="pl-smi"><span class="pl-smi">e</span></span><span class="pl-k">.</span><span class="pl-en">preventDefault</span>(); <span class="pl-c"><span class="pl-c">//</span> 阻止默认行为</span>
    <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">close</span>();
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 关闭当前组件</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">close</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">onClose</span>, <span class="pl-c1">root</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">const</span> <span class="pl-smi">formName</span> <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-c1">constructor</span><span class="pl-k">.</span><span class="pl-en">getFormName</span>();
    <span class="pl-k">if</span> (<span class="pl-smi">onClose</span>) {
      <span class="pl-en">onClose</span>(<span class="pl-smi">formName</span>);
    } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-c1">root</span> <span class="pl-k">instanceof</span> <span class="pl-smi">BaseComponent</span>) {
      <span class="pl-c"><span class="pl-c">//</span> 对应getInstance创建的组件，由父组件控制</span>
      <span class="pl-c1">root</span><span class="pl-k">.</span><span class="pl-en">showPopup</span>(<span class="pl-smi">formName</span>, <span class="pl-c1">false</span>);
    }
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 绘制表单，可覆盖</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {*}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">renderForm</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> {
      <span class="pl-smi">children</span>,
      <span class="pl-smi">layout</span>,
      <span class="pl-smi">formLayout</span>,
      <span class="pl-smi">hideRequiredMark</span>,
      <span class="pl-smi">onValuesChange</span>,
      <span class="pl-smi">formValues</span>,
      <span class="pl-k">...</span><span class="pl-smi">restProps</span>
    } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;

    <span class="pl-k">return</span> (
      &lt;<span class="pl-ent">BaseForm</span>
        <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">restProps</span><span class="pl-pse">}</span>
        <span class="pl-e">hideRequiredMark</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">hideRequiredMark</span><span class="pl-pse">}</span>
        <span class="pl-e">layout</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">layout</span><span class="pl-pse">}</span>
        <span class="pl-e">formLayout</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">formLayout</span><span class="pl-pse">}</span>
        <span class="pl-e">dataSource</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">getDataSource</span>()<span class="pl-pse">}</span>
        <span class="pl-e">formValues</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">formValues</span><span class="pl-pse">}</span>
        <span class="pl-e">onSubmit</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onSubmit</span><span class="pl-pse">}</span>
        <span class="pl-e">onValuesChange</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">onValuesChange</span><span class="pl-pse">}</span>
        <span class="pl-e">wrappedComponentRef</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">form</span> <span class="pl-k">=&gt;</span> {
          <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">form</span> <span class="pl-k">=</span> <span class="pl-smi">form</span>;
        }<span class="pl-pse">}</span>
      /&gt;
    );
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 绘制组件主体内容，可覆盖</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {PopupForm.props.children | *}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">renderBody</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">children</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">return</span> <span class="pl-smi">children</span> <span class="pl-k">||</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">renderForm</span>();
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 表单字段数据源，可覆盖</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {undefined}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">getDataSource</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> <span class="pl-c1">undefined</span>;

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 组件显示标题，可覆盖</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {string}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">getTitle</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>;
}

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-smi">PopupForm</span>;</pre></div>
</li>
<li>
<p>这个是 <strong>基础组件</strong> ，不能直接使用，具体的弹框 <strong>表现形式</strong> 由 <strong>子类</strong> 实现，主要为 <strong>模态框</strong> 和 <strong>抽屉</strong></p>
</li>
<li>
<p>调用方式和常规组件不一样，采用继承的方式实现具体的业务组件，通过组件的静态方法实现渲染和行为控制  ( 当然，要使用 <strong>JSX</strong> 也是可以的 )</p>
</li>
<li>
<p>API</p>
<table role="table">
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>getInstance</code></strong></td>
<td>创建一个该类型表单组件的实例，配合 <code>show</code> 方法控制 显示 / 关闭</td>
</tr>
<tr>
<td><strong><code>show</code></strong></td>
<td>显示通过 <code>getInstance</code> 创建的组件弹框</td>
</tr>
<tr>
<td><strong><code>open</code></strong></td>
<td>接口方式创建并显示一个表单组件，独立于 <strong>App 容器</strong>之外。<br>返回一个对象，通过这个对象引用来显式关闭组件</td>
</tr>
<tr>
<td><strong><code>destroyAll</code></strong></td>
<td>销毁所有通过 <code>open</code> 方法创建的组件弹框</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3>模态框式表单组件</h3>
<hr>
<ul>
<li>
<p>组件定义</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">Modal</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>antd<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PropTypes</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>prop-types<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PopupForm</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>../PopupForm<span class="pl-pds">'</span></span>;

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 模态框式表单</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">class</span> <span class="pl-en">ModalForm</span> <span class="pl-k">extends</span> <span class="pl-smi">PopupForm</span> {
  <span class="pl-k">static</span> <span class="pl-smi">propTypes</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-en">oneOfType</span>([<span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>, <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">number</span>]),
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
  };

  <span class="pl-k">static</span> <span class="pl-smi">defaultProps</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>horizontal<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-c1">false</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-c1">640</span>,
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>确定<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>取消<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-c1">true</span>,
  };

  <span class="pl-en"><span class="pl-s">render</span></span>() {
    <span class="pl-k">const</span> { <span class="pl-smi">children</span>, <span class="pl-smi">title</span>, <span class="pl-smi">width</span>, <span class="pl-smi">visible</span>, <span class="pl-smi">okText</span>, <span class="pl-smi">cancelText</span>, <span class="pl-k">...</span><span class="pl-smi">restProps</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;

    <span class="pl-k">return</span> <span class="pl-smi">visible</span> <span class="pl-k">?</span> (
      &lt;<span class="pl-ent">Modal</span>
        <span class="pl-e">title</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">title</span> <span class="pl-k">||</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">getTitle</span>()<span class="pl-pse">}</span>
        <span class="pl-e">width</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">width</span><span class="pl-pse">}</span>
        <span class="pl-e">visible</span>
        <span class="pl-e">okText</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">okText</span><span class="pl-pse">}</span>
        <span class="pl-e">onOk</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onOk</span><span class="pl-pse">}</span>
        <span class="pl-e">cancelText</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">cancelText</span><span class="pl-pse">}</span>
        <span class="pl-e">onCancel</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onCancel</span><span class="pl-pse">}</span>
        <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">restProps</span><span class="pl-pse">}</span>
        <span class="pl-e">destroyOnClose</span>
      &gt;
        <span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">renderBody</span>()<span class="pl-pse">}</span>
      &lt;/<span class="pl-ent">Modal</span>&gt;
    ) : <span class="pl-c1">null</span>;
  }
}

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-smi">ModalForm</span>;</pre></div>
</li>
<li>
<p>调用示例</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">class</span> <span class="pl-en">Demo1</span> <span class="pl-k">extends</span> <span class="pl-smi">ModalForm</span> {
  <span class="pl-smi">getTitle</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>模态框式表单<span class="pl-pds">'</span></span>;

  <span class="pl-smi">getDataSource</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> [
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key3<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name3<span class="pl-pds">'</span></span> },
  ];
}

&lt;<span class="pl-ent">Button</span> <span class="pl-e">type</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>primary<span class="pl-pds">"</span></span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> <span class="pl-smi">Demo1</span><span class="pl-k">.</span><span class="pl-en">open</span>({ <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>覆盖表单标题<span class="pl-pds">'</span></span> })<span class="pl-pse">}</span>&gt;
  新增
&lt;/<span class="pl-ent">Button</span>&gt;</pre></div>
</li>
</ul>
<h3>抽屉式表单组件</h3>
<hr>
<ul>
<li>
<p>组件定义</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">Drawer</span>, <span class="pl-smi">Button</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>antd<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PropTypes</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>prop-types<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PopupForm</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>../PopupForm<span class="pl-pds">'</span></span>;

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 抽屉式表单</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
<span class="pl-k">class</span> <span class="pl-en">DrawerForm</span> <span class="pl-k">extends</span> <span class="pl-smi">PopupForm</span> {
  <span class="pl-k">static</span> <span class="pl-smi">propTypes</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-en">oneOfType</span>([<span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>, <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">number</span>]),
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
    <span class="pl-c1"><span class="pl-s">closable</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">bool</span>,
  };

  <span class="pl-k">static</span> <span class="pl-smi">defaultProps</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>vertical<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">formLayout</span>:</span> <span class="pl-c1">null</span>,
    <span class="pl-c1"><span class="pl-s">hideRequiredMark</span>:</span> <span class="pl-c1">false</span>,
    <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-c1">720</span>,
    <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">okText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>确定<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">cancelText</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>取消<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">onValuesChange</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">closeOnSubmit</span>:</span> <span class="pl-c1">false</span>,
    <span class="pl-c1"><span class="pl-s">closable</span>:</span> <span class="pl-c1">false</span>,
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 绘制组件按钮</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @returns {*}</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">renderFooter</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">okText</span>, <span class="pl-smi">cancelText</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">return</span> (
      &lt;<span class="pl-ent">div</span>
        <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{
          <span class="pl-c1"><span class="pl-s">position</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>absolute<span class="pl-pds">'</span></span>,
          <span class="pl-c1"><span class="pl-s">left</span>:</span> <span class="pl-c1">0</span>,
          <span class="pl-c1"><span class="pl-s">bottom</span>:</span> <span class="pl-c1">0</span>,
          <span class="pl-c1"><span class="pl-s">width</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>100%<span class="pl-pds">'</span></span>,
          <span class="pl-c1"><span class="pl-s">borderTop</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>1px solid #e9e9e9<span class="pl-pds">'</span></span>,
          <span class="pl-c1"><span class="pl-s">padding</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>10px 16px<span class="pl-pds">'</span></span>,
          <span class="pl-c1"><span class="pl-s">background</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>#fff<span class="pl-pds">'</span></span>,
          <span class="pl-c1"><span class="pl-s">textAlign</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>right<span class="pl-pds">'</span></span>,
        }<span class="pl-pse">}</span>
      &gt;
        <span class="pl-pse">{</span><span class="pl-smi">cancelText</span> <span class="pl-k">?</span> (
          &lt;<span class="pl-ent">Button</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onCancel</span><span class="pl-pse">}</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">marginRight</span>:</span> <span class="pl-c1">8</span> }<span class="pl-pse">}</span>&gt;
            <span class="pl-pse">{</span><span class="pl-smi">cancelText</span><span class="pl-pse">}</span>
          &lt;/<span class="pl-ent">Button</span>&gt;
        ) <span class="pl-k">:</span> <span class="pl-c1">null</span><span class="pl-pse">}</span>
        <span class="pl-pse">{</span><span class="pl-smi">okText</span> <span class="pl-k">?</span> (
          &lt;<span class="pl-ent">Button</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onOk</span><span class="pl-pse">}</span> <span class="pl-e">type</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>primary<span class="pl-pds">"</span></span>&gt;
            <span class="pl-pse">{</span><span class="pl-smi">okText</span><span class="pl-pse">}</span>
          &lt;/<span class="pl-ent">Button</span>&gt;
        ) <span class="pl-k">:</span> <span class="pl-c1">null</span><span class="pl-pse">}</span>
      &lt;/<span class="pl-ent">div</span>&gt;
    );
  };

  <span class="pl-en"><span class="pl-s">render</span></span>() {
    <span class="pl-k">const</span> { <span class="pl-smi">children</span>, <span class="pl-smi">title</span>, <span class="pl-smi">width</span>, <span class="pl-smi">visible</span>, <span class="pl-smi">closable</span>, <span class="pl-smi">formLayout</span>, <span class="pl-k">...</span><span class="pl-smi">restProps</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;

    <span class="pl-k">return</span> <span class="pl-smi">visible</span> <span class="pl-k">?</span> (
      &lt;<span class="pl-ent">Drawer</span>
        <span class="pl-e">title</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">title</span> <span class="pl-k">||</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">getTitle</span>()<span class="pl-pse">}</span>
        <span class="pl-e">width</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">width</span><span class="pl-pse">}</span>
        <span class="pl-e">visible</span>
        <span class="pl-e">closable</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">closable</span><span class="pl-pse">}</span>
        <span class="pl-e">onClose</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onCancel</span><span class="pl-pse">}</span>
        <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">restProps</span><span class="pl-pse">}</span>
        <span class="pl-e">destroyOnClose</span>
      &gt;
        &lt;<span class="pl-ent">div</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">paddingBottom</span>:</span> <span class="pl-c1">75</span> }<span class="pl-pse">}</span>&gt;<span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">renderBody</span>()<span class="pl-pse">}</span>&lt;/<span class="pl-ent">div</span>&gt;
        <span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">renderFooter</span>()<span class="pl-pse">}</span>
      &lt;/<span class="pl-ent">Drawer</span>&gt;
    ) : <span class="pl-c1">null</span>;
  }
}

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-smi">DrawerForm</span>;</pre></div>
</li>
<li>
<p>调用示例</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">class</span> <span class="pl-en">Demo1</span> <span class="pl-k">extends</span> <span class="pl-smi">DrawerForm</span> {
  <span class="pl-smi">getTitle</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">'</span>模态框式表单<span class="pl-pds">'</span></span>;

  <span class="pl-smi">getDataSource</span> <span class="pl-k">=</span> () <span class="pl-k">=&gt;</span> [
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name1<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">required</span>:</span> <span class="pl-c1">true</span> },
    { <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>key3<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>name3<span class="pl-pds">'</span></span> },
  ];
}

&lt;<span class="pl-ent">Button</span> <span class="pl-e">type</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>primary<span class="pl-pds">"</span></span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> <span class="pl-smi">Demo1</span><span class="pl-k">.</span><span class="pl-en">open</span>({ <span class="pl-c1"><span class="pl-s">title</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>覆盖表单标题<span class="pl-pds">'</span></span> })<span class="pl-pse">}</span>&gt;
  新增
&lt;/<span class="pl-ent">Button</span>&gt;</pre></div>
</li>
</ul>
<h3>搜索表单组件</h3>
<hr>
<ul>
<li>
<p>组件定义</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span>, { <span class="pl-smi">Component</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">Form</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>antd<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">PropTypes</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>prop-types<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">submitForm</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>../BaseForm<span class="pl-pds">'</span></span>;

<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c"> * 搜索表单</span>
<span class="pl-c"> <span class="pl-c">*/</span></span>
@<span class="pl-ent">Form</span><span class="pl-k">.</span><span class="pl-en">create</span>({
  <span class="pl-c"><span class="pl-c">//</span> 表单项变化时调用</span>
  <span class="pl-s"><span class="pl-en">onValuesChange</span></span>({ <span class="pl-smi">onValuesChange</span>, <span class="pl-k">...</span><span class="pl-smi">restProps</span> }, <span class="pl-smi">changedValues</span>, <span class="pl-smi">allValues</span>) {
    <span class="pl-k">if</span> (<span class="pl-smi">onValuesChange</span>) <span class="pl-en">onValuesChange</span>(<span class="pl-smi">restProps</span>, <span class="pl-smi">changedValues</span>, <span class="pl-smi">allValues</span>);
  },
})
<span class="pl-k">class</span> <span class="pl-en">SearchForm</span> <span class="pl-k">extends</span> <span class="pl-smi">Component</span> {
  <span class="pl-k">static</span> <span class="pl-smi">propTypes</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">object</span>,
    <span class="pl-c1"><span class="pl-s">onSearch</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">string</span>,
    <span class="pl-c1"><span class="pl-s">render</span>:</span> <span class="pl-smi">PropTypes</span><span class="pl-k">.</span><span class="pl-smi">func</span>,
  };

  <span class="pl-k">static</span> <span class="pl-smi">defaultProps</span> <span class="pl-k">=</span> {
    <span class="pl-c1"><span class="pl-s">root</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">onSearch</span>:</span> <span class="pl-c1">undefined</span>,
    <span class="pl-c1"><span class="pl-s">layout</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>inline<span class="pl-pds">'</span></span>,
    <span class="pl-c1"><span class="pl-s">render</span>:</span> <span class="pl-c1">undefined</span>,
  };

  <span class="pl-en"><span class="pl-s">constructor</span></span>(<span class="pl-smi">props</span>) {
    <span class="pl-c1">super</span>(<span class="pl-smi">props</span>);
    <span class="pl-k">const</span> { <span class="pl-c1">root</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">if</span> (<span class="pl-c1">root</span>) <span class="pl-c1">root</span><span class="pl-k">.</span><span class="pl-smi">searchForm</span> <span class="pl-k">=</span> <span class="pl-c1">this</span>;
  }

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 调用搜索</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param formValues</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">search</span> <span class="pl-k">=</span> <span class="pl-smi">formValues</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">onSearch</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">if</span> (<span class="pl-smi">onSearch</span>) <span class="pl-en">onSearch</span>(<span class="pl-smi">formValues</span>);
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 重置表单并搜索</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">reset</span> <span class="pl-k">=</span> (<span class="pl-smi">searchOnReset</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>) <span class="pl-k">=&gt;</span> {
    <span class="pl-k">const</span> { <span class="pl-smi">form</span>, <span class="pl-smi">formValues</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-smi"><span class="pl-smi">form</span></span><span class="pl-k">.</span><span class="pl-en">resetFields</span>();
    <span class="pl-k">if</span> (<span class="pl-smi">searchOnReset</span> <span class="pl-k">===</span> <span class="pl-c1">true</span>) <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-en">search</span>(<span class="pl-smi">formValues</span>);
  };

  <span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">   * 表单提交时触发</span>
<span class="pl-c">   *</span>
<span class="pl-c">   * @param e</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-smi">onSubmit</span> <span class="pl-k">=</span> <span class="pl-smi">e</span> <span class="pl-k">=&gt;</span> {
    <span class="pl-k">if</span> (<span class="pl-smi">e</span>) <span class="pl-smi"><span class="pl-smi">e</span></span><span class="pl-k">.</span><span class="pl-en">preventDefault</span>();
    <span class="pl-k">const</span> { <span class="pl-smi">form</span>, <span class="pl-smi">formValues</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-en">submitForm</span>(<span class="pl-smi">form</span>, <span class="pl-smi">formValues</span>, <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">search</span>);
  };

  <span class="pl-en"><span class="pl-s">render</span></span>() {
    <span class="pl-k">const</span> { <span class="pl-smi">render</span>, <span class="pl-smi">hideRequiredMark</span>, <span class="pl-smi">layout</span> } <span class="pl-k">=</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>;
    <span class="pl-k">return</span> (
      &lt;<span class="pl-ent">Form</span> <span class="pl-e">hideRequiredMark</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">hideRequiredMark</span><span class="pl-pse">}</span> <span class="pl-e">layout</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">layout</span><span class="pl-pse">}</span> <span class="pl-e">onSubmit</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">onSubmit</span><span class="pl-pse">}</span>&gt;
        <span class="pl-pse">{</span><span class="pl-smi">render</span> <span class="pl-k">?</span> <span class="pl-en">render</span>(<span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">props</span>) <span class="pl-k">:</span> <span class="pl-c1">null</span><span class="pl-pse">}</span>
      &lt;/<span class="pl-ent">Form</span>&gt;
    );
  }
}

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-smi">SearchForm</span>;</pre></div>
</li>
<li>
<p>调用示例</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">import</span> <span class="pl-smi">React</span>, { <span class="pl-smi">Component</span>, <span class="pl-smi">Fragment</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>react<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">Form</span>, <span class="pl-smi">Button</span>, <span class="pl-smi">Col</span>, <span class="pl-smi">Input</span>, <span class="pl-smi">Row</span>, <span class="pl-smi">message</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>antd<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">SearchForm</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>@/components/SearchForm<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> { <span class="pl-smi">renderFormItem</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>@/components/BaseForm<span class="pl-pds">'</span></span>;

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">class</span> <span class="pl-en">Demo</span> <span class="pl-k">extends</span> <span class="pl-smi">Component</span> {
  <span class="pl-smi">search</span> <span class="pl-k">=</span> <span class="pl-smi">data</span> <span class="pl-k">=&gt;</span> <span class="pl-smi"><span class="pl-smi">message</span></span><span class="pl-k">.</span><span class="pl-en">success</span>(<span class="pl-k">`</span><span class="pl-s">搜索提交:</span><span class="pl-k">${</span><span class="pl-c1">JSON</span><span class="pl-k">.</span><span class="pl-en">stringify</span>(<span class="pl-smi">data</span>)<span class="pl-k">}</span><span class="pl-k">`</span>);

  <span class="pl-smi">renderSearchForm</span> <span class="pl-k">=</span> ({ <span class="pl-smi">form</span><span class="pl-k">:</span> { <span class="pl-smi">getFieldDecorator</span> } }) <span class="pl-k">=&gt;</span> (
    &lt;<span class="pl-ent">Fragment</span>&gt;
      &lt;<span class="pl-ent">Row</span>&gt;
        &lt;<span class="pl-ent">Button</span> <span class="pl-e">icon</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>plus<span class="pl-pds">"</span></span> <span class="pl-e">type</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>primary<span class="pl-pds">"</span></span>&gt;
          新增
        &lt;/<span class="pl-ent">Button</span>&gt;
      &lt;/<span class="pl-ent">Row</span>&gt;
      &lt;<span class="pl-ent">Row</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">marginTop</span>:</span> <span class="pl-c1">16</span> }<span class="pl-pse">}</span>&gt;
        &lt;<span class="pl-ent">Col</span> <span class="pl-e">span</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">18</span><span class="pl-pse">}</span>&gt;
          &lt;<span class="pl-ent">Form.Item</span> <span class="pl-e">label</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>条件1<span class="pl-pds">"</span></span>&gt;
            <span class="pl-pse">{</span><span class="pl-en">getFieldDecorator</span>(<span class="pl-s"><span class="pl-pds">'</span>param1<span class="pl-pds">'</span></span>)(&lt;<span class="pl-ent">Input</span> <span class="pl-e">placeholder</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>请输入<span class="pl-pds">"</span></span> /&gt;)<span class="pl-pse">}</span>
          &lt;/<span class="pl-ent">Form.Item</span>&gt;
          <span class="pl-pse">{</span><span class="pl-en">renderFormItem</span>({ <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>条件2<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>param2<span class="pl-pds">'</span></span> }, <span class="pl-smi">getFieldDecorator</span>)<span class="pl-pse">}</span>
          <span class="pl-pse">{</span><span class="pl-en">renderFormItem</span>({ <span class="pl-c1"><span class="pl-s">label</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>条件3<span class="pl-pds">'</span></span>, <span class="pl-c1"><span class="pl-s">name</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>param3<span class="pl-pds">'</span></span> }, <span class="pl-smi">getFieldDecorator</span>)<span class="pl-pse">}</span>
        &lt;/<span class="pl-ent">Col</span>&gt;
        &lt;<span class="pl-ent">Col</span> <span class="pl-e">span</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">6</span><span class="pl-pse">}</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">textAlign</span>:</span> <span class="pl-s"><span class="pl-pds">'</span>right<span class="pl-pds">'</span></span> }<span class="pl-pse">}</span>&gt;
          &lt;<span class="pl-ent">span</span>&gt;
            &lt;<span class="pl-ent">Button</span> <span class="pl-e">type</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>primary<span class="pl-pds">"</span></span> <span class="pl-e">htmlType</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>submit<span class="pl-pds">"</span></span>&gt;
              查询
            &lt;/<span class="pl-ent">Button</span>&gt;
            &lt;<span class="pl-ent">Button</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">marginLeft</span>:</span> <span class="pl-c1">8</span> }<span class="pl-pse">}</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">searchForm</span><span class="pl-k">.</span><span class="pl-en">reset</span>()<span class="pl-pse">}</span>&gt;
              重置并提交
            &lt;/<span class="pl-ent">Button</span>&gt;
            &lt;<span class="pl-ent">Button</span> <span class="pl-e">style</span><span class="pl-k">=</span><span class="pl-pse">{</span>{ <span class="pl-c1"><span class="pl-s">marginLeft</span>:</span> <span class="pl-c1">8</span> }<span class="pl-pse">}</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span>() <span class="pl-k">=&gt;</span> <span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">searchForm</span><span class="pl-k">.</span><span class="pl-en">reset</span>(<span class="pl-c1">false</span>)<span class="pl-pse">}</span>&gt;
              只重置
            &lt;/<span class="pl-ent">Button</span>&gt;
          &lt;/<span class="pl-ent">span</span>&gt;
        &lt;/<span class="pl-ent">Col</span>&gt;
      &lt;/<span class="pl-ent">Row</span>&gt;
    &lt;/<span class="pl-ent">Fragment</span>&gt;
  );

  <span class="pl-en"><span class="pl-s">render</span></span>() {
    <span class="pl-k">return</span> (
      &lt;<span class="pl-ent">SearchForm</span>
        <span class="pl-e">root</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-pse">}</span>
        <span class="pl-e">onSearch</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">search</span><span class="pl-pse">}</span>
        <span class="pl-e">render</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">this</span><span class="pl-k">.</span><span class="pl-smi">renderSearchForm</span><span class="pl-pse">}</span>
        <span class="pl-e">searchOnReset</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">false</span><span class="pl-pse">}</span>
      /&gt;
    );
  }
}</pre></div>
</li>
</ul>
<h3>遇到的问题</h3>
<hr>
<p>在实际使用的过程中，弹框表单的子组件中可能会包含 <strong>被 connect 的组件</strong>，光使用 <strong>antd</strong> 的弹框组件包裹就会报错：</p>
<blockquote>
<p>Uncaught Error: Could not find "store" in either the context or props of "Connect(Demo)". Either wrap the root component in a , or explicitly pass "store" as a prop to "Connect(Demo)".</p>
</blockquote>
<p>解决办法就是使用 <strong>redux</strong> 的 <strong>Provider</strong> 组件包裹一下</p>
<div class="highlight highlight-source-js-jsx"><pre><span class="pl-smi">ReactDOM</span><span class="pl-k">.</span><span class="pl-en">render</span>(
  <span class="pl-c"><span class="pl-c">//</span> 使用 Provider 使子组件能从上下文中访问 store</span>
  <span class="pl-c"><span class="pl-c">//</span> 注意 react-redux 版本要和 dva 中引用的版本一致，否则子组件使用 @connect 会出错</span>
  <span class="pl-c"><span class="pl-c">//</span> eslint-disable-next-line no-underscore-dangle</span>
  &lt;<span class="pl-ent">Provider</span> <span class="pl-e">store</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-c1">window</span><span class="pl-k">.</span><span class="pl-smi">g_app</span><span class="pl-k">.</span><span class="pl-smi">_store</span><span class="pl-pse">}</span>&gt;
    &lt;<span class="pl-ent">Com</span> <span class="pl-pse">{</span><span class="pl-k">...</span><span class="pl-smi">props</span><span class="pl-pse">}</span> <span class="pl-e">visible</span> <span class="pl-e">onClose</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-smi">close</span><span class="pl-pse">}</span> /&gt;
  &lt;/<span class="pl-ent">Provider</span>&gt;,
  <span class="pl-smi">div</span>
);</pre></div>
<p>具体调用位置在上面 <code>PopupForm.open</code> 中，该代码已经按 <strong>dva</strong> 提供的方式进行解决了。</p>
<h3>最后</h3>
<hr>
<p>完整代码已经传到 <a href="https://codesandbox.io/" rel="nofollow">CodeSandbox</a> ，点击查看 <a href="https://codesandbox.io/s/4wmon20n94" rel="nofollow">antd 版</a> 或者 <a href="https://codesandbox.io/s/9zoxv04wzo" rel="nofollow">antd pro 版</a></p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/c7120bf2e4f8">https://www.jianshu.com/p/c7120bf2e4f8</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ant Design Pro 使用之 CodeSandbox 模版]]></title>
            <link>https://anyesu.github.io/blog/articles/24</link>
            <guid>24</guid>
            <pubDate>Mon, 23 Sep 2019 15:45:27 GMT</pubDate>
            <description><![CDATA[正文 最近在用 Ant Design Pro 做前端框架，试用的时候乍一看各种组件布局挺齐全的，有种站在巨人肩膀上的感觉。不过，开始开发之后就有点懵了，因为太丰富了反而思路受到限制，改起来有点无从下手 ( 比如 权限和菜单 这块内容耦合就挺严重的 ) ，各种代码混在一起对于初入者来说完全分不清哪些是有用的哪些是没用的。所以，经过一番研究决定还是应该换个使用姿势： 单独新建项目从头搭建，而不是在 a]]></description>
            <content:encoded><![CDATA[<h3>正文</h3>
<hr>
<p>最近在用 <a href="https://pro.ant.design/index-cn" rel="nofollow">Ant Design Pro</a> 做前端框架，试用的时候乍一看各种组件布局挺齐全的，有种站在巨人肩膀上的感觉。不过，开始开发之后就有点懵了，因为太丰富了反而思路受到限制，改起来有点无从下手 ( 比如 <strong>权限和菜单</strong> 这块内容耦合就挺严重的 ) ，各种代码混在一起对于初入者来说完全分不清哪些是有用的哪些是没用的。所以，经过一番研究决定还是应该换个使用姿势：</p>
<ul>
<li>
<p><del>单独新建项目从头搭建，而不是在 <a href="https://github.com/ant-design/ant-design-pro/">antd pro</a> 原有代码的基础上开发。</del></p>
<p>目前的 pro@v4 已经基本上只剩一个框架了，按官方步骤创建即可。</p>
</li>
<li>
<p><strong>antd pro</strong> 和 <a href="https://pro.ant.design/index-cn" rel="nofollow">antd</a> 一样以 <a href="https://www.npmjs.com/package/ant-design-pro" rel="nofollow">组件包</a> 的形式引入 ( <a href="https://www.yuque.com/ant-design/ant-design-pro/lmgc46" rel="nofollow">参考</a> ) ，直接使用其中的业务组件，也方便后续的升级。另外也可以借鉴其现有的 <a href="https://preview.pro.ant.design" rel="nofollow">布局效果</a> ，就不必花太多的精力在过细的样式调整上了。</p>
</li>
<li>
<p>按照 <a href="https://github.com/ant-design/ant-design-pro/issues/3143" data-hovercard-type="issue" data-hovercard-url="/ant-design/ant-design-pro/issues/3143/hovercard">V4 版本</a> 中提出的区块 ( <a href="https://alibaba.github.io/ice/docs/materials/intro-material" rel="nofollow">物料</a> ) 思想，按模块划分页面 ( 每个页面独立开发调试 ) ，结构更加清晰，减小耦合，也方便已有页面的复用和扩展，开发新项目的时候就可以快速剔除无关内容。</p>
</li>
</ul>
<p>按照上面的思路我对原项目做了一个精简，整理出一个新项目的模版，效果可以看 <a href="https://pk76nllkn7.sse.codesandbox.io/" rel="nofollow">这里</a> ，使用 <a href="https://codesandbox.io/s/node" rel="nofollow">node</a> 作为基础模版，这样 <a href="https://codesandbox.io/" rel="nofollow">CodeSandbox</a> 会在后台建立容器来跑代码，就可以和本地开发有一样的体验了。 <strong>CodeSandbox</strong> 上原先也没有 <strong>antd pro</strong> 的模版，现在小伙伴们可以基于这个模版来复现问题了。</p>
<ul>
<li>
<p><strong>模版地址：</strong><a href="https://codesandbox.io/s/pk76nllkn7" rel="nofollow">https://codesandbox.io/s/pk76nllkn7</a></p>
<p><strong>考虑到编译构建和网络因素，初次加载会比较慢，请耐心等待</strong></p>
</li>
</ul>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/ed9fee06a8f3">https://www.jianshu.com/p/ed9fee06a8f3</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 VPN 打通内网]]></title>
            <link>https://anyesu.github.io/blog/articles/22</link>
            <guid>22</guid>
            <pubDate>Sun, 22 Sep 2019 16:10:42 GMT</pubDate>
            <description><![CDATA[前言 在 上一篇文章 中已经介绍了使用 SSH 隧道 的方式来打通内网环境，好处是极小依赖 ( 只要支持 ssh 即可 ) ，不过使用下来也有几点问题比较明显： 无密码，安全性很差，IP 变动或者换地方了设置防火墙白名单也比较麻烦 浏览器可以通过设置全局的 HTTP 代理来访问，但在其他软件中就需要单独配置比较麻烦，比如我的 SSH 终端工具 要连接几十台服务器，每台服务器的配置都要单独修改想想就]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="https://www.jianshu.com/p/388a93b1e7f7" rel="nofollow">上一篇文章</a> 中已经介绍了使用 <strong>SSH 隧道</strong> 的方式来打通内网环境，好处是极小依赖 ( 只要支持 <strong>ssh</strong> 即可 ) ，不过使用下来也有几点问题比较明显：</p>
<ul>
<li>
<p>无密码，安全性很差，IP 变动或者换地方了设置防火墙白名单也比较麻烦</p>
</li>
<li>
<p>浏览器可以通过设置全局的 HTTP 代理来访问，但在其他软件中就需要单独配置比较麻烦，比如我的 <strong>SSH 终端工具</strong> 要连接几十台服务器，每台服务器的配置都要单独修改想想就头大</p>
</li>
<li>
<p>只支持 <strong>TCP</strong> 及在它之上的协议，不支持 <strong>UDP</strong></p>
</li>
</ul>
<p>使用 <strong>VPN</strong> 就可以很好的解决上面的几个问题</p>
<h3>方案</h3>
<hr>
<ol>
<li>
<p>在 <strong>内网</strong> 搭建 <strong>VPN 服务器</strong></p>
</li>
<li>
<p>将 <strong>VPN 服务</strong> 暴露到 <strong>公网</strong> 中</p>
</li>
<li>
<p>通过 <strong>公网</strong> 连接到 <strong>VPN 网络</strong>，通过 <strong>VPN 网络</strong> 访问 <strong>内网</strong> 资源</p>
</li>
</ol>
<h3>搭建 VPN 服务器</h3>
<hr>
<ul>
<li>
<p>在当前目录下新建 <strong>VPN 配置文件</strong> <code>vpn.env</code> 用于管理 <strong>VPN</strong> 的帐号密码</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 预共享密钥</span>
VPN_IPSEC_PSK=<span class="pl-s"><span class="pl-pds">'</span>vpn<span class="pl-pds">'</span></span>
<span class="pl-c"><span class="pl-c">#</span> 帐号</span>
VPN_USER=<span class="pl-s"><span class="pl-pds">'</span>vpn<span class="pl-pds">'</span></span>
<span class="pl-c"><span class="pl-c">#</span> 密码</span>
VPN_PASSWORD=<span class="pl-s"><span class="pl-pds">'</span>vpn<span class="pl-pds">'</span></span></pre></div>
</li>
<li>
<p>为了方便，采用 <strong>docker</strong> 的方式来搭建</p>
<div class="highlight highlight-source-shell"><pre>docker run --name vpn \
-d --privileged --restart=always \
--env-file <span class="pl-s"><span class="pl-pds">`</span>pwd<span class="pl-pds">`</span></span>/vpn.env \
-p 500:500/udp -p 4500:4500/udp \
-v /lib/modules:/lib/modules:ro hwdsl2/ipsec-vpn-server</pre></div>
</li>
</ul>
<p>先测试下：内网下是否能够连接上 <strong>VPN</strong> ( 选择 <strong>使用预共享密钥的 L2TP/IPsec</strong> )</p>
<h3>暴露 VPN 服务到公网</h3>
<hr>
<p>由于 <strong>VPN 服务器</strong> 搭建在内网环境，外部无法直接访问，所以按 <a href="https://www.jianshu.com/p/388a93b1e7f7" rel="nofollow">上一篇文章</a> 中的方式借助一台公网的服务器做 <strong>跳板机</strong> ，将 <strong>VPN 服务</strong> 的端口暴露在公网中。这里就遇到一个问题：<strong>VPN 服务</strong> 的端口是 <strong>UDP 协议</strong> 的，而 <strong>SSH 隧道</strong> 是不支持 <strong>UDP</strong> 的，有点小尴尬啊。不过好在可以通过 <strong>TCP / UDP</strong> 互相转换的方式来 "<strong>曲线救国</strong>" ，具体原理另外开文讲解 ( TODO ) ，这里就只给最终的操作：</p>
<ul>
<li>
<p>在 <strong>VPN 主机</strong> 上执行</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 将本机 1337 端口 ( TCP ) 接收到的数据转发到本机的 500 端口 ( UDP )</span>
docker run --name vpn500 -p 1337:80 \
-d --restart=always \
alpine/socat tcp-listen:80,fork,reuseaddr udp-connect:172.17.0.1:500

<span class="pl-c"><span class="pl-c">#</span> 将本机 1338 端口 ( TCP ) 接收到的数据转发到本机的 4500 端口 ( UDP )</span>
docker run --name vpn4500 -p 1338:80 \
-d --restart=always \
alpine/socat tcp-listen:80,fork,reuseaddr udp-connect:172.17.0.1:4500

<span class="pl-c"><span class="pl-c">#</span> 将本机 1337 端口通过 ssh 隧道暴露到跳板机的 1337 端口上，123.123.123.123 改为跳板机的公网 ip</span>
ssh -p 22 -Nf -R 0.0.0.0:1337:127.0.0.1:1337 root@123.123.123.123

<span class="pl-c"><span class="pl-c">#</span> 将本机 1338 端口通过 ssh 隧道暴露到跳板机的 1338 端口上</span>
ssh -p 22 -Nf -R 0.0.0.0:1338:127.0.0.1:1338 root@123.123.123.123</pre></div>
</li>
<li>
<p>在 <strong>跳板机</strong> 上执行</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 将本机 500 端口 ( UDP ) 接收到的数据转发到本机的 1337 端口 ( TCP )</span>
docker run --name vpn500 -p 500:80/udp \
-d --restart=always \
alpine/socat udp-listen:80,fork,reuseaddr tcp-connect:172.17.0.1:1337

<span class="pl-c"><span class="pl-c">#</span> 将本机 4500 端口 ( UDP ) 接收到的数据转发到本机的 1338 端口 ( TCP )</span>
docker run --name vpn4500 -p 4500:80/udp \
-d --restart=always \
alpine/socat udp-listen:80,fork,reuseaddr tcp-connect:172.17.0.1:1338</pre></div>
</li>
</ul>
<p>测试下：通过 <strong>跳板机</strong> 的公网 IP 是否能够连接上 <strong>VPN</strong> ( 选择 <strong>使用预共享密钥的 L2TP/IPsec</strong> )</p>
<h3>优化</h3>
<hr>
<p>通过上面的步骤已经初步实现了本文的目的，但是由于使用了蛋疼的 <strong>TCP / UDP</strong> 转换的方式，性能非常差劲，网速最快也只有 <strong>20 kb/s</strong> 左右，远程连个服务器什么的还好说，开网页就算了吧。其实，除了这种蹩脚的转换方式，还可以用 <strong>frp ( <a href="https://github.com/fatedier/frp/blob/master/README_zh.md">v0.24.1</a> )</strong> 做内网穿透：</p>
<ul>
<li>
<p>在 <strong>VPN 主机</strong> 上执行</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 写入 frp 客户端配置</span>
cat <span class="pl-k">&gt;</span> frpc.ini <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s">[common]</span>
<span class="pl-s">server_addr = &lt;跳板机 ip&gt;</span>
<span class="pl-s">server_port = 7000</span>
<span class="pl-s"># 与服务端的 token 一致才能认证通过</span>
<span class="pl-s">token = 123456</span>
<span class="pl-s"></span>
<span class="pl-s">[range:vpn]</span>
<span class="pl-s">type = udp</span>
<span class="pl-s">local_ip = 172.17.0.1</span>
<span class="pl-s">local_port = 500,4500</span>
<span class="pl-s">remote_port = 500,4500</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

docker run --name frpc \
-d --restart=always \
-v <span class="pl-s"><span class="pl-pds">`</span>pwd<span class="pl-pds">`</span></span>/frpc.ini:/etc/frpc.ini \
leonismoe/frpc</pre></div>
</li>
<li>
<p>在 <strong>跳板机</strong> 上执行</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 写入 frp 服务端配置</span>
cat <span class="pl-k">&gt;</span> frps.ini <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s">[common]</span>
<span class="pl-s">server_port = 7000</span>
<span class="pl-s">token = 123456</span>
<span class="pl-s"></span>
<span class="pl-s">dashboard_port = 7500</span>
<span class="pl-s"># dashboard 用户名密码，默认都为 admin</span>
<span class="pl-s">dashboard_user = admin</span>
<span class="pl-s">dashboard_pwd = admin</span>
<span class="pl-s"><span class="pl-k">EOF</span></span>

<span class="pl-c"><span class="pl-c">#</span> 7000 是 frp 的服务端口</span>
<span class="pl-c"><span class="pl-c">#</span> 400/4500 是 VPN 的端口</span>
<span class="pl-c"><span class="pl-c">#</span> 7500 是 frp 的 web 管理界面端口, 可有可无</span>
docker run --name frps \
-d --restart=always \
-p 7000:7000 -p 7500:7500 -p 500:500/udp -p 4500:4500/udp \
-v <span class="pl-s"><span class="pl-pds">`</span>pwd<span class="pl-pds">`</span></span>/frps.ini:/etc/frps.ini \
leonismoe/frps</pre></div>
</li>
</ul>
<p>连接 <strong>VPN</strong> 后，速度上有了明显的提升但还是很慢，不过上传能跑满跳板机的带宽，具体原因还有待研究。</p>
<p>另外，<strong>frp</strong> 还支持 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F">点对点内网穿透</a> ，有空也可以试下。</p>
<h3>使用 SoftEther VPN</h3>
<hr>
<p>出现上面的问题，主要还是因为搭建 <strong>SSH 隧道</strong> 时带来的 "<strong>惯性思维</strong>" ，为什么非得远程转发 <strong>UDP</strong> 端口呢？搜寻了一圈就发现了非常强大的 <a href="https://www.softether.org" rel="nofollow">SoftEther VPN</a> ，它就提供 <strong>TCP</strong> 协议的连接方式，远程转发它的 <strong>TCP</strong> 端口就行了。</p>
<ol>
<li>
<p>在 <strong>VPN 主机</strong> 上先关闭之前搭建的 <strong>VPN 服务</strong></p>
<div class="highlight highlight-source-shell"><pre>docker rm -f vpn</pre></div>
</li>
<li>
<p>在 <strong>VPN 主机</strong> 上搭建  <strong>SoftEther</strong></p>
<div class="highlight highlight-source-shell"><pre>docker run --name=vpn2 \
-d --privileged --restart=always --cap-add NET_ADMIN \
-p 500:500/udp -p 4500:4500/udp -p 1701:1701/tcp \
-p 1194:1194/udp \
-p 5555:5555/tcp \
-e USERS=vpn:vpn -e SPW=vpn123456 -e PSK=vpn \
siomiz/softethervpn
<span class="pl-c"><span class="pl-c">#</span> USERS 格式：username:password;user2:pass2;user3:pass3</span>
<span class="pl-c"><span class="pl-c">#</span> PSK 是预共享密钥，SPW 是管理密钥 ( 用于登录 SoftEther Server 管理器 )</span>

<span class="pl-c"><span class="pl-c">#</span> 将 VPN 主机的服务端口暴露到跳板机上</span>
ssh -p 22 -Nf -R 0.0.0.0:5555:127.0.0.1:5555 root@123.123.123.123</pre></div>
</li>
<li>
<p>下载 <a href="https://www.softether-download.com/cn.aspx?product=softether" rel="nofollow">SoftEther 的客户端</a> ，通过 <strong>客户端</strong> 连接 <strong>VPN</strong> 即可，此时的网速取决于 <strong>跳板机</strong> 的 <strong>公网带宽</strong></p>
</li>
</ol>
<p>当然，也可以配合上面的 <strong>内网穿透</strong> 步骤使用系统自带的 <strong>VPN 客户端</strong> 直连。</p>
<p><strong>所以，最终方案就是：SoftEther VPN + frp NAT</strong></p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/4801adfcd07e">https://www.jianshu.com/p/4801adfcd07e</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Tomcat 、Jetty 和 Undertow 对比测试]]></title>
            <link>https://anyesu.github.io/blog/articles/21</link>
            <guid>21</guid>
            <pubDate>Sat, 21 Sep 2019 17:06:22 GMT</pubDate>
            <description><![CDATA[背景 最近在做压测 , 同事觉得 Tomcat 不行想要切换 web 服务器 , 于是我就去网上搜了一些测评结果 , 不出意外 Tomcat 得到了一致的差评。抱着怀疑的态度 , 我决定对 SpringBoot 内嵌支持的三款 Servlet 容器 ( Tomcat 、Jetty 和 Undertow ) 做一个简单的对比测试 , 测试结果仅供参考 。 测试环境 项目 描述 测试端主机 阿里云EC]]></description>
            <content:encoded><![CDATA[<h3>背景</h3>
<hr>
<p>最近在做压测 , 同事觉得 <strong>Tomcat</strong> 不行想要切换 <strong>web</strong> 服务器 , 于是我就去网上搜了一些测评结果 , 不出意外 <strong>Tomcat</strong> 得到了一致的差评。抱着怀疑的态度 , 我决定对 <strong>SpringBoot</strong> 内嵌支持的三款 <strong>Servlet 容器</strong> ( <a href="http://tomcat.apache.org/" rel="nofollow">Tomcat</a> 、<a href="http://www.eclipse.org/jetty/" rel="nofollow">Jetty</a> 和 <a href="http://undertow.io/" rel="nofollow">Undertow</a> ) 做一个简单的对比测试 , <strong>测试结果仅供参考</strong> 。</p>
<h3>测试环境</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>项目</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>测试端主机</td>
<td>阿里云ECS(ecs.sn1ne.2xlarge) 8C16G CentOS7.4.1708 <code>Linux Kernel 3.10.0</code></td>
</tr>
<tr>
<td>被测端主机</td>
<td>阿里云ECS(ecs.sn1ne.2xlarge) 8C16G CentOS7.4.1708 <code>Linux Kernel 3.10.0</code></td>
</tr>
<tr>
<td>网络环境</td>
<td>阿里云专有网络 内网带宽: <strong>2 Gbps</strong></td>
</tr>
<tr>
<td>测试工具</td>
<td><strong>wrk</strong></td>
</tr>
<tr>
<td>项目框架</td>
<td><code>SpringBoot 1.5.10.RELEASE</code></td>
</tr>
<tr>
<td>JDK</td>
<td><code>1.8.0_191</code> <code>Java HotSpot(TM) 64-Bit Server VM</code></td>
</tr>
<tr>
<td>测试容器</td>
<td><code>Tomcat</code> <code>Jetty</code> <code>Undertow</code></td>
</tr>
</tbody>
</table>
<h4>说明：</h4>
<ul>
<li>
<p>测试端和被测端分别在两台主机上 , 为了避免放在一台主机上导致互相抢占 <strong>CPU</strong> 而无法得到真实结果。</p>
</li>
<li>
<p>主角是 <strong>Servlet容器</strong> , 所以网络环境不应该是这次测试的瓶颈 ( 系统内核的 <strong>TCP</strong> 参数也要优化 ) 。</p>
</li>
<li>
<p>测试工具用过 <a href="https://github.com/wg/wrk">wrk</a> 、<a href="http://httpd.apache.org/docs/2.4/programs/ab.html" rel="nofollow">ab</a> 、<a href="http://jmeter.apache.org/" rel="nofollow">jmeter</a> , 测试的目的是为了获取被测端的性能 , 但不能因为测试工具的性能瓶颈而埋没了被测端的真实能力 , 因此选用简单高效的 <strong>wrk</strong> ( 下载源码编译安装 ) 。</p>
</li>
</ul>
<h3>测试方法</h3>
<hr>
<p>使用最简单的 <strong>HTTP</strong> 接口 , 不包含任何业务逻辑和数据库操作 , 反映容器的极致性能</p>
<ul>
<li>项目地址：<a href="https://github.com/anyesu/test/tree/master/servlet-test">https://github.com/anyesu/test/tree/master/servlet-test</a></li>
</ul>
<div class="highlight highlight-source-java"><pre><span class="pl-k">@RestController</span>
<span class="pl-k">@RequestMapping</span>(<span class="pl-s"><span class="pl-pds">"</span>/api<span class="pl-pds">"</span></span>)
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestController</span> {

    <span class="pl-k">@RequestMapping</span>(<span class="pl-s"><span class="pl-pds">"</span>/test<span class="pl-pds">"</span></span>)
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">test</span>() {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>This is a test result.<span class="pl-pds">"</span></span>;
    }

}</pre></div>
<p>使用 <strong>wrk</strong> 5000 并发下持续压测 10 分钟 ( 超时时间设为 30s , 避免超时时间过短带来的大量错误 )</p>
<pre><code>./wrk -t 8 -c 5000 -d 10m -T 30s "http://yourhostip:3000/api/test"
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li>
<p><strong>JVM</strong> 内存设置为 <strong>2G</strong> 大小</p>
</li>
<li>
<p>项目启动后需要预热 ( <strong>JIT</strong> 编译、加线程等等 ) 一下才能达到最优的性能。</p>
</li>
<li>
<p>为了避免性能数据波动造成的影响 , 每种情况测试 <strong>3</strong> 遍后取最优结果。</p>
</li>
<li>
<p>按理说测试时间越长越能反映真实情况，不过试了 <strong>30</strong> 分钟的测试 , 一趟测试下来耗费了一天时间 , 结果和 <strong>10</strong> 分钟的也差不了多少 , 所以还是节省点时间吧。</p>
</li>
</ul>
<h3>测试结果</h3>
<hr>
<h4>Tomcat 8.0.53 NIO 模式</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -jar servlet-test-tomcat-8-nio.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 161.3% ( 最大 800% )
Server 的 CPU 使用率: 52.4 us, 13.0 sy,  0.0 ni, 16.8 id,  0.0 wa,  0.0 hi, 17.8 si,  0.0 st
Server GC 情况：YGC: 870 YGCT: 5.3 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    86.31ms    7.23ms 778.24ms   88.50%
    Req/Sec     7.25k   420.33    14.55k    72.93%
  34639518 requests in 10.00m, 5.33GB read
  Socket errors: connect 0, read 1253, write 2928, timeout 0
Requests/sec:  57726.28
Transfer/sec:      9.09MB
</code></pre>
</li>
</ul>
<h4>Tomcat 8.5.34 NIO 模式</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -jar servlet-test-tomcat-8.5-nio.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 132.3% ( 最大 800% )
Server 的 CPU 使用率: 60.2 us, 14.1 sy,  0.0 ni, 19.1 id,  0.0 wa,  0.0 hi,  6.5 si,  0.0 st
Server GC 情况：YGC: 940 YGCT: 5.736 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    83.43ms    9.79ms   1.70s    96.22%
    Req/Sec     7.51k   408.60    14.48k    73.85%
  35852565 requests in 10.00m, 4.55GB read
  Socket errors: connect 0, read 1165, write 2883, timeout 0
Requests/sec:  59745.50
Transfer/sec:      7.76MB
</code></pre>
</li>
</ul>
<h4>Tomcat 8.0.53 APR 模式 ( <a href="https://www.cnblogs.com/xing901022/p/9145914.html" rel="nofollow">服务器上需要安装 apr 类库</a> )</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -Djava.library.path=/usr/local/apr/lib -jar servlet-test-tomcat-8-apr.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 183.4% ( 最大 800% )
Server 的 CPU 使用率: 69.5 us, 13.7 sy,  0.0 ni,  3.7 id,  0.0 wa,  0.0 hi, 13.1 si,  0.0 st
Server GC 情况：YGC: 1224 YGCT: 6.251 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    61.71ms   71.59ms   7.29s    99.87%
    Req/Sec    10.36k   441.68    18.63k    78.23%
  49480257 requests in 10.00m, 7.61GB read
  Socket errors: connect 0, read 1388, write 814, timeout 0
Requests/sec:  82453.62
Transfer/sec:     12.99MB
</code></pre>
</li>
</ul>
<h4>Jetty 9.4.8.v20171121</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -jar servlet-test-jetty.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 11.3% ( 最大 800% )
Server 的 CPU 使用率: 98.6 us,  0.5 sy,  0.0 ni,  0.5 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st
Server GC 情况：YGC: 640 YGCT: 6.541 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   126.01ms  435.50ms  29.95s    90.64%
    Req/Sec   206.88    127.12     1.03k    70.75%
  978373 requests in 10.00m, 128.76MB read
  Socket errors: connect 0, read 95571, write 7191, timeout 331
Requests/sec:   1630.39
Transfer/sec:    219.72KB
</code></pre>
</li>
</ul>
<h4>Undertow 1.4.22.Final</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -jar servlet-test-undertow.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 32.6% ( 最大 800% )
Server 的 CPU 使用率: 93.6 us,  2.4 sy,  0.0 ni,  1.5 id,  0.0 wa,  0.0 hi,  2.5 si,  0.0 st
Server GC 情况：YGC: 370 YGCT: 1.684 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   354.95ms  138.95ms   1.93s    75.08%
    Req/Sec     1.77k   199.04     4.19k    72.85%
  8471058 requests in 10.00m, 1.28GB read
  Socket errors: connect 0, read 1601, write 2882, timeout 0
Requests/sec:  14117.10
Transfer/sec:      2.18MB
</code></pre>
</li>
</ul>
<h4>Undertow 1.4.22.Final 配置线程数</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -Dserver.undertow.io-threads=16 -Dserver.undertow.worker-threads=256 -jar servlet-test-undertow.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 33.3% ( 最大 800% )
Server 的 CPU 使用率: 92.1 us,  2.4 sy,  0.0 ni,  2.3 id,  0.0 wa,  0.0 hi,  3.2 si,  0.0 st
Server GC 情况：YGC: 367 YGCT: 2.23 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   391.49ms  333.83ms   3.23s    60.47%
    Req/Sec     1.76k   235.55     4.51k    69.41%
  8389131 requests in 10.00m, 1.27GB read
  Socket errors: connect 0, read 3987, write 3486, timeout 0
Requests/sec:  13980.36
Transfer/sec:      2.16MB
</code></pre>
</li>
</ul>
<h4>Undertow 2.0.15.Final</h4>
<ul>
<li>
<p>启动命令:</p>
<div class="highlight highlight-source-shell"><pre>java -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k -jar servlet-test-undertow2.jar</pre></div>
</li>
<li>
<p>监控项:</p>
<pre><code>wrk 的 CPU 使用率: 31.6% ( 最大 800% )
Server 的 CPU 使用率: 90.0 us,  2.6 sy,  0.0 ni,  4.1 id,  0.0 wa,  0.0 hi,  3.3 si,  0.0 st
Server GC 情况：YGC: 361 YGCT: 2.676 FGC:0
</code></pre>
</li>
<li>
<p>wrk 结果:</p>
<pre><code>Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   368.09ms   17.14ms 942.66ms   97.28%
    Req/Sec     1.70k   164.17     4.01k    76.01%
  8118614 requests in 10.00m, 1.22GB read
  Socket errors: connect 0, read 686, write 1453, timeout 0
Requests/sec:  13530.04
Transfer/sec:      2.09MB
</code></pre>
</li>
</ul>
<h3>测试结果分析</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>Servlet 容器</th>
<th>QPS</th>
<th>QPS / GC 次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tomcat 8.0.53 NIO 模式</td>
<td>57726.28</td>
<td>57726.28 / 870 = 66.352</td>
</tr>
<tr>
<td>Tomcat 8.5.34 NIO 模式</td>
<td>59745.50</td>
<td>59745.50 / 940 = 63.559</td>
</tr>
<tr>
<td>Tomcat 8.0.53 APR 模式</td>
<td>82453.62 ( 最优 )</td>
<td>82453.62 / 1224 = 67.364</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Jetty 9.4.8.v20171121</td>
<td>1630.39 ( 最差 )</td>
<td>1630.39 / 640 = 2.547</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Undertow 1.4.22.Final</td>
<td>14117.10</td>
<td>14117.10 / 370 = 38.154</td>
</tr>
<tr>
<td>Undertow 1.4.22.Final 配置线程数</td>
<td>13980.36</td>
<td>13980.36 / 367 = 38.094</td>
</tr>
<tr>
<td>Undertow 2.0.15.Final</td>
<td>13530.04</td>
<td>13530.04 / 361 = 37.479</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>先说结果: <strong>Tomcat APR 模式</strong> "最优" , <strong>Jetty</strong> "最差" , <strong>Undertow</strong> 也没有想象中的碾压 <strong>Tomcat</strong></p>
</li>
<li>
<p><strong>Tomcat NIO 模式</strong> 压力刚上来的时候 <strong>CPU</strong> 会用满 , 稳定后基本会留有 <strong>10%</strong> 以上的空闲</p>
</li>
<li>
<p><strong>Jetty</strong> 采用的默认配置 , 才 <strong>2k</strong> 不到的 <strong>QPS</strong> 确实有点出乎意料的 , 需要配置后做进一步的测试对比</p>
</li>
<li>
<p><strong>Undertow</strong> 提供的配置项很少 , 只有 <strong>线程数</strong> 和 <strong>缓冲大小</strong> , 加大 <strong>线程数</strong> 后也没能提升性能。本次测试中 <strong>Undertow2.0</strong> 版本也没有性能上的提升。</p>
</li>
<li>
<p><strong>Tomcat8.5</strong> 相对于 <strong>Tomcat8.0</strong> 应该有性能上的提升 , 由于系统中安装的 <strong>apr</strong> 库的版本问题没有测试 <strong>Tomcat8.5+APR</strong> 的性能 ( <strong>Tomcat</strong> 版本和 <a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/" rel="nofollow">apr</a> 版本要对应 )</p>
</li>
<li>
<p><strong>默认线程数</strong>: <strong>Undertow</strong> 为 <strong>8</strong> ( <strong>CPU</strong> 核心数 ) 个 <strong>IO</strong> 线程 + <strong>64</strong> ( <strong>8</strong> * <strong>IO</strong> 线程数 ) 个 <strong>WORK</strong> 线程, <strong>Tomcat</strong> 和 <strong>Jetty</strong> 均在 <strong>200</strong> 左右。因为都用的 <strong>NIO</strong> , 所以调大线程数效果不大 , 反而带来 <strong>CPU上下文切换</strong> 和 <strong>内存消耗 ( -Xss )</strong> 的问题</p>
</li>
<li>
<p>听人说 <strong>Undertow</strong> 在正常运行中会莫名其妙挂掉 , 具体原因还不清楚</p>
</li>
</ul>
<h3>优化</h3>
<hr>
<ul>
<li>
<p><strong>JVM 参数</strong></p>
<p>曾经我也比较信奉所谓的 <strong>标准参数</strong> , 然而按照上述方法单独对 <strong>Tomcat</strong> 进行对比测试后并没有得到所谓的 <strong>"参数调优"</strong> 的效果, 所以还是 <strong>针对实际运行情况再做调整吧</strong>。<br>
主要几类配置项有:</p>
<ol>
<li>
<p>-server</p>
</li>
<li>
<p>内存 ( -Xms -Xmx -Xmn -Xss )</p>
</li>
<li>
<p><a href="https://blog.csdn.net/chroje/article/details/79573010" rel="nofollow">垃圾回收器组合</a></p>
</li>
<li>
<p>GC 相关参数 ( 打印日志 / DisableExplicitGC /ExplicitGCInvokesConcurrent / 定时 GC )</p>
</li>
</ol>
</li>
<li>
<p><strong>Connector 运行模式</strong></p>
<p><strong>Tomcat Connector</strong> 有 <strong>BIO</strong> 、<strong>NIO</strong> 、<strong>APR</strong> 三种运行模式 ( 可以看下这篇 <a href="http://hongjiang.info/how-tomcat-implements-keep-alive/" rel="nofollow">文章</a> ) , 虽然 <strong>APR</strong> 模式性能最好 ( 不绝对 ) , 但也带来了维护上的成本 , 所以还是那句话 —— <strong>针对实际的业务场景选择</strong></p>
</li>
<li>
<p><strong>项目运行参数</strong></p>
<p><strong>SpringBoot</strong> 中几个容器的可配置项都在 <strong>org.springframework.boot.autoconfigure.web.ServerProperties</strong> 这个类中, 一般默认就行了, 遇到问题再调整 ( <strong>Tomcat</strong> 相关配置可以看 <a href="http://hongjiang.info/index/tomcat/" rel="nofollow">这里</a> )</p>
</li>
</ul>
<h3>结语</h3>
<hr>
<ul>
<li>
<p><strong>本次测试结果和大部分网上的测试正好相反</strong>。</p>
<p>网上的测试：在一台机器上跑 , 用例并发量比较小 , 得到的 <strong>QPS</strong> 也比较低 ( 几百的数值而且比较接近 ) ，也没有说明测试使用的机器配置和容器版本 , 只是简单的把 <strong>Tomcat</strong> 归类为性能最差。这样的测试结论我认为是很不可靠的。</p>
<p>时间有限 , 以上只是部分的测试用例 , 实际可以组合的情况 ( 服务器配置、容器版本、实际业务代码等等 ) 多了去了 , 所以再强调一遍 —— <strong>本次测试结果仅供参考</strong> 。</p>
</li>
<li>
<p><strong>有人可能会奇怪本次测试的意义？</strong></p>
<p>一般服务器上会部署多个应用 , 不会让一个应用把所有 <strong>CPU</strong> 都吃满 , 而且一般线上应用也不会是这么简单的接口 , 瓶颈往往是在一些复杂的业务逻辑和数据库上 , 网上也有提到三种容器使用的业务场景也有所不同。</p>
<p>我想说的是 , 本次测试纯粹是测试容器的性能 , 空跑的结果都摆在这了 , 跑业务的话性能难道能更好？如果 <strong>Jetty</strong> 真的如测试中那么差 , 还会有人用它跑高并发的项目吗？</p>
<p><strong>所以 , 本文只是提供一种测试思路 , 有疑问就多动动手进行论证 , 在没有亲自实践过的情况下都不应该轻易下"绝对"的结论。</strong></p>
</li>
</ul>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/f7cb40a8ce22">https://www.jianshu.com/p/f7cb40a8ce22</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 GitLab + Jenkins 实现自动化构建]]></title>
            <link>https://anyesu.github.io/blog/articles/20</link>
            <guid>20</guid>
            <pubDate>Sat, 21 Sep 2019 16:26:41 GMT</pubDate>
            <description><![CDATA[背景 在测试环境部署这块, 经历过以下几个阶段: 阶段一 有一台测试服务器把项目放上面测试, 当初也没有什么相关的经验, 每次改完代码本地打包上传到服务器上, 然后一顿命令启动项目, 完成了最原始的部署。 这种方式构建和部署全靠人肉, 项目简单的时候还好说, 项目一多配置一多 ( 比如微服务 ) 中间哪个环节粗心出点错那简直就是灾难。 同时还要专门有人对运维相关的技术比较了解, 不然哪天我不在测试]]></description>
            <content:encoded><![CDATA[<h3>背景</h3>
<hr>
<p>在测试环境部署这块, 经历过以下几个阶段:</p>
<ul>
<li>
<p>阶段一</p>
<p>有一台测试服务器把项目放上面测试, 当初也没有什么相关的经验, 每次改完代码本地打包上传到服务器上, 然后一顿命令启动项目, 完成了最原始的部署。</p>
<p>这种方式构建和部署全靠人肉, 项目简单的时候还好说, 项目一多配置一多 ( 比如微服务 ) 中间哪个环节粗心出点错那简直就是灾难。</p>
<p>同时还要专门有人对运维相关的技术比较了解, 不然哪天我不在测试工作就完全停滞了。</p>
</li>
<li>
<p>阶段二</p>
<p>既然都是重复工作, 那就整理下步骤写个脚本</p>
<ol>
<li>
<p>从 <strong>SVN</strong> 拉代码</p>
</li>
<li>
<p><strong>Maven</strong> 构建打包</p>
</li>
<li>
<p>重启 <strong>Tomcat</strong></p>
</li>
</ol>
<p>每次执行下脚本就搞定了。看着挺不错的, 不过实际执行时的情况总会复杂许多 ( 服务器帐号权限、测试人员对 <strong>Linux</strong> 的熟悉程度、项目启动依赖复杂等等问题 ) 。</p>
</li>
<li>
<p>阶段三</p>
<p>了解到 <strong>Jenkins</strong> 是个不错的工具, 那就把脚本的内容迁移到 <strong>Jenkins</strong> 上, 不管是开发还是测试只要在 web 界面上点击一下按钮即可完成构建部署, 很 easy。</p>
</li>
<li>
<p>阶段四</p>
<p><strong>容器化</strong>: 使用 <strong>Docker</strong> 来部署项目, 这样就可以干掉原来服务器上散落各地参差不齐的 <strong>Tomcat</strong> ( 不同项目依赖不同 ) , 利用 <strong>Docker Compose</strong> 对项目进行编排, 提供一种规范的构建配置 ( 同时也是一份文档 ) , 大大减小了后期维护和交接的成本。</p>
</li>
<li>
<p>阶段五</p>
<p>上面的阶段已经能解决日常需求了, 但是还有一点问题就是每次提交完代码还要手动去 <strong>Jenkins</strong> 上发布, 能更自动点就更好了 ( 嗯, 就是懒 ) 。</p>
<p>于是就引出了本文的目标 —— 自动持续构建, 不需要人工操作 ( 留人工操作用于处理特殊情况 )</p>
</li>
</ul>
<h3>方案流程</h3>
<hr>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/57d2a670c71881b5d6bd0987738624d2669316c8/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663566643533373561626364656238622e706e67"><img src="https://camo.githubusercontent.com/57d2a670c71881b5d6bd0987738624d2669316c8/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663566643533373561626364656238622e706e67" alt="流程图" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-f5fd5375abcdeb8b.png" style="max-width:100%;"></a></p>
<ol>
<li>
<p>开发提交代码</p>
</li>
<li>
<p>开发对需要发布的版本打上 <strong>Tag</strong></p>
</li>
<li>
<p>触发 <strong>GitLab</strong> 的 <strong>tag push</strong> 事件, 调用 <strong>Webhook</strong></p>
</li>
<li>
<p><strong>Webhook</strong> 触发 <strong>Jenkins</strong> 的构建任务</p>
</li>
<li>
<p><strong>Jenkins</strong> 构建完项目可以按版本号上传到仓库、部署、通知相关人员等等</p>
</li>
</ol>
<h3>安装 GitLab</h3>
<hr>
<p><a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" rel="nofollow">GitLab 官方文档</a> 已经介绍的比较详细了, 这里不再赘述, 下面给出最终调整过的 <a href="https://docs.docker.com/compose/compose-file/" rel="nofollow">Docker Compose</a> 配置:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">gitlab</span>:
  <span class="pl-ent">image</span>: <span class="pl-s"><span class="pl-pds">"</span>twang2218/gitlab-ce-zh:11.0.2<span class="pl-pds">"</span></span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
  <span class="pl-ent">hostname</span>: <span class="pl-s"><span class="pl-pds">'</span>gitlab<span class="pl-pds">'</span></span>
  <span class="pl-ent">ports</span>:
    - <span class="pl-s"><span class="pl-pds">"</span>10022:22<span class="pl-pds">"</span></span>
    - <span class="pl-s"><span class="pl-pds">"</span>10080:10080<span class="pl-pds">"</span></span>
    <span class="pl-c"><span class="pl-c">#</span> postgresql 端口</span>
    - <span class="pl-s"><span class="pl-pds">"</span>5432:5432<span class="pl-pds">"</span></span>
  <span class="pl-ent">volumes</span>:
    - <span class="pl-s">./gitlab/data:/var/opt/gitlab</span>
    - <span class="pl-s">./gitlab/log:/var/log/gitlab</span>
    - <span class="pl-s">./gitlab/config:/etc/gitlab</span>
  <span class="pl-ent">environment</span>:
    <span class="pl-ent">GITLAB_OMNIBUS_CONFIG</span>: <span class="pl-s">|</span>
<span class="pl-s">      # 仓库路径, 填写宿主机的域名或 IP</span>
<span class="pl-s">      external_url 'http://192.168.xxx.xxx:10080'</span>
<span class="pl-s">      # 调整工作进程数减小内存占用，最小为 2</span>
<span class="pl-s">      unicorn['worker_processes'] = 2</span>
<span class="pl-s">      gitlab_rails['time_zone'] = 'Asia/Shanghai'</span>
<span class="pl-s"></span>
<span class="pl-s">      # 邮箱配置</span>
<span class="pl-s">      gitlab_rails['gitlab_email_from'] = '&lt;your_email&gt;'</span>
<span class="pl-s">      gitlab_rails['gitlab_email_display_name'] = '&lt;your_email_name&gt;'</span>
<span class="pl-s">      gitlab_rails['smtp_enable'] = <span class="pl-c1">true</span></span>
<span class="pl-s">      gitlab_rails['smtp_address'] = 'smtp.163.com'</span>
<span class="pl-s">      gitlab_rails['smtp_port'] = 25</span>
<span class="pl-s">      gitlab_rails['smtp_user_name'] = "&lt;your_email_account&gt;"</span>
<span class="pl-s">      gitlab_rails['smtp_password'] = "&lt;your_email_password&gt;"</span>
<span class="pl-s">      gitlab_rails['smtp_domain'] = 'smtp.163.com'</span>
<span class="pl-s">      gitlab_rails['smtp_tls'] = <span class="pl-c1">false</span></span>
<span class="pl-s">      gitlab_rails['smtp_openssl_verify_mode'] = 'none'</span>
<span class="pl-s">      gitlab_rails['smtp_enable_starttls_auto'] = <span class="pl-c1">false</span></span>
<span class="pl-s">      gitlab_rails['smtp_ssl'] = <span class="pl-c1">false</span></span>
<span class="pl-s">      gitlab_rails['smtp_force_ssl'] = <span class="pl-c1">false</span></span>
<span class="pl-s"></span>
<span class="pl-s">      # 数据库配置</span>
<span class="pl-s">      gitlab_rails['db_host'] = '127.0.0.1'</span>
<span class="pl-s">      gitlab_rails['db_port'] = 5432</span>
<span class="pl-s">      gitlab_rails['db_username'] = "gitlab"</span>
<span class="pl-s">      gitlab_rails['db_password'] = "gitlab"</span>
<span class="pl-s">      </span>
<span class="pl-s">      postgresql['listen_address'] = '0.0.0.0'</span>
<span class="pl-s">      postgresql['port'] = 5432</span>
<span class="pl-s">      postgresql['md5_auth_cidr_addresses'] = %w()</span>
<span class="pl-s">      postgresql['trust_auth_cidr_addresses'] = %w(0.0.0.0/0)</span>
<span class="pl-s">      postgresql['sql_user'] = "gitlab"</span>
<span class="pl-s">      postgresql['sql_user_password'] = Digest::MD5.hexdigest "gitlab" &lt;&lt; postgresql['sql_user']</span>
<span class="pl-s"></span>
<span class="pl-s">      # 备份设置-保留7天</span>
<span class="pl-s">      gitlab_rails['backup_keep_time'] = 604800</span>
<span class="pl-s"></span>    <span class="pl-ent">GITLAB_BACKUPS</span>: <span class="pl-s"><span class="pl-pds">"</span>daily<span class="pl-pds">"</span></span>
    <span class="pl-ent">GITLAB_SIGNUP</span>: <span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>
    <span class="pl-ent">GITLAB_ROOT_PASSWORD</span>: <span class="pl-s"><span class="pl-pds">"</span>lb80h&amp;85<span class="pl-pds">"</span></span>
    <span class="pl-ent">GITLAB_GRAVATAR_ENABLED</span>: <span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span></pre></div>
<p>说明：</p>
<ul>
<li>
<p>这里使用 <strong>汉化版</strong> 镜像, 如果不适应可以换回 <strong>官方原版</strong> 镜像 <code>gitlab/gitlab-ce:11.0.2-ce.0</code></p>
</li>
<li>
<p>项目初始配置 + 启动很慢, 需要一段时间, 日志中出现 <strong>Reconfigured</strong> 时表示启动成功</p>
</li>
<li>
<p><strong>192.168.xxx.xxx</strong> 替换为宿主机的 <strong>IP</strong> 地址</p>
</li>
<li>
<p>初始管理员帐号密码: <code>root</code> / <code>lb80h&amp;85</code> ( 自行修改配置文件中的密码 )</p>
</li>
<li>
<p>该配置为 <strong>乞丐版</strong> , 内存占用 2G+ ( <strong>worker_processes</strong> 越多内存占用越大, 默认为 8G )</p>
</li>
<li>
<p><strong>postgresql</strong> 为容器中内置的数据库 ( 帐号: <code>gitlab</code> / <code>gitlab</code> ) , 没必要就不用暴露端口了</p>
</li>
<li>
<p>邮箱填写用于发送找回密码和通知的发件人帐号 ( <a href="https://www.cnblogs.com/wenwei-blog/p/6286944.html" rel="nofollow">收不到邮件?</a> ) , 不想配置就删掉相关配置好了, 不影响正常使用</p>
</li>
</ul>
<h3>安装 Jenkins</h3>
<hr>
<p>为了测试方便, 使用 <strong>Docker</strong> 化的 <strong>Jenkins</strong> , 如果需要调用一些特殊的命令或脚本就不是很方便, 实际使用过程中可以换成普通版的。</p>
<p><a href="https://docs.docker.com/compose/compose-file/" rel="nofollow">Docker Compose</a> 配置如下:</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">version</span>: <span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>
<span class="pl-ent">services</span>:
  <span class="pl-ent">jenkins</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">jenkins/jenkins:2.151</span>
    <span class="pl-ent">container_name</span>: <span class="pl-s">jenkins</span>
    <span class="pl-ent">networks</span>:
    - <span class="pl-s">net</span>
    <span class="pl-ent">user</span>: <span class="pl-s"><span class="pl-pds">"</span>root<span class="pl-pds">"</span></span>
    <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
    <span class="pl-ent">ports</span>:
    - <span class="pl-c1">9000:8080</span>
    <span class="pl-ent">environment</span>:
    - <span class="pl-s">JAVA_OPTS="-Duser.timezone=Asia/Shanghai"</span>
    <span class="pl-ent">volumes</span>:
    - <span class="pl-s">/etc/localtime:/etc/localtime:ro</span>
    - <span class="pl-s">./data:/var/jenkins_home:rw</span>
    - <span class="pl-s">./backup:/var/jenkins_backup:rw</span>
<span class="pl-c"><span class="pl-c">#</span> 网络配置</span>
<span class="pl-ent">networks</span>:
  <span class="pl-ent">net</span>:
    <span class="pl-ent">driver</span>: <span class="pl-s">bridge</span>
    <span class="pl-ent">ipam</span>:
      <span class="pl-ent">driver</span>: <span class="pl-s">default</span>
      <span class="pl-ent">config</span>:
      - <span class="pl-ent">subnet</span>: <span class="pl-s">172.23.0.0/16</span></pre></div>
<p>说明：</p>
<ul>
<li>
<p>初次启动请打印日志, 日志中有管理员帐号的初始密码, 第一次登陆的时候需要用到</p>
</li>
<li>
<p>为了方便, 使用 <strong>root</strong> 帐号启动容器, 如果使用默认帐号启动需要修改本地目录 ( data、backup ) 的权限</p>
</li>
</ul>
<h3>配置 GitLab</h3>
<hr>
<p>注册账号什么的就不赘述了, 建一个测试项目 <strong>test</strong> , 随便 <strong>commit</strong> 几条内容</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/567760f7f395212eb8ce7288b54f0b37a5a356bb/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623766623065373032616339316266302e706e67"><img src="https://camo.githubusercontent.com/567760f7f395212eb8ce7288b54f0b37a5a356bb/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623766623065373032616339316266302e706e67" alt="新建测试项目" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-b7fb0e702ac91bf0.png" style="max-width:100%;"></a></p>
<p>按下图步骤创建账号的 <strong>access token</strong> , 用于 <strong>Jenkins</strong> 调用 <strong>GitLab</strong> 的 <strong>API</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/ca7a7b77b98ca3c6b5c8f12d3019991242ab9a8f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383965393739383561356132386563392e706e67"><img src="https://camo.githubusercontent.com/ca7a7b77b98ca3c6b5c8f12d3019991242ab9a8f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d383965393739383561356132386563392e706e67" alt="创建 access token" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-89e97985a5a28ec9.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/f8ce82233fb0b462d4157476c28fbcc58b4c1109/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303636356564396435373133346139382e706e67"><img src="https://camo.githubusercontent.com/f8ce82233fb0b462d4157476c28fbcc58b4c1109/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303636356564396435373133346139382e706e67" alt="获取 access token" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-0665ed9d57134a98.png" style="max-width:100%;"></a></p>
<p>记下这里生成的 <strong>access token</strong> ( <code>gRCtwVWU8cxwHdxxVZJD</code> ) , 后面要用到。</p>
<h3>配置 Jenkins</h3>
<hr>
<ul>
<li>
<p><strong>安装插件 ( 安装过程可能会失败,多试几次就好了 )</strong></p>
<ul>
<li>
<p><a href="https://wiki.jenkins.io/display/JENKINS/Git+Parameter+Plugin" rel="nofollow">Git Parameter</a> ( 用于参数化构建中动态获取项目分支 )</p>
</li>
<li>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/Generic+Webhook+Trigger+Plugin" rel="nofollow">Generic Webhook Trigger</a> ( 用于解析 <strong>Webhook</strong> 传过来的参数 )</p>
</li>
<li>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin" rel="nofollow">GitLab</a> ( 用于推送构建结果给 <strong>GitLab</strong> )</p>
</li>
</ul>
</li>
<li>
<p><strong>添加 GitLab 凭据</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/b47d1d9778b292163f6b4633fac5a9e329e47140/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663164663139306535633138363439622e706e67"><img src="https://camo.githubusercontent.com/b47d1d9778b292163f6b4633fac5a9e329e47140/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d663164663139306535633138363439622e706e67" alt="首页 -&gt; 凭据 -&gt; 系统 -&gt; 全局凭据 -&gt; 添加凭据, 把上面 GitLab 中生成的 access token 填进去" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-f1df190e5c18649b.png" style="max-width:100%;"></a></p>
</li>
<li>
<p><strong>配置 GitLab 连接</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c6d7061acabddf331138c6b0be9c505f58f42c05/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333466613137306163663134356137382e706e67"><img src="https://camo.githubusercontent.com/c6d7061acabddf331138c6b0be9c505f58f42c05/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333466613137306163663134356137382e706e67" alt="首页 -&gt; 系统管理 -&gt; 系统设置 -&gt; Gitlab 配置项, 填入 GitLab 相关的配置, 后面配置项目时用到" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-34fa170acf145a78.png" style="max-width:100%;"></a></p>
</li>
<li>
<p><strong>新建项目 test</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c73331818f4f540471bee864cf0cfe5d0e8515a7/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313764316536333637333138613133662e706e67"><img src="https://camo.githubusercontent.com/c73331818f4f540471bee864cf0cfe5d0e8515a7/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313764316536333637333138613133662e706e67" alt="Jenkins项目完整配置" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-17d1e6367318a13f.png" style="max-width:100%;"></a></p>
<ul>
<li>
<p><strong>勾选</strong> 参数化构建过程, 添加 <strong>Git Parameter</strong> 类型的参数 <strong>ref</strong> , 这样构建的时候就可以指定分支进行构建。</p>
</li>
<li>
<p><strong>Source Code Management</strong> 选择 <strong>Git</strong> , 添加项目地址和授权方式 ( <strong>帐号密码</strong> 或者 <strong>ssh key</strong> ) , 分支填写构建参数 <strong>$ref</strong>。</p>
</li>
<li>
<p><strong>Build Triggers</strong> 选择 <strong>Generic Webhook Trigger</strong> 方式用于解析 <strong>GitLab</strong> 推过来的详细参数 ( <a href="http://jsonpath.com" rel="nofollow">jsonpath 在线测试</a> ) 。其他触发方式中: <a href="https://www.cnblogs.com/jwentest/p/8204421.html" rel="nofollow">Trigger builds remotely</a> 是 <strong>Jenkins</strong> 自带的, <strong>Build when a change is pushed to GitLab</strong> 是 <strong>GitLab 插件</strong> 提供的, 都属于简单的触发构建, 无法做复杂的处理。</p>
</li>
<li>
<p>虽然 <strong>Generic Webhook Trigger</strong> 提供了 <strong>Token</strong> 参数进行鉴权, 但为了避免不同项目进行混调 ( 比如 A 项目提交代码却触发了 B 项目的构建) , 还要对请求做下过滤。<strong>Optional filter</strong> 中 <strong>Text</strong> 填写需要校验的内容 ( 可使用变量 ) , <strong>Expression</strong> 使用正则表达式对 <strong>Text</strong> 进行匹配, 匹配成功才允许触发构建。</p>
</li>
<li>
<p><strong>Build</strong> 内容按自己实际的项目类型进行调整, 使用 <strong>Maven 插件</strong> 或 <strong>脚本</strong> 等等。</p>
</li>
<li>
<p><strong>GitLab Connection</strong> 选择上面添加的 <strong>GitLab 连接 ( <code>Jenkins</code> )</strong> , <strong>Post-build Actions</strong> 添加 <strong>Publish build status to GitLab</strong> 动作, 实现构建结束后通知构建结果给 <strong>GitLab</strong>。</p>
</li>
</ul>
</li>
<li>
<p>回到 <strong>GitLab</strong> 的项目页面中, 添加一个 <strong>Webhook</strong> ( http://JENKINS_URL/generic-webhook-trigger/invoke?token=&lt;上面 <strong>Jenkins</strong> 项目配置中的 <strong>token</strong>&gt; ) , 触发器选择 <strong>标签推送事件</strong>。因为日常开发中 <strong>push</strong> 操作比较频繁而且不是每个版本都需要构建, 所以只针对需要构建的版本打上 <strong>Tag</strong> 就好了。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/4b81817cea2b7c56ef5b93f07f888bb8b2d7340c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393263643666626436613362333233332e706e67"><img src="https://camo.githubusercontent.com/4b81817cea2b7c56ef5b93f07f888bb8b2d7340c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393263643666626436613362333233332e706e67" alt="gitlab添加 Webhook" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-92cd6fbd6a3b3233.png" style="max-width:100%;"></a></p>
<p>创建完使用 <strong>test 按钮</strong> 先测试下, 可能会出现下面的错误</p>
<blockquote>
<p>Hook execution failed: URL '<a href="http://192.168.xxx.xxx:9000/generic-webhook-trigger/invoke?token=d63ad84eb18cb04d4459ec347a196dce" rel="nofollow">http://192.168.xxx.xxx:9000/generic-webhook-trigger/invoke?token=d63ad84eb18cb04d4459ec347a196dce</a>' is blocked: Requests to the local network are not allowed</p>
</blockquote>
<p><strong>解决办法: <a href="https://blog.csdn.net/xukangkang1hao/article/details/80756085" rel="nofollow">允许 GitLab 本地网络发送 Webhook 请求</a></strong></p>
</li>
</ul>
<h3>测试效果</h3>
<hr>
<p>可以在 <strong>GitLab</strong> 直接添加 <strong>Tag</strong> , 不过我觉得用 <strong>IDEA</strong> 上操作更方便点, 就把代码拉下来在本地操作</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/30721d1c7f40143de95e2df128512abdea878246/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326265366338326161663532646433302e706e67"><img src="https://camo.githubusercontent.com/30721d1c7f40143de95e2df128512abdea878246/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326265366338326161663532646433302e706e67" alt="针对每个commit添加tag" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-2be6c82aaf52dd30.png" style="max-width:100%;"></a></p>
<p>然后使用快捷键 <strong>Ctrl + Shift + K</strong> 调出 <strong>Push 窗口</strong> , 把 <strong>Tag</strong> 推送到 <strong>GitLab</strong> 中</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/05c75ec6ca98083de0859cf5ec6ddfe1c780bed9/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393366646636646562313630336338332e706e67"><img src="https://camo.githubusercontent.com/05c75ec6ca98083de0859cf5ec6ddfe1c780bed9/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393366646636646562313630336338332e706e67" alt="push tag" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-93fdf6deb1603c83.png" style="max-width:100%;"></a></p>
<p>回到 <strong>GitLab</strong> 页面可以看到触发了 <strong>Webhook</strong> , <strong>View details</strong> 查看请求详情, <strong>Response body</strong> 中 <code>triggered</code> 字段值为 <code>true</code> 则表示成功触发了 <strong>Jenkins</strong> 进行构建</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/25b99f375c1a3625191c6788de9f68d12d3e7804/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613363653934376661336536653366322e706e67"><img src="https://camo.githubusercontent.com/25b99f375c1a3625191c6788de9f68d12d3e7804/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613363653934376661336536653366322e706e67" alt="Webhook 触发历史" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a3ce947fa3e6e3f2.png" style="max-width:100%;"></a></p>
<p>再看下构建结果</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d5d9474ce694fcf9929a0992f550c8b908513d3a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613964386230386239373534313264302e706e67"><img src="https://camo.githubusercontent.com/d5d9474ce694fcf9929a0992f550c8b908513d3a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613964386230386239373534313264302e706e67" alt="gitlab 查看构建结果 — 流水线" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a9d8b08b975412d0.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/08134b3983d09868b615aace43564ffa85b19e01/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313931303835616363643034623837642e706e67"><img src="https://camo.githubusercontent.com/08134b3983d09868b615aace43564ffa85b19e01/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313931303835616363643034623837642e706e67" alt="gitlab 中查看构建结果 — commits" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-191085accd04b87d.png" style="max-width:100%;"></a></p>
<p><strong>注意:</strong> 每添加一个 <strong>Tag</strong> 就会触发一次事件, 不管是不是一起 <strong>push</strong> 的。所以一次 <strong>push</strong> 多个 <strong>Tag</strong> 会触发 <strong>Jenkins</strong> 进行多次构建。不过 <strong>Jenkins</strong> 已经做了处理, 默认串行执行任务 ( 一个任务结束再执行下一个 ) , 而且在构建前有一个 <strong>pending</strong> 状态, 此时被多次触发会进行合并, 并取首次触发的参数, 如下图所示:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1e6187719d4329160b5397e4a4e92c9d11ba874a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d346433616134646366653862336265382e706e67"><img src="https://camo.githubusercontent.com/1e6187719d4329160b5397e4a4e92c9d11ba874a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d346433616134646366653862336265382e706e67" alt="同时触发多次事件" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-4d3aa4dcfe8b3be8.png" style="max-width:100%;"></a></p>
<h3>关于 Tag 的几点说明</h3>
<hr>
<ul>
<li>
<p>推送 <strong>Tag</strong> 到远端的时候, 远端已存在 ( 同名 ) 的 <strong>Tag</strong> 不会被添加到远端</p>
</li>
<li>
<p>拉取远端的 <strong>Tag</strong> 时, 本地已存在 ( 同名 ) 的 <strong>Tag</strong> 不会添加到本地</p>
</li>
<li>
<p>拉取远端的 <strong>Tag</strong> 时, 本地不会删除远端已删除的 <strong>Tag</strong> , 需要同步远端的 <strong>Tag</strong> 可以先删除本地所有 <strong>Tag</strong> 再 <strong>pull</strong></p>
</li>
<li>
<p>删除 <strong>Tag</strong> 也会推送事件, 要做好过滤 ( 上面配置中已使用 <strong>commitsId</strong> 字段进行过滤 )</p>
</li>
</ul>
<h3>未完待续</h3>
<hr>
<p><strong>通过上面的步骤已经初步实现了想要的效果, 还有几个点后续可以再考虑下：</strong></p>
<ul>
<li>
<p>上文只包含自动构建的内容, 对于项目的部署可以考虑几种方式: 手动选择指定的版本进行发布、构建任务结束后直接触发部署任务、定时部署最新版本 ( 根据实际需求调整 )。</p>
</li>
<li>
<p>测试发版的频率会比较高, 会生成大量的 <strong>Tag</strong> , 可以约定 <strong>Tag</strong> 的格式, 比如 <code>test 0.0.1</code> 表示触发测试环境的项目构建, <code>online 1.0.0</code> 表示触发正式版本构建, 隔离之后可以方便后续的维护和清理。</p>
</li>
<li>
<p>构建部分可以整合 <strong>Docker</strong> , 把构建结果打包到 <strong>Docker</strong> 镜像中 ( 代码版本库的 <strong>Tag</strong> 正好可以作为镜像的 <strong>Tag</strong> ) , 再上传到 <strong>Docker</strong> 镜像仓库 ( <a href="https://docs.docker.com/registry/" rel="nofollow">私服</a> 或者第三方仓库 ) 中, 后续部署就可以直接从镜像仓库拉取镜像直接运行了。</p>
</li>
<li>
<p>集成自动化测试 , 比如 <a href="https://www.yiibai.com/jenkins/jenkins_continuous_deployment.html" rel="nofollow">这个</a></p>
</li>
<li>
<p>尝试配置 <strong>GitLab</strong> 自带的 <a href="https://gitlab.com/help/ci/quick_start/README.md" rel="nofollow">CI / CD</a></p>
</li>
</ul>
<h3>总结</h3>
<hr>
<p>以上就是对曾经踩过的一些坑进行的整合, 也没什么好总结的。总之, 合理地利用现有工具来解放双手, 就能有更多时间做其他想做的事!</p>
<p>时间有限一些基础的步骤就不细讲直接一笔带过了, 方案上可能有些细节方面也没考虑全, 欢迎评论留言。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/7e8037c63d63">https://www.jianshu.com/p/7e8037c63d63</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-f5fd5375abcdeb8b.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[使用 SSH TUNNEL 打通公司和家里的网络]]></title>
            <link>https://anyesu.github.io/blog/articles/19</link>
            <guid>19</guid>
            <pubDate>Sat, 21 Sep 2019 12:38:53 GMT</pubDate>
            <description><![CDATA[前言 平时经常遇到下面的情况： 工作没做完，想回家继续做。带电脑回家？ 碰到以前做过的功能，想从家里的电脑捞一点代码。没独立 IP 怎么访问？ 服务器只允许公司网络访问，在外面要登服务器。找领导设置安全组权限 ( 或者防火墙 ) ？ 在外面想访问公司局域网中的某个服务，比如 Gitlab ？ 公司网络不能逛淘宝？ 想去墙外的世界看一看？ 一般情况下的对应方法： 远程连接 ( 比如 Windows ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>平时经常遇到下面的情况：</p>
<ol>
<li>工作没做完，想回家继续做。带电脑回家？</li>
<li>碰到以前做过的功能，想从家里的电脑捞一点代码。没独立 <strong>IP</strong> 怎么访问？</li>
<li>服务器只允许公司网络访问，在外面要登服务器。找领导设置安全组权限 ( 或者防火墙 ) ？</li>
<li>在外面想访问公司局域网中的某个服务，比如 <strong>Gitlab</strong> ？</li>
<li>公司网络不能逛淘宝？</li>
<li>想去墙外的世界看一看？</li>
</ol>
<p>一般情况下的对应方法：</p>
<ol>
<li>远程连接 ( 比如 <strong>Windows</strong> 自带的 )</li>
<li><strong>NAT</strong> 内网穿透 ( 比如花生壳，几年前用过免费版的，不太稳定，<strong>Linux</strong> 下安装也不太顺畅 )</li>
<li>一般需要正当理由</li>
<li>公司有固定公网 <strong>IP</strong> 的话，路由器设置端口转发，不过路由器权限呢？</li>
<li>代理服务器</li>
<li><strong>VPN</strong> ( 作用和代理服务器差不多，但原理不一样 )</li>
</ol>
<p>本文的目的就是使用 <strong>SSH TUNNEL</strong> 这项技术解决上面的问题，也就是打通所谓的 "公司内网" 和 "家庭内网"。</p>
<h3>SSH TUNNEL 简介</h3>
<hr>
<p>经常远程连接 <strong>Linux</strong> 服务器的小伙伴，对于 <strong>ssh</strong> 这个命令应该不陌生吧。它还可以不执行远程指令只建立一条和远程服务器之间的连接，也就是形成了一条通道，在这条通道上我们就可以做一些文章了。<br>
先看下 <strong>ssh</strong> 命令的参数介绍 ( 需要了解更多请通过命令 <a href="https://linux.die.net/man/1/ssh" rel="nofollow"><code>man ssh</code></a> 查看 )</p>
<div class="highlight highlight-source-shell"><pre>-1: 强制使用ssh协议版本1；
-2: 强制使用ssh协议版本2；
-4: 强制使用IPv4地址；
-6: 强制使用IPv6地址；
-A: 开启认证代理连接转发功能；
-a: 关闭认证代理连接转发功能；
-b: 使用本机指定地址作为对应连接的源IP地址；
-C: 请求压缩所有数据；
-F: 指定ssh指令的配置文件；
-f: 后台执行ssh指令；
-g: 允许远程主机连接主机的转发端口；
-i: 指定身份文件；
-l: 指定连接远程服务器登录用户名；
-N: 不执行远程指令；
-o: 指定ssh客户端配置选项来覆盖配置文件中的配置,比如: -o <span class="pl-s"><span class="pl-pds">"</span>StrictHostKeyChecking no<span class="pl-pds">"</span></span> 可以去除检查主机的提示；
-p: 指定远程服务器上的ssh端口(默认为22)；
-q: 静默模式；
-X: 开启X11转发功能；
-x: 关闭X11转发功能；
-y: 开启信任X11转发功能。

-D: 监听本地的指定端口，本机将作为 SOCKS5 服务器使用
-L: 本地监听指定端口，该端口收到的请求会通过远程服务器转发到另一台机器的指定端口上
-R: 远程服务器上监听指定端口，该端口收到的请求会通过本地转发到另一台机器的指定端口上</pre></div>
<p>关键的就是最后的三个参数，对应 <strong>SSH 隧道</strong> 的三种端口转发模式: 本地转发 ( <strong>-L Local</strong> )，远程转发 ( <strong>-R Remote</strong> ) 和动态转发 ( <strong>-D Dynamic</strong> )</p>
<h4>本地转发</h4>
<p><strong>本地监听指定端口，该端口收到的请求会通过远程服务器转发到另一台机器的指定端口上</strong></p>
<ul>
<li>
<p>语法：</p>
<div class="highlight highlight-source-shell"><pre>ssh [-p ssh_port] -L [bind_address:]port:host:hostport user@remote_host

解释:
    port: 本地监听的端口
    bind_address: 监听端口使用的本地地址 ( 如: 192.168.1.2,127.0.0.1,0.0.0.0 ), 不设置时默认为回环地址 ( 127.0.0.1 )
    host: 转发的目标 IP
    hostport: 转发的目标端口
注意:
    host:hostport 是远程主机 user@remote_host:ssh_port 所能访问到的地址 ( 包括 user@remote_host 自己 )，本地主机不一定能访问该地址</pre></div>
</li>
<li>
<p>示例：</p>
<div class="highlight highlight-source-shell"><pre>ssh -p 23 -Nf -L 0.0.0.0:3000:123.123.123.124:3001 root@123.123.123.123

说明:
    1. 通过 23 端口 ssh 远程服务器 123.123.123.123，使用帐号 root 登录
    2. 本地监听端口 0.0.0.0:3000
    3. 123.123.123.124 和 123.123.123.123 在一个局域网下，而本地不能直接访问 123.123.123.124
    4. 123.123.123.124 主机通过 3001 端口开放服务
    5. 调用链路: 本地访问 --<span class="pl-k">&gt;</span> 127.0.0.1:3000 -- ssh 隧道 --<span class="pl-k">&gt;</span> 123.123.123.123 -- 转发 --<span class="pl-k">&gt;</span> 123.123.123.124:3001</pre></div>
<p>上面示例中相当于将远程主机 <strong>123.123.123.124</strong> 的 <strong>3001</strong> 端口映射为本地的 <strong>3000</strong> 端口，这样就可以通过局域网访问被限制的公网服务了。</p>
</li>
</ul>
<h4>远程转发</h4>
<p><strong>远程服务器上监听指定端口，该端口收到的请求会通过本地转发到另一台机器的指定端口上</strong></p>
<ul>
<li>
<p>语法：</p>
<div class="highlight highlight-source-shell"><pre>ssh [-p ssh_port] -R [bind_address:]port:host:hostport user@remote_host

解释:
    语法和 -L 一样，只不过监听侧和目标侧的网络对换而已
    port: 在远程主机 user@remote_host 上监听的端口
    bind_address: 远程主机 user@remote_host  监听端口使用的地址 ( 如: remote_host, 127.0.0.1, 0.0.0.0 )。和 -L 有点区别，指定 IP 需要在远程主机上修改 /etc/ssh/sshd_config 中的配置: GatewayPorts。
      <span class="pl-s"><span class="pl-pds">"</span>yes<span class="pl-pds">"</span></span> 表示 强制为 0.0.0.0<span class="pl-k">;</span>
      <span class="pl-s"><span class="pl-pds">"</span>no<span class="pl-pds">"</span></span> 表示 强制为回环地址 ( 127.0.0.1 )<span class="pl-k">;</span> ( 默认 )
      <span class="pl-s"><span class="pl-pds">"</span>clientspecified<span class="pl-pds">"</span></span> 表示 由客户端决定<span class="pl-k">;</span>
    host: 转发的目标 IP
    hostport: 转发的目标端口
注意:
    host:hostport 是本地主机所能访问到的地址 ( 包括本机 )，远程主机 user@remote_host:ssh_port 不一定能访问该地址</pre></div>
</li>
<li>
<p>示例：</p>
<div class="highlight highlight-source-shell"><pre>ssh -p 23 -Nf -R 172.17.0.1:3000:192.168.1.100:3001 root@123.123.123.123

说明:
    1. 通过 23 端口 ssh 远程服务器 123.123.123.123，使用帐号 root 登录
    2. 123.123.123.123 监听端口 172.17.0.1:3000 ( 我的远程服务器运行着 docker 所以有一个虚拟网络 172.17.0.0 )
    3. 192.168.1.100 和 本地主机 在一个局域网下，而 123.123.123.123 ( 外网 ) 不能直接访问 192.168.1.100 ( 内网 )
    4. 192.168.1.100 主机通过 3001 端口开放服务
    5. 调用链路: 远程服务器中访问 --<span class="pl-k">&gt;</span> 172.17.0.1:3000 -- ssh 隧道 --<span class="pl-k">&gt;</span> 本地 -- 转发 --<span class="pl-k">&gt;</span> 192.168.1.100:3001</pre></div>
<p>上面示例中相当于将局域网主机 <strong>192.168.1.100</strong> 的 <strong>3001</strong> 端口映射为远程服务器 <strong>123.123.123.123</strong> 的 <strong>3000</strong> 端口，这样就可以通过公网来访问局域网中的服务了。</p>
</li>
</ul>
<h4>动态转发</h4>
<p><strong>监听本地的指定端口，本机将作为 SOCKS5 服务器使用</strong></p>
<ul>
<li>
<p>语法：</p>
<div class="highlight highlight-source-shell"><pre>ssh [-p ssh_port] -D [bind_address:]port user@remote_host

解释:
    port: 本地监听的端口
    bind_address: 监听端口使用的本地地址 ( 如: 192.168.1.2, 127.0.0.1, 0.0.0.0 ), 不设置时默认为回环地址 ( 127.0.0.1 )
注意:
    启动 socks5 代理
代理测试示例:
    curl --socks5 bind_address:port baidu.com</pre></div>
</li>
<li>
<p>示例：</p>
<div class="highlight highlight-source-shell"><pre>ssh -p 23 -Nf -D 127.0.0.1:3000 root@123.123.123.123

说明:
    1. 通过 23 端口 ssh 远程服务器 123.123.123.123，使用帐号 root 登录
    2. 本地监听端口 127.0.0.1:3000
    3. 调用链路: 本地局域网中访问任意 http 服务 -- 使用代理 --<span class="pl-k">&gt;</span> 172.17.0.1:3000 -- ssh 隧道 --<span class="pl-k">&gt;</span> 123.123.123.123 -- 转发 --<span class="pl-k">&gt;</span> 目标 http 服务</pre></div>
<p>上面示例中相当于开启了一个 <strong>代理服务器</strong> ，比起 <strong>本地转发</strong> 需要指定具体端口来说更加方便。</p>
</li>
</ul>
<h3>正文</h3>
<hr>
<p>上面已经介绍了 <strong>SSH TUNNEL</strong> 的使用方式，接下来就开始干正事了，先上两张网络拓扑图。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/620b2bf2ab5ebb3b3f0653f199b5d3b65f1fc73d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313361303332383537623533303133622e6a7067"><img src="https://camo.githubusercontent.com/620b2bf2ab5ebb3b3f0653f199b5d3b65f1fc73d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313361303332383537623533303133622e6a7067" alt="SSH TUNNEL 最终效果" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-13a032857b53013b.jpg" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/365fb03b530d7159683511db83371015247b0534/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613033656662366137653162626636302e6a7067"><img src="https://camo.githubusercontent.com/365fb03b530d7159683511db83371015247b0534/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613033656662366137653162626636302e6a7067" alt="原先未配置的网络" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a03efb6a7e1bbf60.jpg" style="max-width:100%;"></a></p>
<p>对比两张图把少的线连上就好了，是不是很 easy ?</p>
<ul>
<li>
<p><strong>原先环境：</strong><br>
三个独立的网络: <strong>公司内网</strong>、<strong>家里内网</strong>、<strong>阿里云专有网络</strong>，其中可以通过 <strong>公司网络</strong> 访问 <strong>阿里云</strong> 上的服务器而 <strong>家里网络</strong> 则不行。</p>
</li>
<li>
<p><strong>目标：</strong></p>
<ol>
<li>使 <strong>家里网络</strong> 的主机能访问 <strong>公司内局域网</strong> 中的主机</li>
<li>使 <strong>家里网络</strong> 的主机能访问 <strong>公司阿里云</strong> 上的服务器</li>
</ol>
</li>
<li>
<p><strong>预备工作:</strong></p>
<ol>
<li>
<p>有一台公网的服务器作为 <strong>跳板机</strong> ，公司和家里都能访问到它</p>
<p>( 没有服务器？阿里云腾讯云学生机弄台玩玩 )</p>
</li>
<li>
<p>因为 <strong>ssh</strong> 命令不能添加密码作为参数，只能手动输入，而且每次连接都要重新输入也不是很方便，这里采用 <strong>公钥方式</strong> 登录就可以免输密码了</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 创建 ssh 密钥对</span>
ssh-keygen -t rsa -b 4096 -C <span class="pl-s"><span class="pl-pds">"</span>备注1<span class="pl-pds">"</span></span>
  
<span class="pl-c"><span class="pl-c">#</span> 远程服务器上的 ~/.ssh/authorized_keys 权限要是 600</span>
<span class="pl-c"><span class="pl-c">#</span> 追加本机公钥到远程服务器</span>
cat <span class="pl-k">~</span>/.ssh/id_rsa.pub <span class="pl-k">|</span> ssh -p 23 root@123.123.123.123 <span class="pl-s"><span class="pl-pds">"</span>cat - &gt;&gt; ~/.ssh/authorized_keys<span class="pl-pds">"</span></span>
  
<span class="pl-c"><span class="pl-c">#</span> 或者直接复制本机公钥到远程服务器 ( 会覆盖掉远程服务器已有的其他公钥 )</span>
scp -P 23 -p <span class="pl-k">~</span>/.ssh/id_rsa.pub root@123.123.123.123:<span class="pl-k">~</span>/.ssh/authorized_keys</pre></div>
</li>
</ol>
</li>
<li>
<p><strong>步骤：</strong></p>
<ol>
<li>
<p>将 <strong>公司主机A</strong> 的端口 <strong>22</strong> 映射到 <strong>跳板机J</strong> 的端口 <strong>9999</strong> 上, 在 <strong>公司主机A</strong> 按照下面的命令配置 ( <strong>跳板机J</strong> 需要按上文中的方式将 <strong>GatewayPorts</strong> 设为 <code>true</code> )</p>
<div class="highlight highlight-source-shell"><pre>ssh -p 23 -Nf -R 9999:127.0.0.1:22 root@123.123.123.123</pre></div>
<p>当然也可以通过 <strong>docker</strong> 运行 <strong>autossh</strong> 来使这个隧道可以自动重连</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-c"><span class="pl-c">#</span> 暴露本地 ssh 端口到远端服务器端口</span>
<span class="pl-ent">ssh-to-expose-ssh-server</span>:
  <span class="pl-ent">image</span>: <span class="pl-s">jnovack/autossh</span>
  <span class="pl-ent">container_name</span>: <span class="pl-s">autossh-ssh-to-expose-ssh-server</span>
  <span class="pl-c"><span class="pl-c">#</span> 使用宿主机的网络</span>
  <span class="pl-ent">network_mode</span>: <span class="pl-s">host</span>
  <span class="pl-ent">environment</span>:
    - <span class="pl-s">SSH_HOSTUSER=root</span>
    - <span class="pl-s">SSH_HOSTNAME=123.123.123.123</span>
    - <span class="pl-s">SSH_HOSTPORT=23</span>
    - <span class="pl-s">SSH_TUNNEL_REMOTE=9999</span>
    - <span class="pl-s">SSH_TUNNEL_HOST=127.0.0.1</span>
    - <span class="pl-s">SSH_TUNNEL_LOCAL=22</span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
  <span class="pl-ent">volumes</span>:
    - <span class="pl-s">~/.ssh/id_rsa:/id_rsa  </span></pre></div>
<p>这样在 <strong>跳板机J</strong> 上就可以通过 <code>ssh -p 9999 root@127.0.0.1</code> 远程连接到 <strong>公司主机A</strong> 了</p>
</li>
<li>
<p>在 <strong>跳板机J</strong> 上设置动态转发使其作为 <strong>代理服务器</strong> , 将接收到的请求再转发到 <strong>公司主机A</strong></p>
<p>在 <strong>跳板机J</strong>上执行下面的命令</p>
<div class="highlight highlight-source-shell"><pre>ssh -p 9999 -Nf -D 0.0.0.0:1080 root@127.0.0.1</pre></div>
<p>同样的，要把 <strong>跳板机J</strong> 的 <strong>公钥</strong> 复制到 <strong>公司主机A</strong> 上实现免密登录</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 创建 ssh 密钥对</span>
ssh-keygen -t rsa -b 4096 -C <span class="pl-s"><span class="pl-pds">"</span>备注2<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> 追加本机公钥到远程服务器</span>
cat <span class="pl-k">~</span>/.ssh/id_rsa.pub <span class="pl-k">|</span> ssh -p 9999 root@127.0.0.1 <span class="pl-s"><span class="pl-pds">"</span>cat - &gt;&gt; ~/.ssh/authorized_keys<span class="pl-pds">"</span></span></pre></div>
<p>当然也可以使用 <strong>docker</strong> 启动 <strong>autossh</strong></p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-c"><span class="pl-c">#</span> 使用 SSH TUNNEL 创建 SOCKS5 代理</span>
<span class="pl-ent">ssh-tunnel-socks5-server</span>:
  <span class="pl-ent">image</span>: <span class="pl-s">jnovack/autossh</span>
  <span class="pl-ent">container_name</span>: <span class="pl-s">ssh-tunnel-socks5-server</span>
  <span class="pl-ent">entrypoint</span>:
    <span class="pl-s">autossh</span>
     <span class="pl-s">-M 0</span>
     <span class="pl-s">-N</span>
     <span class="pl-s">-o ServerAliveInterval=5</span>
     <span class="pl-s">-o ServerAliveCountMax=1</span>
     <span class="pl-s">-o "ExitOnForwardFailure yes"</span>
     <span class="pl-s">-o "StrictHostKeyChecking no"</span>
     <span class="pl-s">-t -t</span>
     <span class="pl-s">-i /id_rsa</span>
     <span class="pl-s">-D 0.0.0.0:1080</span>
     <span class="pl-s">-p 9999</span>
     <span class="pl-c"><span class="pl-c">#</span> 使用宿主机的IP</span>
     <span class="pl-s">root@172.17.0.1</span>
  <span class="pl-ent">ports</span>:
    - <span class="pl-s"><span class="pl-pds">"</span>1081:1080<span class="pl-pds">"</span></span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
  <span class="pl-ent">volumes</span>:
    - <span class="pl-s">~/.ssh/id_rsa:/id_rsa</span></pre></div>
</li>
</ol>
<p>这样 <strong>家里主机F</strong> 就可以通过设置代理 <strong>跳板机J</strong> 连接上 <strong>阿里云</strong> 上的服务器了。</p>
<p>原理: <strong>公司主机A</strong> 和 <strong>跳板机J</strong> 联合组成 <strong>代理层</strong> 。调用链路为: <strong>家里主机F</strong> -- 使用代理 --&gt; <strong>跳板机J</strong> -- ssh 隧道 --&gt; <strong>公司主机A</strong> -- 转发 --&gt; <strong>阿里云</strong> 服务器。</p>
<p><strong>注</strong> : 组成 <strong>代理层</strong> 还有另一种方式: <strong>公司主机A</strong> 开代理服务同时把端口远程暴露到 <strong>跳板机J</strong> 上, 通过这种方式就可以配置代理服务的密码了, 具体配置参照 <a href="https://github.com/anyesu/SSH-Tunnel/blob/master/client-side/docker-compose-proxy.yml">这里</a> 。</p>
</li>
</ul>
<p><strong>就这么两步配置已经打通"公司网络"和"家里网络"了。不过，貌似实现的效果是单向的诶 ( 只能家里连公司，公司还不能连家里, 如下图所示 )</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/212ac63f7a23394f3f702c2bc9812378de2361b0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313562656231613831636534376565312e6a7067"><img src="https://camo.githubusercontent.com/212ac63f7a23394f3f702c2bc9812378de2361b0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d313562656231613831636534376565312e6a7067" alt="SSH TUNNEL 单向配置效果" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-15beb1a81ce47ee1.jpg" style="max-width:100%;"></a></p>
<p>解决办法: <strong>家里主机F</strong> 按 <strong>公司主机A</strong> 的步骤再配一遍就好啦。</p>
<h3>拓展</h3>
<hr>
<ul>
<li>
<p><strong>使用代理访问受限制的网站 ( 比如公司内网的项目 ) ：</strong></p>
<ol>
<li>
<p>由于代理服务器使用的是 <strong>SOCKS5</strong> 协议，<strong>Chrome</strong> 上安装 <strong>SwitchyOmega</strong> 插件配置代理服务器地址，即可通过代理服务器访问受限制的服务了。</p>
</li>
<li>
<p>将 <strong>SOCKS5</strong> 协议转为 <strong>HTTP</strong> 协议，然后通过系统自带的方式 ( <strong>Win</strong> 下设置 <strong>IE</strong> 的 <strong>Internet 属性</strong> ，移动设备设置 <strong>WIFI 的 HTTP 代理</strong> ) 来设置全局代理，<strong>docker-compose</strong> 配置如下</p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-c"><span class="pl-c">#</span> 使用 gost 代理 SOCKS5 端口</span>
<span class="pl-ent">gost-server</span>:
  <span class="pl-ent">image</span>: <span class="pl-s">ginuerzh/gost</span>
  <span class="pl-ent">command</span>: <span class="pl-s">-L=:8080 -F=socks5://ssh-to-local-proxy:1080</span>
  <span class="pl-ent">ports</span>:
    - <span class="pl-s"><span class="pl-pds">"</span>1082:8080<span class="pl-pds">"</span></span>
<span class="pl-ent">restart</span>: <span class="pl-s">always</span>

<span class="pl-c"><span class="pl-c">#</span> 使用 privoxy 代理 SOCKS5 端口</span>
<span class="pl-ent">privoxy</span>:
  <span class="pl-ent">image</span>: <span class="pl-s">rdsubhas/tor-privoxy-alpine</span>
  <span class="pl-ent">entrypoint</span>: <span class="pl-s">sh -c 'echo "listen-address 0.0.0.0:8118" &gt; /etc/service/privoxy/config &amp;&amp; echo "forward-socks5 / ssh-to-local-proxy:1080 ." &gt;&gt; /etc/service/privoxy/config &amp;&amp; privoxy --no-daemon /etc/service/privoxy/config'</span>
  <span class="pl-ent">ports</span>:
  - <span class="pl-s"><span class="pl-pds">"</span>1083:8118<span class="pl-pds">"</span></span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span></pre></div>
<p>这里给出两种转换方式 : <a href="https://github.com/ginuerzh/gost">gost</a> 和 <a href="https://blog.csdn.net/dounine/article/details/53028747" rel="nofollow">privoxy</a> , 选择其中一种方式即可。<strong>privoxy</strong> 找不到纯净的镜像, 都是捆绑 <strong>tor</strong> 的, 就挑一个最精简的来做修改吧。</p>
</li>
<li>
<p>其实还可以在 <strong>公司主机A</strong> 搭建 <strong>SS 服务器</strong> , 然后就可以通过 <strong>SS 客户端</strong> 来连接代理。具体的本文就不细说了，搭建示例可以看 <a href="https://github.com/anyesu/SSH-Tunnel/tree/master/client-side">这里</a> 对应的 <strong>compose</strong> 文件。</p>
</li>
</ol>
</li>
<li>
<p><strong>终端工具中使用代理来连接云服务器</strong><br>
这里的例子使用 <strong>WinSCP</strong> , 其他工具应该也差不多: 新建站点 -&gt; 编辑 -&gt; 高级 -&gt; 连接</p>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/5062c27193a9db0cb9916c7442cdb3964059c9bc/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623630353338663166333964633033362e706e67"><img src="https://camo.githubusercontent.com/5062c27193a9db0cb9916c7442cdb3964059c9bc/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d623630353338663166333964633033362e706e67" alt="WinSCP" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-b60538f1f39dc036.png" style="max-width:100%;"></a></p>
<ol>
<li><strong>ssh 隧道方式</strong> : 使用 <strong>跳板机J</strong> 的 <strong>9999</strong> 端口加 <strong>公司主机A</strong> 的帐号、密码、端口。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d2c924c8d5ae7fe6e00f6979e3ee1689ba741731/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d323231336635386435363937343764392e706e67"><img src="https://camo.githubusercontent.com/d2c924c8d5ae7fe6e00f6979e3ee1689ba741731/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d323231336635386435363937343764392e706e67" alt="WinSCP-ssh隧道方式" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-2213f58d569747d9.png" style="max-width:100%;"></a></p>
<ol start="2">
<li><strong>代理方式</strong> : 可以选择 <strong>SOCKS5</strong> 协议或者 <strong>HTTP</strong> 协议，和上面的配置一致即可。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/40ed8591897b8e72ff91d68535c38457a518b746/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d626236383764666461643562386330392e706e67"><img src="https://camo.githubusercontent.com/40ed8591897b8e72ff91d68535c38457a518b746/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d626236383764666461643562386330392e706e67" alt="WinSCP-代理方式" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-bb687dfdad5b8c09.png" style="max-width:100%;"></a></p>
<h3>其他问题</h3>
<hr>
<ol>
<li>SSH 连接可能会中断 ( 临时的网络拥塞、SSH 超时、中继主机重启等等 )，所以可以借助 <strong>autossh</strong> 实现自动重连来保证可靠的服务。</li>
<li>SSH 连接有 <strong>超时断开</strong> 的机制，<strong>WinSCP</strong> 有时会不断提示 <strong>断开重连</strong> ，有两种方式来维持连接：
<ol>
<li>设置 -&gt; 面板 -&gt; 远程 -&gt; 修改刷新面板间隔为 30s 或者更短</li>
<li>session 设置 -&gt; 高级 -&gt; 连接 -&gt; keepalives -&gt; 执行哑命令 ( 空 SSH 包是没效果的 )</li>
</ol>
</li>
<li><strong>Win10 1803</strong> 已经默认集成了 <strong>SSH 工具</strong> ，可以直接使用上面的命令。当然也可以借助终端工具来建立 <strong>SSH 隧道</strong> ，比如在 <a href="https://blog.csdn.net/u010520552/article/details/80823953" rel="nofollow"><code>MobaXterm</code></a> 上可以使用图形界面进行设置，比较直观。</li>
<li>文中的方法使用 <strong>两级代理三次转发 ( 如果在 docker 中运行那就是四次转发 )</strong> 实现不同网络的访问，中间代理层的 <strong>带宽</strong> 就限制了整体的访问速度，需要注意下。</li>
<li><strong>跳板机</strong> 提供的 <strong>SOCKS5</strong> 代理服务没有密码，如果被别人知道了 <strong>IP</strong> 和端口容易被恶意攻击，所以一定要做好安全措施 ( 比如: <strong>安全组</strong> 或 <strong>防火墙</strong> 限制 <strong>跳板机</strong> 的入网 <strong>IP</strong> 为自己指定的 <strong>IP</strong> ) 。</li>
<li>你公司其他同事也想连你家里的电脑？总不能把 <strong>跳板机</strong> 暴露给他吧，太不安全了，你本地再开一层代理，让他用你的电脑作为代理好了。</li>
</ol>
<h3>仓库</h3>
<hr>
<p>基于 <strong>docker-compose</strong> 运行的完整配置已经上传至 <a href="https://github.com/anyesu/SSH-Tunnel">GitHub</a> 。</p>
<h3>参考文章</h3>
<hr>
<ul>
<li><a href="https://www.cnblogs.com/fbwfbi/p/3702896.html" rel="nofollow">SSH隧道技术----端口转发，socket代理</a></li>
<li><a href="https://linux.cn/article-8945-1.html" rel="nofollow">通过 SSH 实现 TCP / IP 隧道（端口转发）：使用 OpenSSH 可能的 8 种场景</a></li>
<li><a href="https://www.cnblogs.com/wangkongming/p/4124945.html" rel="nofollow">winScp如何通过隧道代理进行远程连接</a></li>
<li><a href="https://github.com/caojx-git/learn/blob/master/notes/linux/ssh%20tunnel%20%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F_2.md">ssh tunnel 三种模式</a></li>
<li><a href="https://www.ssh.com/ssh/tunneling/" rel="nofollow">SSH Tunnel | SSH.COM</a></li>
<li><a href="https://www.ssh.com/ssh/tunneling/example" rel="nofollow">SSH port forwarding - Example, command, server config | SSH.COM</a></li>
</ul>
<h3>吐槽</h3>
<hr>
<p>发布文章还会莫名其妙被锁定，也是醉了。好像是出现 <strong>SS 服务</strong> 的全称就会被封，要了解更多相关内容的自己去 <code>GitHub</code> 搜索 <a href="https://github.com/search"><code>SS/SS-windows</code></a> ( SS 替换为全称 ) 。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/388a93b1e7f7">https://www.jianshu.com/p/388a93b1e7f7</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-13a032857b53013b.jpg" length="0" type="image/jpg"/>
        </item>
        <item>
            <title><![CDATA[记一次 win10 下的内存泄漏分析]]></title>
            <link>https://anyesu.github.io/blog/articles/18</link>
            <guid>18</guid>
            <pubDate>Sat, 27 Jul 2019 10:53:39 GMT</pubDate>
            <description><![CDATA[前言 在上回 SVN 项目迁移到 Git 的过程中遇到了内存泄漏的问题，本文就这个问题做一次分析和记录。 第一回合 之前对迁移过程做了大量测试，觉得都没问题了，就把项目带回家准备利用周末的时间来迁移，下周其他同事就可以正常提交代码而不用耽误太多时间了。 当然，回家后不会立即开始迁移，先做点正事。迁移的时候电脑应该专心点，免得出现什么未知问题，所以睡觉前开始挂机，醒来估计差不多就好了。嗯，想法很美好]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在上回 <a href="https://www.jianshu.com/p/5dcf658851f7" rel="nofollow">SVN 项目迁移到 Git</a> 的过程中遇到了内存泄漏的问题，本文就这个问题做一次分析和记录。</p>
<h3>第一回合</h3>
<hr>
<p>之前对迁移过程做了大量测试，觉得都没问题了，就把项目带回家准备利用周末的时间来迁移，下周其他同事就可以正常提交代码而不用耽误太多时间了。</p>
<p>当然，回家后不会立即开始迁移，先做点正事。迁移的时候电脑应该专心点，免得出现什么未知问题，所以睡觉前开始挂机，醒来估计差不多就好了。嗯，想法很美好。</p>
<p>第二天起来，准备收割胜利的果实，结果发现电脑死机了 ( 鼠标虽然还能动，但是点啥都没反应，键盘也毫无响应 ) ，无奈之下只好按电源强制关机了。</p>
<h3>第二回合</h3>
<hr>
<p>想起来挂机的时候同时开了两个任务 ( <code>git subtree</code> 和 <code>git filter-branch</code> )，会不会是这两个任务冲突了？那就一个一个执行吧，重新开始挂机，出门去。</p>
<p>晚上回来之后，电脑 "<strong>不负所托</strong>" 又死机了。</p>
<h3>第三回合</h3>
<hr>
<p>前两次死机的时候我都不在现场，如果我盯着它，干活应该能认真点？强制关机，再次开启任务，打开任务管理器，我倒要看看是什么原因导致的。</p>
<p>开始之后，<strong>CPU</strong> 开始飙升，查看进程发现竟然不是 <strong>Git</strong> 而是 <strong>电脑管家的实时防护服务</strong> ，喧宾夺主了吧。想关掉这个服务，试了各种方法都关不掉，最后干脆直接卸载。</p>
<p>卸载完 <strong>电脑管家</strong> ，重新开始任务。结果 <strong>CPU</strong> 还是飙升，这回是 <strong>win10</strong> 自带的 <strong>Windows Defender</strong> ，同理禁用掉。( 后来发现，这两个软件应该是对 <strong>Git</strong> 产生的大量文件进行扫描，虽然会占用一些 <strong>CPU</strong> ，但是并没有太大影响，所以不必禁用 )</p>
<p>重新开始，<strong>CPU</strong> 正常了，接下来就是慢慢等待了。半小时,一小时... 一切还算正常，不过内存占用有点上升。按照任务已完成的进度和增长的内存，粗粗算了一下，发现内存根本坚持不到任务结束的那一刻。果然，几个小时之后，内存就满了，磁盘利用率开始飙升，然而任务还有一大半没完成，而且速度越来越慢，不过电脑还能正常使用。继续等待，一个小时后，不出意外，终于死机了。</p>
<h3>问题分析</h3>
<hr>
<p>通过上面的试验可以确认，死机的原因是 <strong>内存泄漏</strong> 了，但是什么原因导致 <strong>内存泄漏</strong> 还无法得知。</p>
<p>下面给出本次迁移使用的机器配置</p>
<table role="table">
<thead>
<tr>
<th>机器</th>
<th>系统</th>
<th>配置</th>
<th>测试结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>公司的闲置笔记本 ( A )</td>
<td>win10 1703</td>
<td>i5 8G</td>
<td>正常执行迁移任务，不存在内存泄漏</td>
</tr>
<tr>
<td>公司的工作笔记本 ( B )</td>
<td>win10 1803</td>
<td>i5 8G</td>
<td>内存泄漏</td>
</tr>
<tr>
<td>家里的笔记本 ( C )</td>
<td>win10 1709</td>
<td>i5 8G</td>
<td>内存泄漏</td>
</tr>
</tbody>
</table>
<p>既然有一台电脑是正常的，那就可以排除操作系统的问题了，对比下闲置电脑和我日常使用的电脑有哪些差异 ( 系统配置，安装的第三方软件等等 ) 。</p>
<ol>
<li>
<p>首先注意到电脑 A 的虚拟内存配置和其他两台电脑不太一样，那就调成一样或者关掉虚拟内存试试。结果内存还是会泄漏，不过内存用满了之后任务就因为内存不足自动结束了，也就不会死机了。到这一步可得知死机的原因是 <strong>物理内存耗尽后，大量使用磁盘虚拟出来的内存</strong> ，但是还没从根源上找到内存泄漏的原因。</p>
</li>
<li>
<p>对比任务管理器中的运行的服务，一个个关掉后测试，有点费劲费时 ( 这真是个笨方法，后来想到重启进入 <strong>安全模式</strong> 测一遍就好了 ) 。忽然注意到，前面提到的 <strong>电脑管家的实时防护服务</strong> 和 <strong>Windows Defender</strong> 会占用较多的 <strong>CPU</strong> ，那么和它们类似的 <strong>扫描类/底层拦截类</strong> 的软件也很有嫌疑。这回把目标瞄准 <strong>ADSafe</strong> 这个广告拦截软件，禁用服务，再次开启迁移任务。等待了一个小时，内存竟然没有增长，看来 <strong>真凶</strong> 就是它了。</p>
</li>
</ol>
<h3>问题复现</h3>
<hr>
<p>先上截图，看下开启 <strong>ADSafe</strong> 时的资源使用情况</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/6e337d1c256bd8ee2e1163783ad956ee528aed37/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d306463393933663464376330663266372e706e67"><img src="https://camo.githubusercontent.com/6e337d1c256bd8ee2e1163783ad956ee528aed37/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d306463393933663464376330663266372e706e67" alt="开机后刚开始执行任务" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-0dc993f4d7c0f2f7.png" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/e10ea1c28067d96411b7ae7546d12bc8e3015a40/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326235393666346633386535336464632e706e67"><img src="https://camo.githubusercontent.com/e10ea1c28067d96411b7ae7546d12bc8e3015a40/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326235393666346633386535336464632e706e67" alt="任务运行半小时后" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-2b596f4f38e53ddc.png" style="max-width:100%;"></a></p>
<p>对比前面两张图看下半小时的数据差异：</p>
<ol>
<li>资源管理器中 <strong>使用中</strong> 增长 <strong>2.1 G</strong>，<strong>已提交</strong> 增长 <strong>2.9 G</strong></li>
<li>资源监视器中 <strong>可用</strong> 的内存几乎都转为 <strong>正在使用</strong></li>
<li><strong>RAMMap</strong> 中 <strong>进程私有</strong> 增长 <strong>100 M</strong>，<strong>映射文件</strong> 增长 <strong>1 G</strong>，<strong>页表</strong> 增长 <strong>1.2 G</strong></li>
</ol>
<p>可以发现进程并没有泄露内存，<strong>映射文件</strong> 占用的内存不用太在意，唯一异常的地方在于 <strong>页表</strong> 这一项。</p>
<p>再上一张 <strong>RAMMap</strong> 中进程标签页下的截图</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/98914026fce0c9a59ed86c293f71bd62624f3506/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613838316331663130383664663732342e706e67"><img src="https://camo.githubusercontent.com/98914026fce0c9a59ed86c293f71bd62624f3506/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613838316331663130383664663732342e706e67" alt="RAMMap 中进程标签页" data-canonical-src="https://upload-images.jianshu.io/upload_images/1836534-a881c1f1086df724.png" style="max-width:100%;"></a></p>
<p>可以看到大量的进程，<strong>PID</strong> 由最初的 <strong>1 W+</strong> 增长到了 <strong>18 W+</strong> ，而且这些进程大部分在任务管理器是不存在的 ( 即进程已结束 ) 。粗粗统计了下，大约有 <strong>46000</strong> 个进程 ( <code>sh.exe/git.exe/cat.exe</code> ) ，每个占用 <strong>28 KB</strong> ，合计大约有 <strong>1.22 G</strong> ，正好和上面的 <strong>页表</strong> 内存增长量相吻合，所以应该是这部分内存无法回收利用导致的内存泄漏 ( 这估计是系统的 <strong>bug</strong> ，进程结束应该释放页表占用的内存才对 ) 。<a href="https://social.technet.microsoft.com/Forums/msonline/en-US/69879cec-902c-424a-b391-4e9d7aea5385/windows2008r2-sp1?forum=WinServerPreviewZHCN#176e3b01-610b-4b54-8faf-efecb4854a39" rel="nofollow">类似情况</a></p>
<p>关掉 <strong>ADSafe</strong> 后再次试验，<code>sh.exe/git.exe/cat.exe</code> 进程数虽然也增加了几十个，但是和前面的 <strong>4 W+</strong> 比起来完全不是一个数量级。</p>
<h3>结论</h3>
<hr>
<p>通过上面测试，可以定位到内存泄漏的根源: <strong>ADSafe</strong> 和 <strong>Git</strong> 有所冲突，导致 <strong>Git</strong> 不断创建新的进程。至于是什么冲突那就无法得知了，和 <strong>ADSafe</strong> 说拜拜就好了。</p>
<h3>拓展知识</h3>
<hr>
<h5>1. 文中用到的内存分析工具: <code>RAMMap</code> 、<code>VMMap</code> 、<code>AIDA64 Extreme</code></h5>
<h5>2. 关于任务管理器中的内存指标:</h5>
<blockquote>
<p><strong>使用中</strong> : 进程使用的内存大小，内存使用率就是用这个值计算的，实际上这个值并没有太大意义。<br>
<strong>已提交 ( 已用 )</strong> : 所有程序真正占用的内存，当这个值接近或者超过物理内存大小的时候，电脑基本已经开始变卡了，因为这时候已经开始使用磁盘所虚拟出来的内存，想想内存和磁盘的读写速度就知道了。<br>
<strong>已提交 ( 总 )</strong> : 也就是 <strong>虚拟内存</strong>，等于 <strong>物理内存</strong> + <strong>系统盘下 pagefile.sys 文件的大小</strong></p>
<p>关于 <strong>使用中</strong> 和 <strong>已提交</strong> 的区别，我的理解: 一个进程向操作系统申请了 <strong>1 G</strong> 的内存，那么这些内存就都归这个进程使用，虽然它现在只使用了 <strong>200 M</strong>，但剩下 <strong>800 M+</strong> 应该为这个进程保留，而不能拿去给别的进程使用，这个例子中 <strong>已提交</strong> 就是 <strong>1 G</strong> ，<strong>使用中</strong> 是 <strong>200 M</strong>，两者之差可以反映出程序的内存利用率。</p>
</blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/43714216/answer/96359711" rel="nofollow">Windows 8或者Windows10的任务管理器中，内存已提交的两个数字都是什么意思?</a></li>
<li><a href="https://www.zhihu.com/question/19828627/answer/133877436" rel="nofollow">Win 7 “已修改”内存占了几 G ，怎么才能让它自动释放？</a></li>
<li><a href="http://shashanzhao.com/archives/832.html" rel="nofollow">windows任务管理器中的工作设置内存,内存专用工作集,提交大小详解</a></li>
</ul>
<h5>3. 是否应该禁用 "虚拟内存" ( pagefile.sys )？</h5>
<p>个人不建议禁用。比如我平时工作时，开一个 <strong>IDEA</strong> 再把工作项目都启动，基本上 <strong>8 G</strong> 的内存都用完了，这时如果我再开个 <strong>Chrome</strong> 就要用到 <strong>虚拟内存</strong> 了，内存再挤一点用一点。但是如果我禁用了 <strong>虚拟内存</strong> ，就会提示 <strong>内存不足</strong> 导致程序崩溃，或者需要关闭 <strong>其他使用中的程序</strong> 腾出内存才能打开新的程序。<strong>虚拟内存</strong> 的意义在于：<strong>物理内存</strong> 不足的时候使用磁盘来代替内存，虽然会卡一点，但是能满足使用所需 ( 就是要开这么多程序 ) 。同样的，<strong>内存不足</strong> 根本解决办法应该是 <strong>加内存并且少开程序</strong> 而不是一味的加大 <strong>虚拟内存</strong> 。</p>
<h5>4. 关于 RAMMap 中的指标</h5>
<p>按照我的经验，<strong>剩余可用内存</strong> 基本上等于 <strong>映射文件 ( 备用 )</strong> + <strong>未使用 ( 归零 + 可用 )</strong> 。如果开启了 <strong>Superfetch</strong> 服务，系统会把一些常用的文件读取到内存 ( <strong>映射文件</strong> ) 中，这样程序中用到这些文件的时候就能更快的读取，这部分内存在 <strong>内存不足</strong> 的时候是可以拿来给其他进程使用。</p>
<ul>
<li><a href="https://www.cnblogs.com/tudoux/p/4634888.html" rel="nofollow">内存查看工具RAMMAP说明</a></li>
<li><a href="http://www.cnblogs.com/georgepei/archive/2012/03/07/2383548.html" rel="nofollow">内存详解</a></li>
</ul>
<h5>5. 关于页表</h5>
<p>对于页表我也不了解，页表应该就是一个目录结构，保存 <strong>内存地址映射关系</strong>，通过它程序能把 <strong>逻辑地址</strong> 转为 <strong>实际的物理地址</strong> 。</p>
<ul>
<li><a href="https://www.zhihu.com/question/50796850" rel="nofollow">怎样通俗的理解操作系统中内存管理分页和分段？</a></li>
<li><a href="https://blog.csdn.net/chluknight/article/details/6689323" rel="nofollow">内存分页大小对性能的提升原理</a></li>
<li><a href="http://www.mamicode.com/info-detail-1289630.html" rel="nofollow">操作系统内存管理之 分页与虚存（页表、页框、内存）</a></li>
<li><a href="https://blog.csdn.net/iawes/article/details/50915975" rel="nofollow">页表到底占用多少空间？一些疑惑和思考</a></li>
</ul>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/7510e57aeaff">https://www.jianshu.com/p/7510e57aeaff</a></h4>]]></content:encoded>
            <enclosure url="https://upload-images.jianshu.io/upload_images/1836534-0dc993f4d7c0f2f7.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[SVN 项目迁移到 Git]]></title>
            <link>https://anyesu.github.io/blog/articles/17</link>
            <guid>17</guid>
            <pubDate>Sat, 27 Apr 2019 18:24:30 GMT</pubDate>
            <description><![CDATA[前言 最近刚把公司项目从 SVN 迁移到了 Git 上，在这里做个记录。 数据迁移 # 检出空项目proj svn co --depth=empty --username=user svn://url proj # 进入proj目录 cd proj # 获取user列表 echo '(no author) = no_author <no_author@no_author>' > ../users.]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>最近刚把公司项目从 <strong>SVN</strong> 迁移到了 <strong>Git</strong> 上，在这里做个记录。</p>
<h3>数据迁移</h3>
<hr>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 检出空项目proj</span>
svn co --depth=empty --username=user svn://url proj

<span class="pl-c"><span class="pl-c">#</span> 进入proj目录</span>
<span class="pl-c1">cd</span> proj

<span class="pl-c"><span class="pl-c">#</span> 获取user列表</span>
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>(no author) = no_author &lt;no_author@no_author&gt;<span class="pl-pds">'</span></span> <span class="pl-k">&gt;</span> ../users.txt
svn log ^/ --xml <span class="pl-k">|</span> grep -P <span class="pl-s"><span class="pl-pds">"</span>^&lt;author<span class="pl-pds">"</span></span> <span class="pl-k">|</span> sort -u <span class="pl-k">|</span> perl -pe <span class="pl-s"><span class="pl-pds">'</span>s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = $1 &lt;$1\@email.com&gt;/<span class="pl-pds">'</span></span> <span class="pl-k">&gt;&gt;</span> ../users.txt

<span class="pl-c"><span class="pl-c">#</span> 对users.txt进行编辑 替换用户名和邮箱内容</span>

<span class="pl-c1">cd</span> ../ <span class="pl-k">&amp;&amp;</span> rm -rf proj

<span class="pl-c"><span class="pl-c">#</span> 检出svn r1版本到最新版本的数据</span>
git svn clone -r1:HEAD svn://url --username=user --no-metadata --authors-file=users.txt proj</pre></div>
<p>执行上面的步骤就可以将 <strong>SVN</strong> 项目导出到本地 <strong>Git</strong> 仓库了。不过，一般项目比较大导出时间会比较长，可以中断 <code>git svn clone</code> 操作，采用下面的命令分段迁移，避免长时间运行把电脑弄卡或者死机：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 进入proj目录</span>
<span class="pl-c1">cd</span> proj

<span class="pl-c"><span class="pl-c">#</span> 更新远程分支 git-svn </span>
git svn fetch

<span class="pl-c"><span class="pl-c">#</span> 合并远程分支 git-svn 到 master 分支</span>
git merge git-svn

<span class="pl-c"><span class="pl-c">#</span> 如果迁移过程中svn地址有变动，可以修改 .git/config 文件中对应的url</span>
</pre></div>
<p>这里说一个迁移的细节，可以提早进行 <code>git svn clone</code> 操作，在下班的时候 <code>git svn fetch</code> 快速更新到最新版本然后停掉 <strong>SVN</strong> 服务器。</p>
<h3>多模块项目拆分</h3>
<hr>
<p>我们的项目是一个 <strong>maven</strong> 多模块项目，原先在 <strong>SVN</strong> 下可以给不同的人开放不同子模块的权限，而 <strong>Git</strong> 无法做到目录级权限控制，所以能想到的解决办法就是拆拆拆。不过，我们项目的子模块比较多 ( 20 多个 )，全拆感觉会要命，就简单拆成前端和后端两个仓库吧。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1. 将子模块 [module1] 拆分为新的分支 module1</span>
git subtree split -P module1 -b module1

<span class="pl-c"><span class="pl-c">#</span> 2. 清理 master 分支中包含子模块 [module1] 的内容</span>
git filter-branch -f --index-filter <span class="pl-s"><span class="pl-pds">"</span>git rm -rf --cached --ignore-unmatch module1<span class="pl-pds">"</span></span> --prune-empty master

<span class="pl-c"><span class="pl-c">#</span> 3. 将子模块推送到新仓库的master分支</span>
git push http://gitlab/module1.git module1:master</pre></div>
<p>需要深入使用 <strong>subtree</strong> 可以参考下面的步骤，不过个人认为 <strong>subtree</strong> 的引用在日常开发中不是很方便，还不如工作空间下引入多个项目。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 4. 父模块引入新的仓库作为子模块</span>
git subtree add --prefix=module1 http://gitlab/module1.git master

<span class="pl-c"><span class="pl-c">#</span> 5. 父模块中 pull 子模块的数据</span>
git subtree pull --prefix=module1 http://gitlab/module1.git master

<span class="pl-c"><span class="pl-c">#</span> 6. 父模块向子模块 push</span>
git subtree push --prefix=module1 http://gitlab/module1.git master</pre></div>
<h3>遇到的问题</h3>
<hr>
<ul>
<li>
<p><strong>耗时</strong><br>
<code>git svn clone</code> , <code>git subtree split</code> , <code>git filter-branch</code> 这三个步骤非常的耗时间，需要合理安排时间, 中途要经常备份。我们的项目有 <strong>3w+</strong> 的 <strong>commits</strong> ，在 <strong>i5 8g</strong> 的 <strong>win10</strong> 上耗时分别为 <strong>30 h</strong>, <strong>2 h</strong>, <strong>10 h</strong>，迁移后项目大小 <strong>300 M</strong> 。中途遇到过 <strong>蓝屏重启后索引错乱需要重头再来</strong>、<strong>内存泄漏导致死机</strong> ( <a href="https://www.jianshu.com/p/7510e57aeaff" rel="nofollow">单独开篇讲</a> )、<strong>SVN 服务器经常断开连接</strong> 等等问题。</p>
</li>
<li>
<p><strong>空目录</strong><br>
迁移后，原先的空目录会被删除，如果需要保持原有目录结构，可以在空目录下添加占位文件并提交到 <strong>SVN</strong> 上，之后再导入 <strong>Git</strong> 。参考 <a href="https://blog.csdn.net/fengchao2016/article/details/52769151" rel="nofollow">git 提交空文件夹</a> 。</p>
</li>
<li>
<p><strong>换行符的问题</strong><br>
在 <strong>SVN</strong> 上这个不算什么大问题，迁移到了 <strong>Git</strong> 上之后就成了大问题，因为有 <strong>autocrlf</strong> 这个配置项。一般人安装 <strong>Git</strong> 的时候要么选择默认设置，要么被网上的文章误导一顿操作结果越设置越乱。解决方法：</p>
</li>
</ul>
<blockquote>
<p>源码在仓库中统一用 LF 格式保存<br>
在 Mac 上设置 autocrlf = input ( 检出的时候不转换，提交的时候自动转成 LF )<br>
在 Windows 上设置 autocrlf = true ( 检出的时候自动转成 CRLF , 提交的时候自动转成 LF )</p>
</blockquote>
<p>我们的项目比较可怕，是 <strong>CRLF</strong> 文件和 <strong>LF</strong> 文件混合的，可以采用下面的命令批量替换，然后提交到 <strong>SVN</strong> 上。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 修改svn项目的换行符(linux下或者进入git-bash执行)</span>
find <span class="pl-c1">.</span> -type f -print -o -path ./.svn -prune <span class="pl-k">|</span> xargs dos2unix -k</pre></div>
<p>对了，迁移完最好使用 <strong>Beyond Compare 4</strong> 这样的工具对比下。</p>
<ul>
<li><strong>其他问题</strong>
<ul>
<li>迁移用的 <strong>SVN</strong> 帐号最好有所有目录的权限</li>
<li><strong>users.txt</strong> 中加一行 <code>(no author) = no_author &lt;no_author@no_author&gt;</code></li>
<li>最好用 <strong>Linux</strong> 服务器迁移，耗时能从以 <strong>小时</strong> 为单位提升到以 <strong>分钟</strong> 为单位，而且可以同时进行多个项目的迁移。</li>
</ul>
</li>
</ul>
<h3>参考</h3>
<hr>
<ul>
<li><strong><a href="https://blog.csdn.net/xueshanhaizi/article/details/54929365" rel="nofollow">SVN 迁移到 git</a></strong></li>
<li><strong><a href="https://segmentfault.com/a/1190000002548731" rel="nofollow">Git 仓库拆拆拆</a></strong></li>
<li><strong><a href="https://typecodes.com/mix/gitsubtree1.html" rel="nofollow">Git 多仓库作子目录的双向同步：一次 Git Subtree 的实践</a></strong></li>
<li><strong><a href="https://blog.csdn.net/cjf_iceking/article/details/47836201" rel="nofollow">Windows 文件换行符转 Linux 换行符</a></strong></li>
</ul>
<hr>
<h3>结语</h3>
<hr>
<p>整个迁移步骤就上面简单的几步就好了，剩下的就是把本地仓库 <strong>push</strong> 到远程仓库 ( 如 <strong>gitlab</strong> ) 中即可，至于其他的坑各位自行体验吧。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/5dcf658851f7">https://www.jianshu.com/p/5dcf658851f7</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Docker Stack 部署多服务集群]]></title>
            <link>https://anyesu.github.io/blog/articles/16</link>
            <guid>16</guid>
            <pubDate>Sat, 27 Apr 2019 17:48:07 GMT</pubDate>
            <description><![CDATA[前言 单机模式下，我们可以使用 Docker Compose 来编排多个服务，而在 上一篇文章 中介绍的 Docker Swarm 只能实现对单个服务的简单部署。于是就引出了本文的主角 Docker Stack ，通过 Docker Stack 我们只需对已有的 docker-compose.yml 配置文件稍加改造就可以完成 Docker 集群环境下的多服务编排。 正文 首先创建一个 docke]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>单机模式下，我们可以使用 <a href="https://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">Docker Compose</a> 来编排多个服务，而在 <a href="https://www.jianshu.com/p/47fa426ff767" rel="nofollow">上一篇文章</a> 中介绍的 <strong>Docker Swarm</strong> 只能实现对单个服务的简单部署。于是就引出了本文的主角 <strong>Docker Stack</strong> ，通过 <strong>Docker Stack</strong> 我们只需对已有的 <strong>docker-compose.yml</strong> 配置文件稍加改造就可以完成 <strong>Docker</strong> 集群环境下的多服务编排。</p>
<h3>正文</h3>
<hr>
<ul>
<li>
<p>首先创建一个 <strong>docker-compose.yml</strong> 文件，使用 <a href="https://docs.docker.com/compose/compose-file/#deploy" rel="nofollow">Docker Compose v3</a> 语法</p>
<p>内容比较简单，一个有四个实例的 <strong>nginx</strong> 服务，两个只部署在 <strong>manager</strong> 节点上的单实例监控工具服务：<a href="https://portainer.io" rel="nofollow">portainer</a> 和 <a href="https://github.com/dockersamples/docker-swarm-visualizer">visualizer</a></p>
</li>
</ul>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">version</span>: <span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>

<span class="pl-ent">services</span>:
  <span class="pl-ent">nginx</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">nginx:alpine</span>
    <span class="pl-ent">ports</span>:
      - <span class="pl-c1">80:80</span>
    <span class="pl-ent">deploy</span>:
      <span class="pl-ent">mode</span>: <span class="pl-s">replicated</span>
      <span class="pl-ent">replicas</span>: <span class="pl-c1">4</span>

  <span class="pl-ent">visualizer</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">dockersamples/visualizer</span>
    <span class="pl-ent">ports</span>:
      - <span class="pl-s"><span class="pl-pds">"</span>9001:8080<span class="pl-pds">"</span></span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s"><span class="pl-pds">"</span>/var/run/docker.sock:/var/run/docker.sock<span class="pl-pds">"</span></span>
    <span class="pl-ent">deploy</span>:
      <span class="pl-ent">replicas</span>: <span class="pl-c1">1</span>
      <span class="pl-ent">placement</span>:
        <span class="pl-ent">constraints</span>: <span class="pl-s">[node.role == manager]</span>

  <span class="pl-ent">portainer</span>:
    <span class="pl-ent">image</span>: <span class="pl-s">portainer/portainer</span>
    <span class="pl-ent">ports</span>:
      - <span class="pl-s"><span class="pl-pds">"</span>9000:9000<span class="pl-pds">"</span></span>
    <span class="pl-ent">volumes</span>:
      - <span class="pl-s"><span class="pl-pds">"</span>/var/run/docker.sock:/var/run/docker.sock<span class="pl-pds">"</span></span>
    <span class="pl-ent">deploy</span>:
      <span class="pl-ent">replicas</span>: <span class="pl-c1">1</span>
      <span class="pl-ent">placement</span>:
        <span class="pl-ent">constraints</span>: <span class="pl-s">[node.role == manager]</span></pre></div>
<ul>
<li>部署服务</li>
</ul>
<div class="highlight highlight-source-shell"><pre>$ docker stack deploy -c docker-compose.yml stack-demo</pre></div>
<ul>
<li>部署成功之后查看详情</li>
</ul>
<div class="highlight highlight-source-shell"><pre>$ docker stack services stack-demo 
ID                  NAME                    MODE                REPLICAS            IMAGE                             PORTS
4yb35ywqvo49        stack-demo_portainer    replicated          1/1                 portainer/portainer:latest        <span class="pl-k">*</span>:9000-<span class="pl-k">&gt;</span>9000/tcp
mzd2volqug28        stack-demo_nginx        replicated          4/4                 nginx:alpine                      <span class="pl-k">*</span>:80-<span class="pl-k">&gt;</span>80/tcp
r0zlzpp3wujg        stack-demo_visualizer   replicated          1/1                 dockersamples/visualizer:latest   <span class="pl-k">*</span>:9001-<span class="pl-k">&gt;</span>8080/tcp</pre></div>
<ul>
<li>在浏览器中访问监控工具，对应端口如下：</li>
</ul>
<pre><code>portainer  ——→ ip:9000
visualizer ——→ ip:9001
</code></pre>
<p><strong>注意：如果有多个 manager 节点，portainer 和 visualizer 可能分别部署在两台机器上，所以ip可能会不一样。</strong></p>
<ul>
<li>修改 <strong>docker-compose.yml</strong> 文件后重新部署即可完成对修改内容的更新</li>
</ul>
<div class="highlight highlight-source-shell"><pre>$ docker stack deploy -c docker-compose.yml stack-demo</pre></div>
<h3>关于负载均衡</h3>
<hr>
<p>评论区有小伙伴提到，容器间通过服务名 ( 比如文中的 <strong>nginx</strong> ) 通讯时，对应的 <strong>IP</strong> 却和容器的实际 <strong>IP</strong> 对不上。出现这个情况是因为负载均衡（ 对外表现为一个服务，内部为多个服务 ）。下面是我做的试验，希望能帮助大家理解。</p>
<ol>
<li>
<p>按上面的配置启动集群 ( 由两台服务器构成 )</p>
</li>
<li>
<p>在 <strong>manager</strong> 节点服务器中看下运行的服务</p>
<div class="highlight highlight-source-shell"><pre>$ docker ps
CONTAINER ID IMAGE NAMES
9b96f07bbb91 dockersamples/visualizer:latest stack-demo_visualizer.1.p5hy7gsc50vbm0wkxm1c17rl6
942dd34d024e nginx:alpine stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz
706ae42e0089 nginx:alpine stack-demo_nginx.2.vnlmlky5m5qy7l8qxq6k5nllk
6dba55dd7d63 portainer/portainer:latest stack-demo_portainer.1.yv76gf0i7gou2awen44kshm1j</pre></div>
</li>
<li>
<p>在这台服务器上启动了两个 <strong>nginx</strong> 容器实例，随便进一个实例看下 <strong>IP</strong></p>
<div class="highlight highlight-source-shell"><pre>$ docker <span class="pl-c1">exec</span> -it stack-demo_nginx.2.vnlmlky5m5qy7l8qxq6k5nllk ifconfig
eth0 Link encap:Ethernet HWaddr 02:42:0A:FF:00:3E
inet addr:10.255.0.62 Bcast:10.255.255.255 Mask:255.255.0.0
eth1 Link encap:Ethernet HWaddr 02:42:0A:00:06:07
inet addr:10.0.6.7 Bcast:10.0.6.255 Mask:255.255.255.0
eth2 Link encap:Ethernet HWaddr 02:42:AC:13:00:04
inet addr:172.19.0.4 Bcast:172.19.255.255 Mask:255.255.0.0
lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0</pre></div>
<p>发现容器中绑了3个网卡 <strong>eth0</strong> 、<strong>eth1</strong> 、<strong>eth2</strong> ，我猜想分别对应 <strong>整个 Swarm 集群的局域网</strong>、<strong>当前 Stack 集群的局域网</strong> 、<strong>当前主机下 Compose 服务的局域网</strong> 三个网络。</p>
</li>
<li>
<p>查看当前主机下的 <strong>docker</strong> 网络</p>
<div class="highlight highlight-source-shell"><pre>$ docker network ls
NETWORK ID NAME DRIVER SCOPE
bd4fa8219483 bridge bridge <span class="pl-k">local</span>
e51735fef0d6 docker_gwbridge bridge <span class="pl-k">local</span>
26360437865a host host <span class="pl-k">local</span>
yvupj4ex3odl ingress overlay swarm
f0a0190c3b1f none null <span class="pl-k">local</span>
oft930l7jpdn stack-demo_default overlay swarm</pre></div>
</li>
<li>
<p>上一步看到有两个 <strong>swarm</strong> 的网络，进去看下具体信息</p>
<div class="highlight highlight-source-json"><pre>$ docker network inspect ingress
<span class="pl-s"><span class="pl-pds">"</span>IPAM<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>Config<span class="pl-pds">"</span></span>: [
        {
            <span class="pl-s"><span class="pl-pds">"</span>Subnet<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.0/16<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>Gateway<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.1<span class="pl-pds">"</span></span>
        }
    ]
},
<span class="pl-s"><span class="pl-pds">"</span>Containers<span class="pl-pds">"</span></span>: {
    <span class="pl-s"><span class="pl-pds">"</span>6dba55dd7d63f7166e2e0ee3afed8e427089b7140d62f39a835d3145a058b868<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>stack-demo_portainer.1.yv76gf0i7gou2awen44kshm1j<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.59/16<span class="pl-pds">"</span></span>,
    },
    <span class="pl-s"><span class="pl-pds">"</span>706ae42e00890444087aa6d51ccb966b76b5ad4c985b48fdf5215c192bcf0836<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>stack-demo_nginx.2.vnlmlky5m5qy7l8qxq6k5nllk<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.62/16<span class="pl-pds">"</span></span>,
    },
    <span class="pl-s"><span class="pl-pds">"</span>942dd34d024e218aad4e5034e1194a2cfa1d9be81a839ec86403cf237d41368b<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.64/16<span class="pl-pds">"</span></span>,
    },
    <span class="pl-s"><span class="pl-pds">"</span>9b96f07bbb91a570bb8d26945996d77151c5633c0a6057361ab4474b393da364<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>stack-demo_visualizer.1.p5hy7gsc50vbm0wkxm1c17rl6<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.66/16<span class="pl-pds">"</span></span>,
    },
    <span class="pl-s"><span class="pl-pds">"</span>ingress-sbox<span class="pl-pds">"</span></span>: {
        <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>ingress-endpoint<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.255.0.2/16<span class="pl-pds">"</span></span>,
    }
}</pre></div>
<p>内容太多就省略其他无关内容了，从上面的信息已经可以证明第三步的猜想了 ( <strong>ingress</strong> 对应 <strong>Swarm 集群</strong> , <strong>stack-demo_default</strong> 对应 <strong>Stack 集群</strong> ) ，要进一步确认可以再看下另一台服务器上的网络。</p>
</li>
<li>
<p>通过容器 <strong>nginx.4</strong> 使用服务名的方式 <strong>ping</strong> 一下 <strong>nginx</strong></p>
<div class="highlight highlight-source-shell"><pre>$ docker <span class="pl-c1">exec</span> -it stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz ping nginx
PING nginx (10.0.6.5): 56 data bytes
64 bytes from 10.0.6.5: seq=0 ttl=64 time=0.121 ms</pre></div>
<p>发现 <strong>IP</strong> 是 <strong>10.0.6.5</strong> ，属于 <strong>stack-demo_default</strong> 网络，但是在两台服务器的 <strong>docker</strong> 网络详情里面都找不到这个实例。</p>
</li>
<li>
<p>在容器 <strong>nginx.4</strong> 中安装 <strong>curl</strong> 然后再访问 <strong>nginx</strong> 看下效果</p>
<div class="highlight highlight-source-shell"><pre>$ docker <span class="pl-c1">exec</span> -it stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz sh -c <span class="pl-s"><span class="pl-pds">'</span>echo -e "https://mirrors.ustc.edu.cn/alpine/latest-stable/main\nhttps://mirrors.ustc.edu.cn/alpine/latest-stable/community" &gt; /etc/apk/repositories &amp;&amp; apk --update add curl<span class="pl-pds">'</span></span>
$ docker <span class="pl-c1">exec</span> -it stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz curl nginx</pre></div>
<p>可以看到访问成功，再多调用几次。</p>
</li>
<li>
<p>打印 <strong>nginx</strong> 容器的日志 ( 可以多开几个终端打印日志，再访问 <strong>nginx</strong> 看下实时日志的效果，这样更直观 )</p>
<div class="highlight highlight-source-shell"><pre>$ docker logs stack-demo_nginx.2.vnlmlky5m5qy7l8qxq6k5nllk <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>---分界线---<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span> docker logs stack-demo_nginx.4.tp6u05jmg9iuookqc9i9e11kz
10.0.6.4 - - [06/Dec/2018:10:15:18 +0000] <span class="pl-s"><span class="pl-pds">"</span>GET / HTTP/1.1<span class="pl-pds">"</span></span> 200 612 <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>curl/7.60.0<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>
---分界线---
10.0.6.4 - - [06/Dec/2018:10:13:16 +0000] <span class="pl-s"><span class="pl-pds">"</span>GET / HTTP/1.1<span class="pl-pds">"</span></span> 200 612 <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>curl/7.60.0<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>
10.0.6.4 - - [06/Dec/2018:10:15:19 +0000] <span class="pl-s"><span class="pl-pds">"</span>GET / HTTP/1.1<span class="pl-pds">"</span></span> 200 612 <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>curl/7.60.0<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span></pre></div>
<p>可以看到明显的负载均衡的效果，请求都来自 <strong>10.0.6.4</strong>，它就是 <strong>stack-demo_default</strong> 网络中一个名为 <code>lb-</code> 开头的实例，它就是这个负载均衡的入口。</p>
<div class="highlight highlight-source-json"><pre><span class="pl-s"><span class="pl-pds">"</span>lb-stack-demo_default<span class="pl-pds">"</span></span>: {
	<span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>stack-demo_default-endpoint<span class="pl-pds">"</span></span>,
	<span class="pl-s"><span class="pl-pds">"</span>IPv4Address<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>10.0.6.4/24<span class="pl-pds">"</span></span>,
}</pre></div>
</li>
<li>
<p>再去另一台服务器看下 <strong>nginx</strong> 的日志</p>
<p>发现并没有访问记录，说明这个负载均衡仅限于 <strong>当前服务器</strong> 、<strong>相同服务</strong> 的 <strong>多个实例</strong>，不会跨服务器负载均衡。</p>
</li>
<li>
<p>在另一台服务器上再重复 <strong>7 &amp; 8</strong> 两个步骤</p>
<p>发现另一台服务器上不存在名为 <code>lb-</code> 开头的实例，而负载均衡的入口是其中一个普通的 <strong>nginx</strong> 实例。</p>
</li>
</ol>
<p><strong>总结下：</strong></p>
<p>整个请求的调用流程应该就是：<strong>通过服务名 nginx 访问</strong> -- 指向 --&gt; <strong>stack 集群网关 ( 10.0.6.5 )</strong> -- 转发 --&gt; <strong>stack 集群中，位于当前服务器的负载均衡实例 ( 10.0.6.4 )</strong> -- 分发 --&gt; <strong>最终的应用</strong> 。</p>
<h3>相关命令</h3>
<hr>
<table role="table">
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">docker stack deploy</td>
<td align="left">部署新的堆栈或更新现有堆栈</td>
</tr>
<tr>
<td align="left">docker stack ls</td>
<td align="left">列出现有堆栈</td>
</tr>
<tr>
<td align="left">docker stack ps</td>
<td align="left">列出堆栈中的任务</td>
</tr>
<tr>
<td align="left">docker stack rm</td>
<td align="left">删除一个或多个堆栈</td>
</tr>
<tr>
<td align="left">docker stack services</td>
<td align="left">列出堆栈中的服务</td>
</tr>
</tbody>
</table>
<h3>参考文章</h3>
<hr>
<ul>
<li><a href="https://www.cnblogs.com/xishuai/p/docker-swarm.html#docker-stack-%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A-gui-%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2" rel="nofollow">Docker 三剑客之 Docker Swarm</a></li>
</ul>
<hr>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/1db6f0150fdb">https://www.jianshu.com/p/1db6f0150fdb</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Docker Swarm 管理 Docker 集群]]></title>
            <link>https://anyesu.github.io/blog/articles/15</link>
            <guid>15</guid>
            <pubDate>Sat, 27 Apr 2019 10:21:13 GMT</pubDate>
            <description><![CDATA[前言 之前介绍了使用 Docker Compose 在一台 Docker 主机下对多服务多容器进行编排，本文来介绍使用 Docker Swarm 实现对多台 Docker 主机的集群管理。 什么是 Docker Swarm Swarm 是 Docker 公司在2014年12月初发布的一套用来管理 Docker 集群的较为简单的工具，由于 Swarm 使用标准的Docker API接口作为其前端访问]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>之前介绍了使用 <a href="https://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">Docker Compose</a> 在一台 <strong>Docker</strong> 主机下对多服务多容器进行编排，本文来介绍使用 <strong>Docker Swarm</strong> 实现对多台 <strong>Docker</strong> 主机的集群管理。</p>
<h3>什么是 Docker Swarm</h3>
<hr>
<blockquote>
<p>Swarm 是 Docker 公司在2014年12月初发布的一套用来管理 Docker 集群的较为简单的工具，由于 Swarm 使用标准的Docker API接口作为其前端访问入口，所以各种形式的Docker Client(dockerclient in go, docker_py, docker等)都可以直接与Swarm通信。老的 Docker Swarm 使用独立的外部KV存储（比如Consul、etcd、zookeeper），搭建独立运行的Docker主机集群，用户像操作单台Docker 机器一样操作整个集群，Docker Swarm 把多台 Docker 主机当做一台 Docker 主机来管理。新的 Swarm mode 是在docker 1.12版本中集成到 Docker 引擎中的，引入服务的概念，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 Swarm mode 集群具备与 Mesos、Kubernetes 叫板的实力。</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/csdn_duomaomao/article/details/73556777" rel="nofollow">Docker Swarm 和 Swarm mode 的区别</a></li>
<li>注：本文所说的 <strong>swarm</strong> 指的是 <strong>Swarm mode</strong></li>
</ul>
<h3>配置说明</h3>
<hr>
<p>有两台主机 ( <strong>主机1</strong> 、<strong>主机2</strong> ) ，都已安装 <strong>Docker</strong> 。当然也可以使用 <strong>Docker 三剑客</strong> 之一的 <strong>Docker Machine</strong> 来创建一批运行 <strong>Docker</strong> 的虚拟机。</p>
<h3>创建集群</h3>
<hr>
<p>在 <strong>主机1</strong> 上创建 <strong>swarm</strong> 集群，<strong>主机1</strong> 作为 <strong>manager</strong> 节点</p>
<div class="highlight highlight-source-shell"><pre>$ docker swarm init --listen-addr 0.0.0.0:2377 --advertise-addr 主机1的IP
Swarm initialized: current node (kwsp26dy6gwjhocl6nxbez0bu) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-1023ixl3yabjyws8tjdyvob7r40mljsu8atzsmlju18wz2itlj-br6gzae8focpm0ccpjaquz251 主机1的IP:2377

To add a manager to this swarm, run <span class="pl-s"><span class="pl-pds">'</span>docker swarm join-token manager<span class="pl-pds">'</span></span> and follow the instructions.</pre></div>
<p><strong>注意：主机1 的防火墙要开放对应的端口</strong></p>
<h3>加入集群</h3>
<hr>
<p><strong>主机2</strong> 作为 <strong>worker</strong> 节点加入上面创建的集群</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 也就是上面创建完集群提示的命令</span>
$ docker swarm join --token SWMTKN-1-1023ixl3yabjyws8tjdyvob7r40mljsu8atzsmlju18wz2itlj-br6gzae8focpm0ccpjaquz251 主机1的IP:2377
This node joined a swarm as a worker.</pre></div>
<p>当然，<strong>主机2</strong> 也可作为 <strong>manager</strong> 节点加入上面创建的集群，当 <strong>主机1</strong> 挂掉的时候它可以晋升为  <strong>Leader</strong> 。</p>
<p>在 <strong>主机1</strong> 上查询对应的 <strong>token</strong></p>
<div class="highlight highlight-source-shell"><pre>$ docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-1023ixl3yabjyws8tjdyvob7r40mljsu8atzsmlju18wz2itlj-07q9wti67nkvqixykkcbi1ge8 主机1的IP:2377</pre></div>
<p>注意：这个 <strong>token</strong> 和前面的 <strong>token</strong> 是不一样的</p>
<p>在 <strong>主机2</strong> 上执行对应的命令作为 <strong>manager</strong> 节点加入集群。可以添加 <code>--listen-addr</code> 和 <code>--advertise-addr</code> 选项 ( 同创建集群步骤 )</p>
<div class="highlight highlight-source-shell"><pre>$ docker swarm join --token SWMTKN-1-1023ixl3yabjyws8tjdyvob7r40mljsu8atzsmlju18wz2itlj-07q9wti67nkvqixykkcbi1ge8 主机1的IP:2377
This node joined a swarm as a manager.</pre></div>
<h3>查看集群节点</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
kwsp26dy6gwjhocl6nxbez0bu <span class="pl-k">*</span>   主机1               Ready               Active              Leader              18.03.0-ce
19nnijmzs16o1f92e6wdmltsf     主机2               Ready               Active              Reachable           18.03.0-ce</pre></div>
<h3>创建一个 overlay 网络</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>$ docker network create --driver overlay network_swarm</pre></div>
<h3>在 swarm 集群上创建服务，并指定使用的网络</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>$ docker service create --replicas 2 --name service_test --network=network_swarm nginx:alpine</pre></div>
<h3>查看服务状态</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
yp2tn16eqaqc        service_test        replicated          2/2                 nginx:alpine

$ docker service ps service_test
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS
8mgu08gmy0bf        service_test.1      nginx:alpine        主机1               Running             Running 4 minutes ago
310uv4k6aro8        service_test.2      nginx:alpine        主机2               Running             Running 4 minutes ago</pre></div>
<p>在 <strong>主机1</strong> 上查看容器</p>
<div class="highlight highlight-source-shell"><pre>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
d9df9c365d68        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   About a minute ago   Up About a minute   80/tcp              service_test.1.8mgu08gmy0bf9pxovz5zxn8ih</pre></div>
<p>在 <strong>主机2</strong> 上查看容器</p>
<div class="highlight highlight-source-shell"><pre>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
43704a7989ed        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   About a minute ago   Up 2 minutes        80/tcp                   service_test.2.310uv4k6aro8n47c37zj0w1c8</pre></div>
<p>可以看到有一个名为 <strong>service_test</strong> 的服务，有两个实例 ( <strong>service_test.1.xxx</strong> 和  <strong>service_test.2.xxx</strong> ) 分别部署在两台机器上。</p>
<h3>调整服务的实例个数</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>$ docker service scale service_test=3
service_test scaled to 3
overall progress: 3 out of 3 tasks
1/3: running   [<span class="pl-k">==================================================&gt;</span>]
2/3: running   [<span class="pl-k">==================================================&gt;</span>]
3/3: running   [<span class="pl-k">==================================================&gt;</span>]
verify: Service converged

<span class="pl-c"><span class="pl-c">#</span> 主机1</span>
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
ed226d0dc795        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   24 seconds ago      Up 23 seconds       80/tcp              service_test.3.u6iop1v2gup15asywx6g927vo
d9df9c365d68        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   2 minutes ago       Up 8 minutes        80/tcp              service_test.1.8mgu08gmy0bf9pxovz5zxn8ih</pre></div>
<h3>服务发现与自动恢复</h3>
<hr>
<p>手动删除或关闭运行中的容器，过几秒之后就能发现 <strong>Swarm</strong> 会自动创建新的容器来顶替失效的容器。</p>
<h3>负载均衡</h3>
<hr>
<p>在单机模式下进行测试，情况会简单点</p>
<ol>
<li>删除已有的服务</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ docker service rm service_test</pre></div>
<ol start="2">
<li><strong>worker</strong> 节点退出集群，使 <strong>manager</strong> 节点成为单节点的集群</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ docker swarm leave</pre></div>
<ol start="3">
<li>创建带端口映射的服务 <strong>service_test</strong></li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ docker service create --replicas 2 --name service_test -p 80:80 --network=network_swarm nginx:alpine</pre></div>
<ol start="4">
<li>创建作为干扰的服务 <strong>service_test2</strong> ( 和 <strong>service_test</strong> 共用一个网络)</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ docker service create --replicas 1 --name service_test2 -p 81:80 --network=network_swarm nginx:alpine</pre></div>
<ol start="5">
<li>查看所有容器</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
c2d9a5111659        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   19 seconds ago       Up 17 seconds       80/tcp              service_test2.1.rdseqv5oq2cli3vojsk5unibm
cf09fa224a32        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   About a minute ago   Up About a minute   80/tcp              service_test.2.xdl050dxdrzfpdzjwjf40mook
1b998a72b03b        nginx:alpine        <span class="pl-s"><span class="pl-pds">"</span>nginx -g 'daemon of…<span class="pl-pds">"</span></span>   About a minute ago   Up About a minute   80/tcp              service_test.1.fgu08x9mi33xd002ctdjoeyv0</pre></div>
<ol start="6">
<li>修改每个 <strong>nginx</strong> 的页面内容</li>
</ol>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 注意：容器id修改为实际的容器id</span>
<span class="pl-c"><span class="pl-c">#</span> service_test.1</span>
$ docker <span class="pl-c1">exec</span> -i 1b sed -i <span class="pl-s"><span class="pl-pds">'</span>s$&lt;title&gt;Welcome to nginx!&lt;/title&gt;$&lt;title&gt;Welcome to nginx-1!&lt;/title&gt;$<span class="pl-pds">'</span></span> /usr/share/nginx/html/index.html
<span class="pl-c"><span class="pl-c">#</span> service_test.2</span>
$ docker <span class="pl-c1">exec</span> -i cf sed -i <span class="pl-s"><span class="pl-pds">'</span>s$&lt;title&gt;Welcome to nginx!&lt;/title&gt;$&lt;title&gt;Welcome to nginx-2!&lt;/title&gt;$<span class="pl-pds">'</span></span> /usr/share/nginx/html/index.html
<span class="pl-c"><span class="pl-c">#</span> service_test2.1</span>
$ docker <span class="pl-c1">exec</span> -i c2 sed -i <span class="pl-s"><span class="pl-pds">'</span>s$&lt;title&gt;Welcome to nginx!&lt;/title&gt;$&lt;title&gt;Welcome to nginx-3!&lt;/title&gt;$<span class="pl-pds">'</span></span> /usr/share/nginx/html/index.html</pre></div>
<ol start="7">
<li>查看效果</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ curl 127.0.0.1:81 <span class="pl-k">|</span> grep title
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   614  100   614    0     0   181k      0 --:--:-- --:--:-- --:--:--  199k
<span class="pl-k">&lt;</span>title<span class="pl-k">&gt;</span>Welcome to nginx-3<span class="pl-k">!</span><span class="pl-k">&lt;</span>/title<span class="pl-k">&gt;</span>
$ curl 127.0.0.1 <span class="pl-k">|</span> grep title
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   614  100   614    0     0   196k      0 --:--:-- --:--:-- --:--:--  299k
<span class="pl-k">&lt;</span>title<span class="pl-k">&gt;</span>Welcome to nginx-2<span class="pl-k">!</span><span class="pl-k">&lt;</span>/title<span class="pl-k">&gt;</span>
$ curl 127.0.0.1 <span class="pl-k">|</span> grep title
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   614  100   614    0     0   164k      0 --:--:-- --:--:-- --:--:--  299k
<span class="pl-k">&lt;</span>title<span class="pl-k">&gt;</span>Welcome to nginx-1<span class="pl-k">!</span><span class="pl-k">&lt;</span>/title<span class="pl-k">&gt;</span>
$ curl 127.0.0.1 <span class="pl-k">|</span> grep title
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   614  100   614    0     0   174k      0 --:--:-- --:--:-- --:--:--  299k
<span class="pl-k">&lt;</span>title<span class="pl-k">&gt;</span>Welcome to nginx-2<span class="pl-k">!</span><span class="pl-k">&lt;</span>/title<span class="pl-k">&gt;</span>
...</pre></div>
<p>可以看出访问 <strong>80</strong> 端口会交替访问 <strong>service_test.1</strong> 和 <strong>service_test.2</strong> 且不会转发到 <strong>service_test2.1</strong> 上，说明 <strong>负载均衡</strong> 成功。</p>
<ol start="8">
<li>查看宿主机的 <strong>NAT</strong> 映射情况</li>
</ol>
<div class="highlight highlight-source-shell"><pre>$ sudo iptables -t nat -nL
...
Chain DOCKER-INGRESS (2 references)
target     prot opt <span class="pl-c1">source</span>               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:81 to:172.18.0.2:81
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.18.0.2:80
RETURN     all  --  0.0.0.0/0            0.0.0.0/0</pre></div>
<p>可以看出宿主机的 <strong>80</strong> 端口被映射到了 <strong>172.18.0.2</strong> 的 <strong>80</strong> 端口上，而这个 <strong>172.18.0.2</strong> 的 <strong>IP</strong> 就属于 <strong>overlay</strong> 网络 <code>network_swarm</code>。对于 <strong>overlay</strong> 网络的原理不是很清楚，也没深入研究下去，有了解的小伙伴欢迎指教。不过，我猜测应该是 <strong>overlay</strong> 网络内部实现了某种一对多的端口映射从而实现 <strong>负载均衡</strong> 的效果。</p>
<h3>使用 Docker Stack 部署多服务集群（ <a href="https://www.cnblogs.com/xishuai/p/docker-swarm.html#docker-stack-%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A-gui-%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2" rel="nofollow">参考</a> ）</h3>
<hr>
<p><strong>Docker Swarm</strong> 只能实现对单个服务的简单部署，如果要实现和 <strong>Docker Compose</strong> 一样的多服务编排就需要用到 <strong>Docker Stack</strong> 命令，具体用法请看另一篇 <a href="https://www.jianshu.com/p/1db6f0150fdb" rel="nofollow">文章</a> 。</p>
<h3>Swarm 的不足</h3>
<hr>
<ul>
<li>功能简单有限</li>
<li>当集群中某台机器的资源 ( CPU、内存等 ) 不足时，<strong>Swarm</strong> 在部署服务的时候还是会傻傻地平均分配容器到这台机器上。</li>
</ul>
<h3>常用命令</h3>
<hr>
<ul>
<li><strong>docker swarm</strong> 命令用于管理 <strong>Swarm</strong> 群集</li>
</ul>
<table role="table">
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">docker swarm init</td>
<td align="left">初始化一个 <strong>swarm</strong> 群集</td>
</tr>
<tr>
<td align="left">docker swarm join</td>
<td align="left">加入群集作为节点或管理器</td>
</tr>
<tr>
<td align="left">docker swarm join-token</td>
<td align="left">管理用于加入群集的令牌</td>
</tr>
<tr>
<td align="left">docker swarm leave</td>
<td align="left">离开 <strong>swarm</strong> 群集</td>
</tr>
<tr>
<td align="left">docker swarm unlock</td>
<td align="left">解锁 <strong>swarm</strong> 群集</td>
</tr>
<tr>
<td align="left">docker swarm unlock-key</td>
<td align="left">管理解锁钥匙</td>
</tr>
<tr>
<td align="left">docker swarm update</td>
<td align="left">更新 <strong>swarm</strong> 群集</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>docker node</strong> 命令用于管理 <strong>Swarm</strong> 群集中的机器节点</li>
</ul>
<table role="table">
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">docker node demote</td>
<td align="left">从 <strong>swarm</strong> 群集管理器中降级一个或多个节点</td>
</tr>
<tr>
<td align="left">docker node inspect</td>
<td align="left">显示一个或多个节点的详细信息</td>
</tr>
<tr>
<td align="left">docker node ls</td>
<td align="left">列出 <strong>swarm</strong> 群集中的节点</td>
</tr>
<tr>
<td align="left">docker node promote</td>
<td align="left">将一个或多个节点推入到群集管理器中</td>
</tr>
<tr>
<td align="left">docker node ps</td>
<td align="left">列出在一个或多个节点上运行的任务，默认为当前节点</td>
</tr>
<tr>
<td align="left">docker node rm</td>
<td align="left">从 <strong>swarm</strong> 群集删除一个或多个节点</td>
</tr>
<tr>
<td align="left">docker node update</td>
<td align="left">更新一个节点</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>docker service</strong> 命令用于管理 <strong>Swarm</strong> 群集中的服务</li>
</ul>
<table role="table">
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">docker service create</td>
<td align="left">创建服务</td>
</tr>
<tr>
<td align="left">docker service inspect</td>
<td align="left">显示一个或多个服务的详细信息</td>
</tr>
<tr>
<td align="left">docker service logs</td>
<td align="left">获取服务的日志</td>
</tr>
<tr>
<td align="left">docker service ls</td>
<td align="left">列出服务</td>
</tr>
<tr>
<td align="left">docker service rm</td>
<td align="left">删除一个或多个服务</td>
</tr>
<tr>
<td align="left">docker service scale</td>
<td align="left">设置服务的实例数量</td>
</tr>
<tr>
<td align="left">docker service update</td>
<td align="left">更新服务</td>
</tr>
<tr>
<td align="left">docker service rollback</td>
<td align="left">恢复服务至 <strong>update</strong> 之前的配置</td>
</tr>
</tbody>
</table>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/47fa426ff767">https://www.jianshu.com/p/47fa426ff767</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker 下的网络模式]]></title>
            <link>https://anyesu.github.io/blog/articles/14</link>
            <guid>14</guid>
            <pubDate>Sat, 27 Apr 2019 09:01:58 GMT</pubDate>
            <description><![CDATA[前言 在 Docker 常用指令详解 一文中介绍了 Docker 的常用指令, 在构建容器的时候使用了 --net anyesu_net 这个选项, 意思是让容器使用自定义的网络 anyesu_net , 本文就 Docker 下的网络模式做一个简单介绍。 四种网络模式的选择 bridge 这是 Docker 默认使用的模式, Docker Daemon 启动时默认会创建 Docker0 这个网桥]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a> 一文中介绍了 <strong>Docker</strong> 的常用指令, 在构建容器的时候使用了 <code>--net anyesu_net</code> 这个选项, 意思是让容器使用自定义的网络 <strong>anyesu_net</strong> , 本文就 <strong>Docker</strong> 下的网络模式做一个简单介绍。</p>
<h3>四种网络模式的选择</h3>
<hr>
<ul>
<li><strong>bridge</strong></li>
</ul>
<p>这是 <strong>Docker</strong> 默认使用的模式, <strong>Docker Daemon</strong> 启动时默认会创建 <strong>Docker0</strong> 这个网桥, 网段为 <strong>172.17.0.0/16</strong> , 宿主机 <strong>IP</strong> 为 <strong>172.17.0.1</strong> , 作为这个虚拟子网的 <strong>网关</strong> 。</p>
<p>当然, 也可以新建一个名为 <strong>anyesu_net</strong> 网段为 <strong>172.18.0.0/16</strong> 的网桥：</p>
<div class="highlight highlight-source-shell"><pre>docker network create --subnet=172.18.0.0/16 anyesu_net</pre></div>
<p>启动 <strong>容器</strong> 时指定 <code>--net anyesu_net</code> 即可。</p>
<p><a href="https://www.centos.bz/2017/01/docker-network-create-create-a-network" rel="nofollow">docker network 命令相关资料</a></p>
<ul>
<li><strong>host</strong></li>
</ul>
<p><strong>容器</strong> 共享 <strong>宿主机</strong> 的网络 ( <strong>IP</strong> 和 <strong>端口</strong> ) 。使用 <strong>Docker</strong> 有相当一部分目的是为了隔离 <strong>宿主机</strong> 和 <strong>容器</strong> , 使用 <strong>host</strong> 模式就违背了这一点, 不是很好。另外有很多 <strong>镜像</strong> 如 <strong>tomcat</strong> 默认监听 <strong>8080</strong> 端口的, 使用 <strong>host</strong> 模式后开多个 <strong>容器</strong> 就会造成端口冲突, 而不得不修改 <strong>tomcat</strong> 的监听端口。</p>
<ul>
<li><strong>none</strong></li>
</ul>
<p>这种模式下, 创建的 <strong>容器</strong> 拥有自己的 <strong>Network Namespace</strong>, 但是没有任何网络配置, 所以默认是没有网络的, 可以自己对 <strong>容器</strong> 的 <strong>网卡</strong>、<strong>IP</strong> 进行配置, 适合用来配置比默认设置更加复杂的网络环境。</p>
<ul>
<li><strong>container</strong></li>
</ul>
<p>类似于 <strong>host</strong> 模式, 不过这种模式是共享已存在的 <strong>容器</strong> 使用的网络。</p>
<h3>给容器分配固定 IP</h3>
<hr>
<p>默认应该是按 <strong>容器</strong> 创建或启动顺序依次分配的, 所以 <strong>容器</strong> 重启后 <strong>IP</strong> 就可能会变化, 这对于一些需要定向访问 <strong>容器</strong> 的功能来说就比较麻烦了。一种解决办法是使用 <strong>link</strong> 来链接 <strong>容器</strong>, 原理就是动态配置 <strong>hosts</strong> , 不过这种方式启动顺序有依赖关系, 因此本人不习惯使用。还有一种方法, 是启动 <strong>容器</strong> 的时候使用自定义网络, 如 <strong>anyesu_net</strong> , 并指定 <code>--ip</code> 选项来固定 <strong>IP</strong> 。</p>
<p>当然, 网上还有很多教程借助 <strong>pipework</strong> 、<strong>nsenter</strong> 等工具实现固定 <strong>IP</strong> 的功能, 甚至可以分配到 <strong>宿主机</strong> 所在物理网段上的 <strong>IP</strong> 。不过, 步骤都比较复杂, 有兴趣的小伙伴可以参考下面的几篇文章自己尝试哦。</p>
<ul>
<li><a href="http://ju.outofmemory.cn/entry/115587" rel="nofollow">Docker为容器分配指定物理网段的静态IP</a></li>
<li><a href="http://www.jb51.net/article/94550.htm" rel="nofollow">Docker 配置固定IP及桥接的实现方法</a></li>
<li><a href="http://blog.csdn.net/rually/article/details/51919883" rel="nofollow">分配局域网固定ip</a></li>
<li><a href="http://blog.csdn.net/gobitan/article/details/51104362" rel="nofollow">为Docker容器指定自定义网段的固定IP/静态IP地址</a></li>
<li><a href="http://blog.csdn.net/fgf00/article/details/52575500" rel="nofollow">Docker 使用物理网络IP地址 及四种网络模式</a></li>
</ul>
<h3>关于容器中 hosts 文件的修改</h3>
<hr>
<p>启动 <strong>容器</strong> 的时候指定 <code>--link</code> 或 <code>--add-host</code> 选项修改 <strong>hosts</strong> 文件内容, 但都是追加内容而无法覆盖已有内容, 比如我要重设 <strong>localhost</strong> 使其指向 <strong>宿主机</strong> 的 <strong>IP</strong> <code>172.17.0.1</code> 而不是默认的 <code>127.0.0.1</code> ( <strong>可能也就我吃饱了撑着要这么做吧</strong> ) 就不能用这种方法了。</p>
<p>了解到 <strong>容器</strong> 的 <strong>hosts</strong> 文件是 <strong>容器</strong> 启动时先在 <strong>宿主机</strong> 上动态创建后再挂载到 <strong>容器</strong> 上的 ( 源文件位于 <strong>宿主机</strong> 的 <strong>/var/lib/docker/containers/[容器id]</strong> 目录下 ) , 因此, <strong>容器</strong> 重启之后还会重新创建, 即之前所做的修改都没了。于是想到在容器的 <strong>启动命令</strong> 中动态修改, 但是 <strong>hosts</strong> 文件是不允许直接修改的, 于是采用下面的办法：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 拷贝hosts内容</span>
cp /etc/hosts /etc/hosts.tmp
<span class="pl-c"><span class="pl-c">#</span> 替换字符串</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>s$127.0.0.1$172.17.0.1$<span class="pl-pds">'</span></span> /etc/hosts.tmp
<span class="pl-c"><span class="pl-c">#</span> 覆盖hosts</span>
cat /etc/hosts.tmp <span class="pl-k">&gt;</span> /etc/hosts

<span class="pl-c"><span class="pl-c">#</span> CMD参数中 使用 sh -c "... &amp;&amp; ... &amp;&amp; ..." 的方式来运行多个指令</span></pre></div>
<p>个人觉得这也不是一种好办法, 就换了一种更简单粗暴的方法: <code>-v /etc/hosts:/etc/hosts</code> , 使用 <strong>宿主机</strong> 文件映射 <strong>容器</strong> 的 <strong>hosts</strong> 文件 ( 或者新建一个 <strong>hosts</strong> 文件专门给 <strong>容器</strong> 用而不影响 <strong>宿主机</strong> 的 <strong>hosts</strong> ) 达到覆盖的目的, 再配合 <strong>容器</strong> 固定 <strong>IP</strong> 配置, 多个 <strong>容器</strong> 共用一套 <strong>hosts</strong> 文件, 将所有 <strong>容器</strong> 的主机名和 <strong>IP</strong> 配置进去, <strong>容器</strong> 之间也可以通过主机名或子网 <strong>IP</strong> 直接访问。</p>
<p>相关文章：</p>
<ul>
<li><a href="http://dockone.io/question/400" rel="nofollow">docker hosts 文件修改</a></li>
<li><a href="http://songlisha.blog.51cto.com/6269280/1702565" rel="nofollow">Docker 使用 dnsmasq 替代 /etc/hosts 解析</a></li>
</ul>
<h3>Docker 下使用 dubbo</h3>
<hr>
<p>公司项目中使用了 <strong>dubbo</strong> 来搭建分布式系统, 本地开发环境统一使用 <strong>localhost</strong> 来连接 <strong>ZooKeeper</strong> , 绑定不同端口实现 <strong>伪分布式</strong> 。后来就在测试环境上使用 <strong>Jenkins + Svn + Maven + Docker</strong> 的方式完成 <strong>一键构建</strong> , 将每个服务部署在单独的容器之中, 使用默认的 <strong>bridge</strong> 网络模式。</p>
<h5>遇到的问题</h5>
<p><strong>1. 访问宿主机上的 ZooKeeper</strong></p>
<p>简单的方法是在项目配置文件中使用环境变量或主机名 <strong>ZkServer</strong> 作为注册中心地址, 相应的对 <strong>容器</strong> 进行环境变量和 <strong>hosts</strong> 的配置即可。不过，作为一个懒人, 项目中已经写好了使用 <strong>localhost</strong> 就不想改成 <strong>ZkServer</strong> 了, 方法也简单, 就是使用上面的方法替换 <strong>localhost</strong> 的 <strong>IP</strong> 为 <strong>172.17.0.1</strong> , 即 <strong>宿主机的 IP</strong>。</p>
<p><a href="http://blog.csdn.net/gaowenhui2008/article/details/68484788" rel="nofollow">在Docker中运行Dubbo应用</a></p>
<p><strong>2. 服务提供者注册 IP 问题</strong></p>
<p><strong>容器</strong> 内的服务默认注册到 <strong>zookeeper</strong> 上的地址是一个 <strong>IP</strong> ( 如 <code>172.17.0.2</code> ) , 是一个内网地址, 对于 <strong>宿主机</strong> 和 <strong>运行在其上的所有容器</strong> 之外的其他机器来说是不可访问的。如果要使服务对其他机器可用的话就要另辟蹊径了, 主要方法有:</p>
<blockquote>
<ol>
<li>容器使用 <strong>host</strong> 网络模式或设置为宿主机物理网段上的 <strong>IP</strong></li>
<li>对宿主机和服务消费者之间的网络设置路由规则, 使消费者可访问容器内网 <strong>IP</strong></li>
<li>修改 <strong>dubbo</strong> 源码来指定服务注册 <strong>IP</strong></li>
</ol>
</blockquote>
<p>上面的方法实践起来有点复杂, 也不是很可靠, 还得另寻方法。</p>
<p>查了下 <strong>dubbo</strong> 的源码, 在 <strong>com.alibaba.dubbo.config.ServiceConfig</strong> 类的 <a href="https://github.com/alibaba/dubbo/blob/63cd838a387448a598380efc610f2b14e74cc3d9/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java#LC299">doExportUrlsFor1Protocol</a> 方法中, 如果配置中没有指定 <strong>host</strong> 属性或者使用了回环地址则调用 <strong>InetAddress.getLocalHost().getHostAddress()</strong> 来获取本机可用 <strong>IP</strong>。<strong>InetAddress.getLocalHost</strong> 这个方法在 <strong>Windows</strong> 下应该是取所有网卡中第一个可用的 <strong>IP</strong>, 在 <strong>Linux</strong> 下应该是取主机名对应的 <strong>IP</strong> ( 先去 <strong>/etc/hosts</strong> 中找, 找不到再去 <strong>dns</strong> 服务器找, 需要注意这有可能会得到一个错误的 <strong>IP</strong>) , 因此, 在 <strong>Linux</strong> 下针对上面的问题只需修改 <strong>hosts</strong> 文件, 指定主机名对应的 <strong>IP</strong> 为 <strong>宿主机</strong> 的局域网 <strong>IP</strong> 。另外测试了下, 设置的 <strong>host</strong> 在 <strong>Linux</strong> 下只用于提供给服务注册中心而不用于端口绑定, 也就是说可以设置任意 <strong>IP</strong> ; 而在 <strong>Windows</strong> 下设置了非本机 <strong>IP</strong> 会无法绑定端口。</p>
<p><strong>hosts</strong> 文件改完还有一个问题：<strong>tomcat</strong> 默认 <strong>shutdown</strong> 命令绑定的端口是 <strong>localhost:8005</strong>, 由于 <strong>localhost</strong> 已经不再是容器的 <strong>IP</strong> , 因此端口绑定会失败。简单处理就是修改  <strong>tomcat/conf/server.xml</strong> 文件中 <strong>Server</strong> 节点的属性, 添加属性 <code>address="127.0.0.1"</code> , 如下所示：</p>
<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">Server</span> <span class="pl-e">address</span>=<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span> <span class="pl-e">port</span>=<span class="pl-s"><span class="pl-pds">"</span>8005<span class="pl-pds">"</span></span> <span class="pl-e">shutdown</span>=<span class="pl-s"><span class="pl-pds">"</span>SHUTDOWN<span class="pl-pds">"</span></span>&gt;</pre></div>
<h5>总结下最终的方案步骤：</h5>
<ol>
<li>创建自定义网络 (  <strong>172.18.0.0/16</strong> 网段 )</li>
<li><strong>容器</strong> 指定 <strong>hostname</strong> 、自定义网络、固定 <strong>IP</strong></li>
<li><strong>宿主机</strong> ( 局域网 <strong>IP</strong> : <code>192.168.1.100</code>）新建文件 <strong>/etc/hosts2</strong> 挂载到容器的 <strong>/etc/hosts</strong> 上 (  <code>-v /etc/hosts2:/etc/hosts</code> ) , 内容如下, 所有容器共用此 <strong>hosts</strong> 文件</li>
</ol>
<pre><code>172.18.0.1 localhost
192.168.1.100 docker_host1
192.168.1.100 docker_host2
...

</code></pre>
<ol start="4">
<li><strong>宿主机</strong> 到 <strong>容器</strong> 的端口映射 <code>-p 20880:20880</code></li>
</ol>
<h5>最终结构图如下所示：</h5>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/135bee121fb08bdf5505e3d54479d2f0a4c98157/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616238343536326531393564373365332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/135bee121fb08bdf5505e3d54479d2f0a4c98157/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616238343536326531393564373365332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="dubbo容器结构" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-ab84562e195d73e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>2017-12-25 追加</h3>
<hr>
<blockquote>
<p>目前 dubbo 自身已提供环境变量的方式注册 IP 和端口，详见 <a href="https://github.com/apache/incubator-dubbo-samples/tree/master/dubbo-samples-docker">官方示例</a></p>
<ul>
<li>当前 2.5.9 版本有 <a href="https://github.com/alibaba/dubbo/issues/1289" data-hovercard-type="issue" data-hovercard-url="/apache/dubbo/issues/1289/hovercard">bug</a> , 监听端口与注册端口不一致会导致找不到对应服务</li>
</ul>
</blockquote>
<p><a href="https://github.com/alibaba/dubbo/blob/2.5.x/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java#LC544">2.5.x 分支中配置优先级：</a><br>
系统环境变量 &gt; <strong>java</strong> 命令参数 ( <code>-Dxxx=yyy</code> ) &gt; 配置文件 <strong>host</strong> 属性 &gt; <strong>/etc/hosts</strong> 中 <strong>hostname-ip</strong> 映射关系 &gt; 默认连通注册中心地址的网卡地址 &gt; 第一个可用的网卡地址</p>
<h3>参考文章</h3>
<hr>
<ul>
<li><a href="http://www.dockone.io/article/965" rel="nofollow">聊聊 Docker 1.9 的新网络特性</a></li>
<li><a href="http://cizixs.com/2016/06/13/docker-overlay-network?utm_source=tuicool&amp;utm_medium=referral" rel="nofollow">docker 跨主机网络：overlay 简介</a></li>
<li><a href="https://www.oschina.net/translate/docker-network-configuration" rel="nofollow">Docker 网络配置 【已翻译100%】</a></li>
</ul>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/f510aaa470cc">http://www.jianshu.com/p/f510aaa470cc</a></h4>]]></content:encoded>
            <enclosure url="http://upload-images.jianshu.io/upload_images/1836534-ab84562e195d73e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Docker Daemon 连接方式详解]]></title>
            <link>https://anyesu.github.io/blog/articles/13</link>
            <guid>13</guid>
            <pubDate>Sat, 27 Apr 2019 07:49:50 GMT</pubDate>
            <description><![CDATA[前言 在 Docker 常用详解指令 一文中粗粗提了一下, Docker 是分为客户端和服务端两部分的, 本文将介绍客户端是如何连接服务端的。 连接方式 1. UNIX域套接字 默认就是这种方式, 会生成一个 /var/run/docker.sock 文件, UNIX 域套接字用于本地进程之间的通讯, 这种方式相比于网络套接字效率更高, 但局限性就是只能被本地的客户端访问。 2. TCP 端口监听]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用详解指令</a> 一文中粗粗提了一下, <strong>Docker</strong> 是分为客户端和服务端两部分的, 本文将介绍客户端是如何连接服务端的。</p>
<h3>连接方式</h3>
<hr>
<h5>1. <a href="http://www.cnblogs.com/nufangrensheng/p/3569416.html" rel="nofollow">UNIX域套接字</a></h5>
<p>默认就是这种方式, 会生成一个 <strong>/var/run/docker.sock</strong> 文件, <strong>UNIX</strong> 域套接字用于本地进程之间的通讯, 这种方式相比于网络套接字效率更高, 但局限性就是只能被本地的客户端访问。</p>
<h5>2. TCP 端口监听</h5>
<p>服务端开启端口监听：<code>dockerd -H IP:PORT</code></p>
<p>客户端通过指定的 <strong>IP</strong> 和 <strong>端口</strong> 访问服务端：<code>docker -H IP:PORT</code></p>
<p>通过这种方式, 任何人只要知道了你暴露的 <strong>IP</strong> 和 <strong>端口</strong> 就能随意访问你的 <strong>Docker</strong> 服务了, 这是一件很危险的事, 因为 <strong>docker</strong> 的权限很高, 不法分子可以从这突破取得服务端 <strong>宿主机</strong> 的最高权限。</p>
<h6>相关：<a href="http://www.jianshu.com/p/74aa4723111b" rel="nofollow">一个回车键黑掉一台服务器</a></h6>
<h5>3. 可以同时监听多个 socket</h5>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ sudo dockerd -H unix:///var/run/docker.sock -H tcp://127.0.0.1:2376 -H tcp://127.0.0.1:2377
...
INFO[0004] API listen on 127.0.0.1:2377
INFO[0004] API listen on /var/run/docker.sock
INFO[0004] API listen on 127.0.0.1:2376</pre></div>
<h3>启用 TLS 安全连接</h3>
<hr>
<p>上面介绍了普通的 <strong>HTTP</strong> 方式远程连接很不安全, 解决的办法很简单, 就是启用 <strong>TLS</strong> 证书实现客户端和服务端的双向认证, 以此来保证安全性。</p>
<h5>创建 TLS 证书 ( 根证书、服务端证书、客户端证书 )</h5>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">cd</span> /usr/anyesu/docker
<span class="pl-c"><span class="pl-c">#</span> 内容比较多, 就写成一个shell脚本, 将需要绑定的服务端ip或域名做参数传入即可</span>
vi tlscert.sh</pre></div>
<p>脚本内容如下：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#!</span>/bin/bash</span>
<span class="pl-c"><span class="pl-c">#</span> @author: anyesu</span>

<span class="pl-k">if</span> [ <span class="pl-smi">$#</span> <span class="pl-k">!=</span> 1 ] <span class="pl-k">;</span> <span class="pl-k">then</span> 
<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>USAGE: <span class="pl-smi">$0</span> [HOST_IP]<span class="pl-pds">"</span></span> 
<span class="pl-c1">exit</span> 1<span class="pl-k">;</span> 
<span class="pl-k">fi</span> 

<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
<span class="pl-c"><span class="pl-c">#</span>   下面为证书密钥及相关信息配置，注意修改   #</span>
<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
PASSWORD=<span class="pl-s"><span class="pl-pds">"</span>8#QBD2<span class="pl-smi">$!</span>EmED&amp;QxK<span class="pl-pds">"</span></span>
COUNTRY=CN
PROVINCE=yourprovince
CITY=yourcity
ORGANIZATION=yourorganization
GROUP=yourgroup
NAME=yourname
HOST=<span class="pl-smi">$1</span>
SUBJ=<span class="pl-s"><span class="pl-pds">"</span>/C=<span class="pl-smi">$COUNTRY</span>/ST=<span class="pl-smi">$PROVINCE</span>/L=<span class="pl-smi">$CITY</span>/O=<span class="pl-smi">$ORGANIZATION</span>/OU=<span class="pl-smi">$GROUP</span>/CN=<span class="pl-smi">$HOST</span><span class="pl-pds">"</span></span>

<span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>your host is: <span class="pl-smi">$1</span><span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> 1.生成根证书RSA私钥，PASSWORD作为私钥文件的密码</span>
openssl genrsa -passout pass:<span class="pl-smi">$PASSWORD</span> -aes256 -out ca-key.pem 4096

<span class="pl-c"><span class="pl-c">#</span> 2.用根证书RSA私钥生成自签名的根证书</span>
openssl req -passin pass:<span class="pl-smi">$PASSWORD</span> -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj <span class="pl-smi">$SUBJ</span>

<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
<span class="pl-c"><span class="pl-c">#</span>          用根证书签发server端证书          #</span>
<span class="pl-c"><span class="pl-c">#</span>============================================#</span>

<span class="pl-c"><span class="pl-c">#</span> 3.生成服务端私钥</span>
openssl genrsa -out server-key.pem 4096

<span class="pl-c"><span class="pl-c">#</span> 4.生成服务端证书请求文件</span>
openssl req -new -sha256 -key server-key.pem -out server.csr -subj <span class="pl-s"><span class="pl-pds">"</span>/CN=<span class="pl-smi">$HOST</span><span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> 5.使tls连接能通过ip地址方式，绑定IP</span>
<span class="pl-c1">echo</span> subjectAltName = IP:127.0.0.1,IP:<span class="pl-smi">$HOST</span> <span class="pl-k">&gt;</span> extfile.cnf

<span class="pl-c"><span class="pl-c">#</span> 6.使用根证书签发服务端证书</span>
openssl x509 -passin pass:<span class="pl-smi">$PASSWORD</span> -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf


<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
<span class="pl-c"><span class="pl-c">#</span>          用根证书签发client端证书          #</span>
<span class="pl-c"><span class="pl-c">#</span>============================================#</span>

<span class="pl-c"><span class="pl-c">#</span> 7.生成客户端私钥</span>
openssl genrsa -out key.pem 4096

<span class="pl-c"><span class="pl-c">#</span> 8.生成客户端证书请求文件</span>
openssl req -subj <span class="pl-s"><span class="pl-pds">'</span>/CN=client<span class="pl-pds">'</span></span> -new -key key.pem -out client.csr

<span class="pl-c"><span class="pl-c">#</span> 9.客户端证书配置文件</span>
<span class="pl-c1">echo</span> extendedKeyUsage = clientAuth <span class="pl-k">&gt;</span> extfile.cnf

<span class="pl-c"><span class="pl-c">#</span> 10.使用根证书签发客户端证书</span>
openssl x509 -passin pass:<span class="pl-smi">$PASSWORD</span> -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile.cnf

<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
<span class="pl-c"><span class="pl-c">#</span>                    清理                    #</span>
<span class="pl-c"><span class="pl-c">#</span>============================================#</span>
<span class="pl-c"><span class="pl-c">#</span> 删除中间文件</span>
rm -f client.csr server.csr ca.srl extfile.cnf

<span class="pl-c"><span class="pl-c">#</span> 转移目录</span>
mkdir client server
cp {ca,cert,key}.pem client
cp {ca,server-cert,server-key}.pem server
rm {cert,key,server-cert,server-key}.pem

<span class="pl-c"><span class="pl-c">#</span> 设置私钥权限为只读</span>
chmod -f 0400 ca-key.pem server/server-key.pem client/key.pem</pre></div>
<p>执行服务端配置</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 给脚本添加运行权限</span>
chmod +x tlscert.sh
HOST_IP=127.0.0.1
./tlscert.sh <span class="pl-smi">$HOST_IP</span>
<span class="pl-c"><span class="pl-c">#</span> 客户端需要的证书保存在client目录下, 服务端需要的证书保存在server目录下</span>
sudo cp server/<span class="pl-k">*</span> /etc/docker
<span class="pl-c"><span class="pl-c">#</span> 修改配置</span>
sudo vi /etc/default/docker
<span class="pl-c"><span class="pl-c">#</span> 改为 DOCKER_OPTS="--selinux-enabled --tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server-cert.pem --tlskey=/etc/docker/server-key.pem -H=unix:///var/run/docker.sock -H=0.0.0.0:2375"</span>

<span class="pl-c"><span class="pl-c">#</span> 重启docker</span>
sudo service docker restart</pre></div>
<p><a href="http://blog.csdn.net/l6807718/article/details/51325431" rel="nofollow">关于 Ubuntu 16.04.2 LTS 下DOCKER_OPTS 不生效的问题解决</a></p>
<p>接着按之前的方式连接服务端就出错了，说明 <strong>TLS</strong> 已经生效了。</p>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ docker -H tcp://127.0.0.1:2375 version
Get http://127.0.0.1:2375/v1.29/version: malformed HTTP response <span class="pl-s"><span class="pl-pds">"</span>\x15\x03\x01\x00\x02\x02<span class="pl-pds">"</span></span>.
<span class="pl-k">*</span> Are you trying to connect to a TLS-enabled daemon without TLS<span class="pl-k">?</span></pre></div>
<p>正确的访问方式：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 客户端加tls参数访问</span>
docker --tlsverify --tlscacert=client/ca.pem --tlscert=client/cert.pem --tlskey=client/key.pem -H tcp://127.0.0.1:2375 version

<span class="pl-c"><span class="pl-c">#</span> Docker API方式访问</span>
curl https://127.0.0.1:2375/images/json --cert client/cert.pem --key client/key.pem --cacert client/ca.pem

<span class="pl-c"><span class="pl-c">#</span> 简化客户端调用参数配置</span>
sudo cp client/<span class="pl-k">*</span> <span class="pl-k">~</span>/.docker
<span class="pl-c"><span class="pl-c">#</span> 追加环境变量</span>
<span class="pl-c1">echo</span> -e <span class="pl-s"><span class="pl-pds">"</span>export DOCKER_HOST=tcp://<span class="pl-smi">$HOST_IP</span>:2375 DOCKER_TLS_VERIFY=1<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> <span class="pl-k">~</span>/.bashrc

sudo docker version</pre></div>
<p><strong>切记, 要保护好客户端证书, 这是连接服务端的凭证。另外根证书私钥也要保存好, 泄漏之后就能签发客户端证书了。</strong></p>
<h3>认证模式</h3>
<hr>
<h5>1. 服务端认证模式</h5>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tlsverify, tlscacert, tlscert, tlskey</td>
<td>向客户端发送服务端证书, 校验客户端证书是否由指定的 <strong>CA</strong> ( 自签名根证书 ) 签发</td>
</tr>
<tr>
<td>tls, tlscert, tlskey</td>
<td>向客户端发送服务端证书, 不校验客户端证书是否由指定的 <strong>CA</strong> ( 自签名根证书 ) 签发</td>
</tr>
</tbody>
</table>
<h5>2. 客户端认证模式</h5>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tls</td>
<td>校验服务端证书是否由 公共的 <strong>CA</strong> 机构签发</td>
</tr>
<tr>
<td>tlsverify, tlscacert</td>
<td>校验服务端证书是否由指定的 <strong>CA</strong> ( 自签名根证书 ) 签发</td>
</tr>
<tr>
<td>tls, tlscert, tlskey</td>
<td>使用客户端证书进行身份验证,  但不校验服务端证书是否由指定的 <strong>CA</strong> ( 自签名根证书 ) 签发</td>
</tr>
<tr>
<td>tlsverify, tlscacert, tlscert, tlskey</td>
<td>使用客户端证书进行身份验证且校验服务端证书是否由指定的 <strong>CA</strong> ( 自签名根证书 ) 签发</td>
</tr>
</tbody>
</table>
<h3>关于远程构建命令</h3>
<hr>
<p>在之前的文章中介绍了 <a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a> , 学了今天的内容之后可以连接远程 <strong>Docker Daemon</strong> 进行构建, 不过需要注意的一点是, 构建需要的配置文件、依赖文件等都需要在客户端准备好, 然后会把这些内容传输到服务端执行构建或运行容器。</p>
<p>另外, <strong>win10</strong> 下的 <a href="http://www.jianshu.com/p/bc38ed12da1d" rel="nofollow">WSL</a> 也可以安装 <strong>Docker</strong> ( 不过可能是因为早期版本子系统的缘故, <strong>Docker</strong> 服务端跑不起来, 只能运行 <strong>Docker</strong> 客户端, 前段时间的 <a href="http://www.ghostxitong.com/win10xinwen/4508.html" rel="nofollow">创意者更新</a> 中可能有所改进, 不过还未尝试 ), 通过 <strong>Docker</strong> 客户端连接远程 <strong>Docker</strong> 服务 <strong>假装</strong> 体验下 <strong>Docker</strong> 也是不错的。</p>
<h3>参考文章</h3>
<hr>
<ul>
<li><a href="https://docs.docker.com/engine/security/https" rel="nofollow">tls官方文档</a></li>
<li><a href="http://www.cnblogs.com/onlyworld/p/5105849.html" rel="nofollow">centos下修改docker连接docker_host默认方式为tls方式</a></li>
<li><a href="http://blog.csdn.net/shenshouer/article/details/53081724" rel="nofollow">以HTTPS的方式运行docker</a></li>
<li><a href="https://my.oschina.net/itblog/blog/651434" rel="nofollow">OpenSSL证书生成方法</a></li>
<li><a href="http://dockone.io/article/107" rel="nofollow">Docker API</a></li>
</ul>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/7ba1a93e6de4">http://www.jianshu.com/p/7ba1a93e6de4</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Dockerfile 构建镜像]]></title>
            <link>https://anyesu.github.io/blog/articles/12</link>
            <guid>12</guid>
            <pubDate>Fri, 26 Apr 2019 16:38:44 GMT</pubDate>
            <description><![CDATA[前言 在 上一篇文章 中介绍了很多关于镜像的指令, 本文就介绍下如何使用 Dockerfile 来构建镜像。 用法说明 ( 参考 ) 选项 用法 说明 FROM FROM : 指定基础镜像。 MAINTAINER MAINTAINER   创建者信息。 RUN RUN  执行容器操作，主要用来安装软件。 CMD CMD ["executable","param1","param2"] 或 CMD ]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">上一篇文章</a> 中介绍了很多关于镜像的指令, 本文就介绍下如何使用 <strong>Dockerfile</strong> 来构建镜像。</p>
<h3><a href="https://docs.docker.com/engine/reference/builder/#dockerfile-examples" rel="nofollow">用法说明</a> ( <a href="http://blog.csdn.net/qinyushuang/article/details/43342553" rel="nofollow">参考</a> )</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td><strong>FROM</strong> <a target="_blank" rel="noopener noreferrer" href=""><img style="max-width:100%;"></a>:</td>
<td>指定基础镜像。</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td><strong>MAINTAINER</strong>  </td>
<td>创建者信息。</td>
</tr>
<tr>
<td>RUN</td>
<td><strong>RUN</strong> </td>
<td>执行容器操作，主要用来安装软件。</td>
</tr>
<tr>
<td>CMD</td>
<td><strong>CMD</strong> ["executable","param1","param2"] 或 <strong>CMD</strong> command param1 param2 或 <strong>CMD</strong> ["param1","param2"] ( 作为<strong>ENTRYPOINT</strong> 的参数 )</td>
<td>镜像启动时的操作，会被容器的启动命令覆盖。指定多次则最后一条生效。</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>同 <strong>CMD</strong>，<a href="http://cloud.51cto.com/art/201411/457338.htm" rel="nofollow">与 CMD的差别</a> 主要在于其在容器启动时不会被覆盖</td>
<td>启动容器执行的命令，<strong>CMD</strong> 可为其提供参数。指定多次则最后一条生效，如果之后的 <strong>CMD</strong> 是完整指令则会被其覆盖。</td>
</tr>
<tr>
<td>USER</td>
<td><strong>USER</strong> daemon</td>
<td>指定容器的用户，默认为 <strong>root</strong> 。</td>
</tr>
<tr>
<td>EXPOSE</td>
<td><strong>EXPOSE</strong>   ...</td>
<td>暴露容器端口。</td>
</tr>
<tr>
<td>ENV</td>
<td><strong>ENV</strong>  </td>
<td>设置容器内环境变量。</td>
</tr>
<tr>
<td>COPY</td>
<td><strong>COPY</strong>  </td>
<td>从宿主机拷贝内容到容器内,<strong>/</strong> 结尾表示目录，差别自己体会吧。</td>
</tr>
<tr>
<td>ADD</td>
<td><strong>ADD</strong>  </td>
<td>高级版的 <strong>COPY</strong>，如果 <code>&lt;src&gt;</code> 为 <strong>url</strong> 则表示下载文件，如果 <code>&lt;src&gt;</code> 为可识别的压缩文件，拷贝后会进行解压。建议最好还是用 <strong>COPY</strong> 。</td>
</tr>
<tr>
<td>VOLUME</td>
<td><strong>VOLUME</strong> []</td>
<td>指定挂载点，对应目录会映射到宿主机的目录上，宿主机对应的目录是自动生成的无法指定。</td>
</tr>
<tr>
<td>WORKDIR</td>
<td><strong>WORKDIR</strong> </td>
<td>切换容器内目录，相当于 <strong>cd</strong> 。</td>
</tr>
<tr>
<td>ONBUILD</td>
<td><a href="http://www.cnblogs.com/51kata/p/5265107.html" rel="nofollow">参考</a></td>
<td>在子镜像中执行，比如在 <strong>A镜像</strong> 的<strong>Dockerfile</strong> 中添加 <strong>ONBUILD</strong> 指令，该指令在构建构成不会执行，当 <strong>B镜像</strong> 以 <strong>A镜像</strong> 为基础镜像时，构建 <strong>B镜像</strong> 的过程中就会执行该指令。</td>
</tr>
</tbody>
</table>
<h3>示例：JDK7 + Tomcat7 环境配置</h3>
<hr>
<ul>
<li><strong>创建文件：/usr/anyesu/docker/Dockerfile</strong></li>
</ul>
<div class="highlight highlight-source-dockerfile"><pre><span class="pl-c"><span class="pl-c">#</span>指定基础镜像</span>
<span class="pl-k">FROM</span> alpine:latest
<span class="pl-k">MAINTAINER</span> anyesu

<span class="pl-k">RUN</span> echo -e <span class="pl-s">"https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main<span class="pl-c1">\n</span>\</span>
<span class="pl-s">https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/community"</span> &gt; /etc/apk/repositories &amp;&amp; <span class="pl-c1">\ </span>
    <span class="pl-c"><span class="pl-c">#</span> 安装 curl、bash、openjdk7</span>
    apk --update add curl bash openjdk7-jre-base &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 设置时区</span>
    apk add ca-certificates &amp;&amp; \
    apk add tzdata &amp;&amp; \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \
    echo <span class="pl-s">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 清除缓存</span>
    rm -rf /var/cache/apk/*

<span class="pl-c"><span class="pl-c">#</span> 下载tomcat</span>
<span class="pl-c"><span class="pl-c">#</span> ADD http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.94/bin/apache-tomcat-7.0.94.tar.gz /usr/anyesu/</span>

<span class="pl-c"><span class="pl-c">#</span> 拷贝宿主机并解压的tomcat</span>
<span class="pl-c"><span class="pl-c">#</span> ADD apache-tomcat-7.0.94.tar.gz /usr/anyesu</span>

<span class="pl-c"><span class="pl-c">#</span> 拷贝宿主机已解压的tomcat</span>
<span class="pl-k">COPY</span> apache-tomcat /usr/anyesu/tomcat

<span class="pl-c"><span class="pl-c">#</span> 设置环境变量</span>
<span class="pl-k">ENV</span> JAVA_HOME /usr/lib/jvm/default-jvm
<span class="pl-k">ENV</span> CATALINA_HOME /usr/anyesu/tomcat
<span class="pl-k">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin

<span class="pl-c"><span class="pl-c">#</span> 暴露端口</span>
<span class="pl-k">EXPOSE</span> 8080

<span class="pl-c"><span class="pl-c">#</span> 启动命令（前台程序）</span>
<span class="pl-k">ENTRYPOINT</span> [<span class="pl-s">"catalina.sh"</span>]
<span class="pl-k">CMD</span> [<span class="pl-s">"run"</span>]</pre></div>
<ul>
<li>
<h5>构建</h5>
</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 进入目录</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ <span class="pl-c1">cd</span> /usr/anyesu/docker/
<span class="pl-c"><span class="pl-c">#</span> 将上述脚本内容写入Dockerfile文件中，目录下有官网下载的绿色版tomcat</span>
ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ ls
Dockerfile  apache-tomcat  apache-tomcat-7.0.78.tar.gz
<span class="pl-c"><span class="pl-c">#</span> 开始构建，注意不要漏掉最后的点</span>
ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ sudo docker build -t <span class="pl-c1">test</span> <span class="pl-c1">.</span>
<span class="pl-c"><span class="pl-c">#</span> 打印构建日志</span>
Sending build context to Docker daemon  23.27MB
Step 1/10 <span class="pl-c1">:</span> FROM alpine:latest
 ---<span class="pl-k">&gt;</span> a41a7446062d
Step 2/10 <span class="pl-c1">:</span> MAINTAINER anyesu
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> d17ac0db1a7c
 ---<span class="pl-k">&gt;</span> 9287f9fcf15a
Removing intermediate container d17ac0db1a7c
Step 3/10 <span class="pl-c1">:</span> RUN <span class="pl-c1">echo</span> -e <span class="pl-s"><span class="pl-pds">"</span>https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main\nhttps://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/community<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> /etc/apk/repositories <span class="pl-k">&amp;&amp;</span>    apk --update add curl bash openjdk7-jre-base <span class="pl-k">&amp;&amp;</span>         apk add ca-certificates <span class="pl-k">&amp;&amp;</span>   apk add tzdata <span class="pl-k">&amp;&amp;</span>       ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime <span class="pl-k">&amp;&amp;</span>      <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>Asia/Shanghai<span class="pl-pds">"</span></span> <span class="pl-k">&gt;</span> /etc/timezone <span class="pl-k">&amp;&amp;</span>         rm -rf /var/cache/apk/<span class="pl-k">*</span>
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> f292bd8284da
fetch https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main/x86_64/APKINDEX.tar.gz
fetch https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/community/x86_64/APKINDEX.tar.gz
(1/70) Installing ncurses-terminfo-base (6.0-r7)
...
(70/70) Installing openjdk7-jre-base (7.121.2.6.8-r0)
Executing busybox-1.26.2-r4.trigger
Executing ca-certificates-20161130-r0.trigger
Executing java-common-0.1-r0.trigger
Executing glib-2.48.0-r0.trigger
Executing shared-mime-info-1.6-r0.trigger
Executing gdk-pixbuf-2.34.0-r0.trigger
Executing gtk-update-icon-cache-2.24.28-r1.trigger
OK: 127 MiB <span class="pl-k">in</span> 81 packages
OK: 127 MiB <span class="pl-k">in</span> 81 packages
(1/1) Installing tzdata (2016d-r0)
Executing busybox-1.26.2-r4.trigger
OK: 130 MiB <span class="pl-k">in</span> 82 packages
 ---<span class="pl-k">&gt;</span> 90070fea6abf
Removing intermediate container f292bd8284da
Step 4/10 <span class="pl-c1">:</span> COPY apache-tomcat /usr/anyesu/tomcat
 ---<span class="pl-k">&gt;</span> d43a974aae71
Removing intermediate container 7338935f0222
Step 5/10 <span class="pl-c1">:</span> ENV JAVA_HOME /usr/lib/jvm/default-jvm
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> 2451aa745fb6
 ---<span class="pl-k">&gt;</span> e9b5b8ad1bd7
Removing intermediate container 2451aa745fb6
Step 6/10 <span class="pl-c1">:</span> ENV CATALINA_HOME /usr/anyesu/tomcat
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> a5f2173a4e9a
 ---<span class="pl-k">&gt;</span> 2baea7b305dc
Removing intermediate container a5f2173a4e9a
Step 7/10 <span class="pl-c1">:</span> ENV PATH <span class="pl-smi">$PATH</span>:<span class="pl-smi">$JAVA_HOME</span>/bin:<span class="pl-smi">$CATALINA_HOME</span>/bin
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> 6c16768a8fd5
 ---<span class="pl-k">&gt;</span> ada510b55809
Removing intermediate container 6c16768a8fd5
Step 8/10 <span class="pl-c1">:</span> EXPOSE 8080
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> a5cbbb49c31c
 ---<span class="pl-k">&gt;</span> 93dcf03a3c60
Removing intermediate container a5cbbb49c31c
Step 9/10 <span class="pl-c1">:</span> ENTRYPOINT catalina.sh
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> ff2f4e3b9153
 ---<span class="pl-k">&gt;</span> 7745727915fb
Removing intermediate container ff2f4e3b9153
Step 10/10 <span class="pl-c1">:</span> CMD run
 ---<span class="pl-k">&gt;</span> Running <span class="pl-k">in</span> 0ae96cb0d086
 ---<span class="pl-k">&gt;</span> 11716addf503
Removing intermediate container 0ae96cb0d086
Successfully built 11716addf503
Successfully tagged test:latest
<span class="pl-c"><span class="pl-c">#</span> 查看镜像改变内容</span>
ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ docker <span class="pl-c1">history</span> <span class="pl-c1">test</span>
<span class="pl-c"><span class="pl-c">#</span> 查看镜像详情</span>
ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ docker inspect <span class="pl-c1">test</span>
<span class="pl-c"><span class="pl-c">#</span> 使用镜像运行容器</span>
ubuntu@VM-84-201-ubuntu:/usr/anyesu/docker$ docker run <span class="pl-c1">test</span></pre></div>
<h5>注意：</h5>
<blockquote>
<ol>
<li>上面的 <strong>docker build</strong> 命令中用 <code>.</code> 即当前目录作为 <strong>DockerFile</strong> 所在目录，不要漏了。</li>
<li>上述脚本使用 <strong>Alpine Linux</strong> ( <a href="http://www.tuicool.com/articles/yqmmYbu" rel="nofollow">使用说明</a> ) 作为 <strong>基础镜像</strong>，它只有 <strong>5M</strong> 大小，比起其他动辄几百兆的系统镜像，以此为基础构建的镜像要小很多。当然，由于 <strong>Alpine</strong> 足够精简，就会有很多功能上的缺失需要自己去完善。</li>
<li>在 <strong>Dockerfile</strong> 中，每一条指令 ( <strong>RUN</strong> 、<strong>ADD</strong> 、<strong>COPY</strong> 等 ) 都会创建一个镜像层，相对的，层数变多就会增加镜像的大小，需要注意在后面的镜像层中删除文件并不会减小镜像大小。所以最好将多条指令合并执行再跟上删除操作，以此来精简镜像大小。</li>
</ol>
</blockquote>
<h5>遇到的坑:</h5>
<blockquote>
<ol>
<li>容器中默认的时区是不对的，导致显示的时间不正确，<strong>Alpine</strong> 下最彻底的解决办法见上述构建脚本中 <strong>RUN</strong> 命令 <strong>[ 设置时区 ]</strong> 部分 ( <a href="https://lengzzz.com/note/timezone-in-docker" rel="nofollow">参考</a> )</li>
</ol>
<ul>
<li>非 <strong>Alpine</strong> 下 <a href="http://blog.csdn.net/guyue35/article/details/53243517" rel="nofollow">解决办法</a></li>
</ul>
<div class="highlight highlight-source-shell"><pre>docker run -d -v /etc/localtime:/etc/localtime:ro tomcat:7 sh -c <span class="pl-s"><span class="pl-pds">"</span>echo 'Asia/Shanghai' &gt;/etc/timezone &amp;&amp; catalina.sh run<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> 查看tomcat日志打印时间来验证是否生效</span></pre></div>
<ol start="2">
<li><strong>Alpine</strong> 下安装的 <strong>openjdk</strong> , <strong>$JAVA_HOME/lib</strong> 目录下是没有 <strong>fonts</strong> 目录的，这会导致字体相关的功能 ( 如图形验证码 ) 无法使用，不过即使把正常 <strong>JDK</strong> 的字体目录拷贝过去也只会不报错但还是写不出字 ( 正常运行但不绘制文字 )，我猜和 <strong>alpine</strong> 自身字体缺失有点关系。本人对 <strong>linux</strong> 了解不多，照着网上的方法安装了字体也没有成功，哪位童鞋有解决方法的请不吝赐教。目前最终的解决办法就是使用官方的 <a href="https://hub.docker.com/_/tomcat/" rel="nofollow">tomcat 镜像</a>，毕竟人家的镜像功能是完整的而且还优化过。</li>
</ol>
</blockquote>
<h3>参考文章</h3>
<hr>
<ul>
<li><a href="https://github.com/Carrotzpc/docker_web_app">镜像压缩与优化</a></li>
</ul>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/a0892512f86c">http://www.jianshu.com/p/a0892512f86c</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Docker Compose 构建容器]]></title>
            <link>https://anyesu.github.io/blog/articles/11</link>
            <guid>11</guid>
            <pubDate>Fri, 26 Apr 2019 16:08:38 GMT</pubDate>
            <description><![CDATA[前言 在 Docker 常用指令详解 一文中介绍过使用 docker run 命令配合各种复杂的选项完成对 容器 的构建和运行，但是这么长串的命令真的不是很好记也容易敲错。Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具，以 yaml 格式的数据来保存 容器配置，使用更简单的命令完成对 容器 的管理。此外 docker-compose.yml 还起到一个说明文档的作]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a> 一文中介绍过使用 <code>docker run</code> 命令配合各种复杂的选项完成对 <strong>容器</strong> 的构建和运行，但是这么长串的命令真的不是很好记也容易敲错。<strong>Docker Compose</strong> 是一个用来定义和运行复杂应用的 <strong>Docker</strong> 工具，以 <strong>yaml</strong> 格式的数据来保存 <strong>容器配置</strong>，使用更简单的命令完成对 <strong>容器</strong> 的管理。此外 <strong>docker-compose.yml</strong> 还起到一个说明文档的作用, 一切配置在里面显得一目了然，就不用另外单独去写部署文档了。</p>
<h3>安装与卸载</h3>
<hr>
<h5>1. 安装 Docker Compose ( <a href="https://docs.docker.com/compose/install" rel="nofollow">官方文档</a> )</h5>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> curl方式安装(推荐)</span>
<span class="pl-c"><span class="pl-c">#</span> 源站(https://github.com/docker/compose/releases)太慢了,这里用daocloud上的镜像，版本号可自行修改</span>
sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.14.0/docker-compose-<span class="pl-s"><span class="pl-pds">`</span>uname -s<span class="pl-pds">`</span></span>-<span class="pl-s"><span class="pl-pds">`</span>uname -m<span class="pl-pds">`</span></span> <span class="pl-k">&gt;</span> /tmp/docker-compose
chmod +x /tmp/docker-compose
sudo mv /tmp/docker-compose /usr/local/bin/docker-compose

<span class="pl-c"><span class="pl-c">#</span> pip方式安装(需要python,[pip安装方法](http://www.cnblogs.com/lzj0218/p/5753675.html))</span>
sudo pip install docker-compose</pre></div>
<h5>2. 卸载 Docker Compose</h5>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 对于curl安装方式</span>
sudo rm /usr/local/bin/docker-compose

<span class="pl-c"><span class="pl-c">#</span> 对于pip安装方式</span>
sudo pip uninstall docker-compose</pre></div>
<h3>使用方法 ( <a href="https://docs.docker.com/compose/overview" rel="nofollow">参考</a> )</h3>
<hr>
<div class="highlight highlight-source-shell"><pre>docker-compose [选项] [子命令]</pre></div>
<h5>命令选项列表</h5>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>指定配置文件, 默认为 <strong>./docker-compose.yml</strong></td>
</tr>
<tr>
<td>-p</td>
<td>设置项目名, 默认为配置文件上级目录名</td>
</tr>
<tr>
<td>--verbose</td>
<td>输出详细信息</td>
</tr>
<tr>
<td>-H</td>
<td>指定docker服务器, 相当于 <strong>docker -H</strong></td>
</tr>
</tbody>
</table>
<h5>子命令列表</h5>
<table role="table">
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>构建或重建服务依赖的镜像 ( 配置文件指定 <strong>build</strong> 而不是 <strong>image</strong> )</td>
</tr>
<tr>
<td>config</td>
<td>校验文件并显示解析后的配置</td>
</tr>
<tr>
<td>images</td>
<td>列出容器使用的镜像</td>
</tr>
<tr>
<td>events</td>
<td>监控服务下容器的事件</td>
</tr>
<tr>
<td>logs</td>
<td>显示容器的输出内容 相当于 <strong>docker logs</strong></td>
</tr>
<tr>
<td>port</td>
<td>打印绑定的开放端口</td>
</tr>
<tr>
<td>ps</td>
<td>显示当前项目下的容器，加 <strong>-p</strong> 选项来指定项目名 相当于 <strong>docker ps</strong></td>
</tr>
<tr>
<td>help</td>
<td>命令帮助</td>
</tr>
<tr>
<td>pull</td>
<td>拉取服务用到的镜像 相当于 <strong>docker pull</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>up</td>
<td>项目下创建服务并启动容器，如果指定了项目名，其他操作也要带上项目名参数。容器名格式：<strong>[ 项目名 ]_[ 服务名 ]_[ 序号 ]</strong></td>
</tr>
<tr>
<td>down</td>
<td>移除 <strong>up</strong> 命令创建的容器、网络、挂载点、镜像</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>pause</td>
<td>暂停服务下所的容器</td>
</tr>
<tr>
<td>unpause</td>
<td>恢复服务下所有暂停的容器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>rm</td>
<td>删除服务下停止的容器</td>
</tr>
<tr>
<td>exec</td>
<td>在服务下启动的容器中运行命令 相当于 <strong>docker exec</strong>,</td>
</tr>
<tr>
<td>run</td>
<td>服务下创建并运行容器 相当于 <strong>docker run</strong> ,与 <strong>up</strong> 命令的区别在于端口要另外映射，且不受 <strong>start/stop/restart/kill</strong> 等命令影响，容器名格式：<strong>[ 项目名 ]_[ 服务名 ]_run_[ 序号 ]</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>scale</td>
<td>设置服务的容器数目, 变多就新增, 变少就删除</td>
</tr>
<tr>
<td><code>start</code></td>
<td>开启服务 ( <strong>up</strong> 命令创建的所有容器 ) 相当于 <strong>docker start</strong></td>
</tr>
<tr>
<td><code>stop</code></td>
<td>停止服务 ( <strong>up</strong> 命令创建的所有容器 ) 相当于 <strong>docker stop</strong></td>
</tr>
<tr>
<td><code>restart</code></td>
<td>重启服务 ( <strong>up</strong> 命令创建的所有容器 ) 相当于 <strong>docker restart</strong></td>
</tr>
<tr>
<td>kill</td>
<td>向服务发送信号 ( <strong>up</strong> 命令创建的所有容器 ) 相当于 <strong>docker kill</strong></td>
</tr>
</tbody>
</table>
<h3>docker-compose.yml 语法 ( <a href="http://www.cnblogs.com/freefei/p/5311294.html" rel="nofollow">参考</a>、<a href="https://deepzz.com/post/docker-compose-file.html" rel="nofollow">进阶用法</a> )</h3>
<hr>
<ul>
<li><strong>示例结构：</strong></li>
</ul>
<div class="highlight highlight-source-yaml"><pre><span class="pl-ent">networks</span>: <span class="pl-s">{}</span>
<span class="pl-ent">services</span>:
<span class="pl-ent">  [service-name-1]</span>:
<span class="pl-ent">    image</span>: <span class="pl-s">...</span>
<span class="pl-ent">    network_mode</span>: <span class="pl-s">bridge</span>
<span class="pl-ent">    ports</span>:
<span class="pl-s">      \- 8080:8080/tcp</span>
<span class="pl-s">    ...</span>
<span class="pl-s">  ...</span>
<span class="pl-ent">  [service-name-N]</span>:
<span class="pl-ent">    image</span>: <span class="pl-s">...</span>
<span class="pl-ent">    network_mode</span>: <span class="pl-s">bridge</span>
<span class="pl-ent">    ports</span>:
<span class="pl-s">      \- 8080:8080/tcp</span>
<span class="pl-s">    ...</span>
<span class="pl-c"><span class="pl-c">#</span> 指定 docker-compose 语法的版本</span>
<span class="pl-ent">version</span>: <span class="pl-s"><span class="pl-pds">'</span>2.1<span class="pl-pds">'</span></span>
<span class="pl-ent">volumes</span>: <span class="pl-s">{}</span></pre></div>
<p><code>一般只写第二层 [services] 的内容即可, 如果要指定语法版本则要从最外层开始写。</code></p>
<h3>示例</h3>
<hr>
<p>以我去年写的一篇 <a href="http://www.jianshu.com/p/62790429acef" rel="nofollow">websocket 文章</a> 中的项目作为示例</p>
<p>在当前目录下创建 <strong>docker-compose.yml</strong></p>
<div class="highlight highlight-source-yaml"><pre><span class="pl-c"><span class="pl-c">#</span> tomcat版</span>
<span class="pl-ent">demo-websocket-tomcat</span>:
  <span class="pl-c"><span class="pl-c">#</span> 指定用于构建镜像的Dockerfile路径, 值为字符串</span>
  <span class="pl-ent">build</span>: <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>
  <span class="pl-c"><span class="pl-c">#</span> 设置容器用户名(镜像中已创建)，默认root</span>
  <span class="pl-ent">user</span>: <span class="pl-s">user_docker</span>
  <span class="pl-c"><span class="pl-c">#</span> 设置容器主机名</span>
  <span class="pl-ent">hostname</span>: <span class="pl-s">docker-anyesu</span>
  <span class="pl-c"><span class="pl-c">#</span> 容器内root账户是否拥有宿主机root账户的所有权限 [参考](http://blog.csdn.net/halcyonbaby/article/details/43499409)</span>
  <span class="pl-ent">privileged</span>: <span class="pl-c1">false</span>
  <span class="pl-c"><span class="pl-c">#</span> always (当容器退出时docker自动重启它)</span>
  <span class="pl-c"><span class="pl-c">#</span> on-failure:10 (当容器非正常退出, 最多自动重启10次, 10之后不再重启)</span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
  <span class="pl-c"><span class="pl-c">#</span> 容器的网络连接类型,anyesu_net是创建的自定义网桥</span>
  <span class="pl-ent">net</span>: <span class="pl-s">anyesu_net</span>
  <span class="pl-c"><span class="pl-c">#</span> 挂载点，设置与宿主机之间的路径映射</span>
  <span class="pl-ent">volumes</span>:
  - <span class="pl-s">/usr/anyesu/docker/tomcat-logs:/usr/anyesu/tomcat/logs</span>
  <span class="pl-c"><span class="pl-c">#</span> :ro表示只读,默认为:rw</span>
  <span class="pl-c"><span class="pl-c">#</span>- /usr/anyesu/docker/tomcat-logs:/usr/anyesu/tomcat/logs:ro</span>
  <span class="pl-c"><span class="pl-c">#</span> 与宿主机之间的端口映射</span>
  <span class="pl-ent">ports</span>:
  - <span class="pl-c1">8080:8080</span>
  <span class="pl-c"><span class="pl-c">#</span> 设置容器dns, 如果设置了net项则此项失效, 暂不清楚原因, 不过可以使用本地文件映射为容器的/etc/resolv.conf文件。</span>
  <span class="pl-ent">dns</span>: <span class="pl-s">8.8.8.8</span>
  <span class="pl-c"><span class="pl-c">#</span> 设置容器环境变量</span>
  <span class="pl-ent">environment</span>:
    <span class="pl-ent">JAVA_OPTS</span>: <span class="pl-s">-Djava.security.egd=file:/dev/./urandom</span>

<span class="pl-c"><span class="pl-c">#</span> nodejs版</span>
<span class="pl-ent">demo-websocket-nodejs</span>:
  <span class="pl-c"><span class="pl-c">#</span> 使用镜像</span>
  <span class="pl-ent">image</span>: <span class="pl-s">node:alpine</span>
  <span class="pl-ent">privileged</span>: <span class="pl-c1">false</span>
  <span class="pl-ent">restart</span>: <span class="pl-s">always</span>
  <span class="pl-ent">volumes</span>:
  - <span class="pl-s">/usr/anyesu/docker/websocket-master/Nodejs-Websocket:/usr/anyesu/node</span>
  <span class="pl-ent">ports</span>:
  - <span class="pl-c1">3000:8080</span>
  - <span class="pl-c1">3002:3002</span>
  <span class="pl-c"><span class="pl-c">#</span> 覆盖容器启动后默认执行的命令</span>
  <span class="pl-ent">command</span>: <span class="pl-s">sh -c "npm install ws@1.1.0 express -g &amp;&amp; node /usr/anyesu/node/server.js"</span>
  <span class="pl-ent">environment</span>:
    <span class="pl-ent">NODE_PATH</span>: <span class="pl-s">/usr/local/lib/node_modules</span></pre></div>
<p>再创建 <strong>Dockerfile</strong> 文件, 用于构建镜像</p>
<div class="highlight highlight-source-dockerfile"><pre><span class="pl-k">FROM</span> alpine:latest
<span class="pl-k">MAINTAINER</span> anyesu

<span class="pl-k">RUN</span> echo -e <span class="pl-s">"https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main<span class="pl-c1">\n</span>\</span>
<span class="pl-s">https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/community"</span> &gt; /etc/apk/repositories &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 设置时区</span>
    apk --update add ca-certificates &amp;&amp; \
    apk add tzdata &amp;&amp; \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \
    echo <span class="pl-s">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 安装jdk</span>
    apk add openjdk7=7.121.2.6.8-r0 &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 安装wget</span>
    apk add wget=1.18-r1 &amp;&amp; \
    tmp=/usr/anyesu/tmp &amp;&amp; \
    mkdir -p $tmp &amp;&amp; \
    cd /usr/anyesu &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 下载tomcat</span>
    wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.94/bin/apache-tomcat-7.0.94.tar.gz &amp;&amp; \
    tar -zxvf apache-tomcat-7.0.94.tar.gz &amp;&amp; \
    mv apache-tomcat-7.0.94 tomcat &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 清空webapps下自带项目</span>
    rm -r tomcat/webapps/* &amp;&amp; \
    rm apache-tomcat-7.0.94.tar.gz &amp;&amp; \
    cd $tmp &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 下载websocket-demo源码</span>
    wget https://github.com/anyesu/websocket/archive/master.zip &amp;&amp; \
    unzip master.zip &amp;&amp; \
    proj=$tmp/websocket-master/Tomcat-Websocket &amp;&amp; \
    src=$proj/src &amp;&amp; \
    tomcatBase=/usr/anyesu/tomcat &amp;&amp; \
    classpath=<span class="pl-s">"$tomcatBase/lib/servlet-api.jar:$tomcatBase/lib/websocket-api.jar:$proj/WebRoot/WEB-INF/lib/fastjson-1.1.41.jar"</span> &amp;&amp; \
    output=$proj/WebRoot/WEB-INF/classes &amp;&amp; \
    mkdir -p $output &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 编译java代码</span>
    /usr/lib/jvm/java-1.7-openjdk/bin/javac -sourcepath $src -classpath $classpath -d $output `find $src -name <span class="pl-s">"*.java"</span>` &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 拷贝到tomcat</span>
    mv $proj/WebRoot $tomcatBase/webapps/ROOT &amp;&amp; \
    rm -rf $tmp &amp;&amp; \
    apk del wget &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 清除apk缓存</span>
    rm -rf /var/cache/apk/* &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 添加普通用户</span>
    addgroup -S group_docker &amp;&amp; adduser -S -G group_docker user_docker &amp;&amp; \
    <span class="pl-c"><span class="pl-c">#</span> 修改目录所有者</span>
    chown user_docker:group_docker -R /usr/anyesu

<span class="pl-c"><span class="pl-c">#</span> 设置环境变量</span>
<span class="pl-k">ENV</span> JAVA_HOME /usr/lib/jvm/java-1.7-openjdk
<span class="pl-k">ENV</span> CATALINA_HOME /usr/anyesu/tomcat
<span class="pl-k">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin

<span class="pl-c"><span class="pl-c">#</span> 暴露端口</span>
<span class="pl-k">EXPOSE</span> 8080

<span class="pl-c"><span class="pl-c">#</span> 启动命令（前台程序）</span>
<span class="pl-k">CMD</span> [<span class="pl-s">"catalina.sh"</span>, <span class="pl-s">"run"</span>]</pre></div>
<p>接着就可以构建并运行了</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 创建一个名为anyesu_net、网段为172.18.0.0的网桥(docker默认创建的网段为172.17.0.0)</span>
docker network create --subnet=172.18.0.0/16 anyesu_net

<span class="pl-c"><span class="pl-c">#</span> 子命令 up 选项:</span>
<span class="pl-c"><span class="pl-c">#</span> -d 后台运行</span>
<span class="pl-c"><span class="pl-c">#</span> --build 重新构建依赖的镜像(如果docker-compose.yml中指定了build项的话)</span>
<span class="pl-c"><span class="pl-c">#</span> --force-recreate 重启容器, 即使配置和镜像都没有改变</span>
wget https://github.com/anyesu/websocket/archive/master.zip
unzip master.zip
sed -i <span class="pl-s"><span class="pl-pds">'</span>s$8082$3002$<span class="pl-pds">'</span></span> ./websocket-master/Nodejs-Websocket/server.js
sed -i <span class="pl-s"><span class="pl-pds">'</span>s$8082$3002$<span class="pl-pds">'</span></span> ./websocket-master/Nodejs-Websocket/js/chat.js
sudo docker-compose up -d --build --force-recreate</pre></div>
<p>之后就可以通过 <strong>ip:8080</strong> 或 <strong>ip:3000</strong> 访问这两个项目了 ( 注意防火墙开放这两个端口哦 )</p>
<h5>说明：</h5>
<ul>
<li><strong>上面的两个项目分别展示了 docker 的两种使用方式：</strong></li>
</ul>
<blockquote>
<ol>
<li>环境和应用打包到一个镜像中作为一个整体</li>
<li>环境和应用独立，可以自由组合</li>
</ol>
</blockquote>
<ul>
<li><strong>关于 docker-compose 的 build 操作网上的介绍比较少，有几点要注意的：</strong></li>
</ul>
<blockquote>
<ol>
<li>配置文件中 <strong>build</strong> 参数内容指定 <strong>Dockerfile</strong> 文件的路径, 貌似在高版本中可以是 map 类型</li>
<li><strong>build</strong> 操作需要使用 <strong>sudo</strong> 提权，否则会报一些奇怪的错误</li>
</ol>
</blockquote>
<ul>
<li>
<p><strong>将日志文件映射到宿主机目录上方便查看，如果源码不想打包到镜像中也可以做映射。还有一个小技巧，用空目录映射镜像已有目录达到删除的效果，如 <code>tomcat/webapps</code> 下的自带应用是没用的，可以用这个方法清除。</strong></p>
</li>
<li>
<p><strong><code>JVM 参数</code> 可以配置在环境变量 <code>JAVA_OPTS</code> 中。使用 nodejs 的全局安装 ( <code>-g</code> ) 时别忘了设置 <code>NODE_PATH</code></strong></p>
</li>
<li>
<p><strong><code>command</code> 只能运行一条命令，如果要运行多条就使用 <code>sh -c "..."</code>, 实际命令用 <code>&amp;&amp;</code> 隔开做参数传入</strong></p>
</li>
<li>
<p><strong>websocket 的 <a href="https://github.com/anyesu/websocket">demo源码</a> 有不少同学反映项目配置不起来，研究下上面的 <code>Dockerfile</code> 和 <code>docker-compose.yml</code> 应该就能对项目的结构和依赖有更清晰的了解了。</strong></p>
</li>
<li>
<p><strong>在 <code>demo-websocket-tomcat</code> 项目的配置中, 出于 <a href="http://blog.csdn.net/Ruidu_Doer/article/details/53401523" rel="nofollow">安全</a> 考虑，使用普通用户登录。宿主机的 <code>/usr/anyesu/tomcat/logs</code> 目录要设置 <code>777</code> 权限，否则 <code>tomcat</code> 无法写日志。</strong></p>
</li>
<li>
<p><strong>容器的配置信息, <code>hosts</code> ,  <code>dns</code> 配置文件等可以在 <code>/var/lib/docker/containers/[容器id]/</code> 下查看。</strong></p>
</li>
</ul>
<h5>遇到的坑：</h5>
<p>之前一个原本启动只要 10 秒的小项目在容器中有时候重启要好几分钟甚至可能会一直启不来，在日志中找到下面这段内容：</p>
<blockquote>
<p>INFO: Deploying web application directory /usr/anyesu/tomcat/webapps/ROOT<br>
Jun 10, 2017 3:03:28 PM org.apache.catalina.startup.TldConfig execute<br>
INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.<br>
Jun 10, 2017 3:14:01 PM org.apache.catalina.util.SessionIdGeneratorBase createSecureRandom<br>
INFO: <strong>Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [624,301] milliseconds.</strong><br>
Jun 10, 2017 3:14:05 PM org.apache.catalina.startup.HostConfig deployDirectory<br>
INFO: Deployment of web application directory /usr/fuyou/tomcat/webapps/ROOT has finished in 644,588 ms<br>
Jun 10, 2017 3:14:05 PM org.apache.coyote.AbstractProtocol start<br>
INFO: Starting ProtocolHandler ["http-bio-8080"]<br>
Jun 10, 2017 3:14:05 PM org.apache.coyote.AbstractProtocol start<br>
INFO: Starting ProtocolHandler ["ajp-bio-8009"]<br>
Jun 10, 2017 3:14:05 PM org.apache.catalina.startup.Catalina start<br>
INFO: Server startup in 644776 ms</p>
</blockquote>
<p>关键的一句就是: <strong>Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [624,301] milliseconds</strong><br>
这个步骤竟然用了10分钟！查了一下发现是 <strong>docker</strong> 容器下 <a href="http://hongjiang.info/tomcat-startup-slowly-in-docker" rel="nofollow">随机数与熵池策略</a> 有问题。<br>
解决方法如下，个人更推荐第二种：</p>
<ul>
<li>打开 <strong>$JAVA_PATH/jre/lib/security/java.security</strong>，将<br>
<strong>securerandom.source=file:/dev/random</strong> 替换为 <strong>securerandom.source=file:/dev/urandom</strong></li>
<li>启动容器时，使用 <strong>JVM 参数</strong>：<code>JAVA_OPTS=-Djava.security.egd=file:/dev/./urandom</code></li>
</ul>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/ee8e7d2eb645">http://www.jianshu.com/p/ee8e7d2eb645</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker 常用指令详解]]></title>
            <link>https://anyesu.github.io/blog/articles/10</link>
            <guid>10</guid>
            <pubDate>Fri, 26 Apr 2019 15:11:22 GMT</pubDate>
            <description><![CDATA[前言 在 上一篇文章 中已经介绍了 Docker 相关的概念以及 Docker 的安装, 下面正式进入 Docker 的使用。Docker 分为客户端和服务端两部分, docker 为客户端调用的命令, dockerd 为服务端调用的命令, 本文着重介绍客户端的用法。 主要用法：docker  [ docker命令选项 ] [ 子命令 ] [ 子命令选项 ] docker [ 子命令 ] --he]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p>在 <a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">上一篇文章</a> 中已经介绍了 <strong>Docker</strong> 相关的概念以及 <strong>Docker</strong> 的安装, 下面正式进入 <strong>Docker</strong> 的使用。<strong>Docker</strong> 分为客户端和服务端两部分, <code>docker</code> 为客户端调用的命令, <code>dockerd</code> 为服务端调用的命令, 本文着重介绍客户端的用法。</p>
<h5>主要用法：<strong>docker  [ docker命令选项 ] [ 子命令 ] [ 子命令选项 ]</strong></h5>
<blockquote>
<p><strong>docker [ 子命令 ] --help</strong> 可查看每个子命令的详细用法。</p>
</blockquote>
<h3>Docker 命令选项列表</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>--config [string]</td>
<td>客户端本地配置文件路径</td>
<td>默认为 <strong>~/.docker</strong></td>
</tr>
<tr>
<td>-D, --debug</td>
<td>启用调试模式</td>
<td></td>
</tr>
<tr>
<td>--help</td>
<td>打印用法</td>
<td></td>
</tr>
<tr>
<td>-H, --host list</td>
<td>通过 <strong>socket</strong> 访问指定的 <strong>docker</strong> 守护进程 ( 服务端 )</td>
<td><strong>unix://</strong> , <strong>fd://</strong> , <strong>tcp://</strong></td>
</tr>
<tr>
<td>-l, --log-level [string]</td>
<td>设置日志级别 ( <strong>debug</strong> 、<strong>info</strong> 、<strong>warn</strong> 、<strong>error</strong> 、<strong>fatal</strong> )</td>
<td>默认为 <strong>info</strong></td>
</tr>
<tr>
<td>--tls</td>
<td>启用 <strong>TLS</strong> 加密</td>
<td></td>
</tr>
<tr>
<td>--tlscacert [string]</td>
<td>指定信任的 <strong>CA 根证书</strong> 路径</td>
<td>默认为 <strong>~/.docker/ca.pem</strong></td>
</tr>
<tr>
<td>--tlscert [string]</td>
<td>客户端证书路径</td>
<td>默认为 <strong>~/.docker/cert.pem</strong></td>
</tr>
<tr>
<td>--tlskey [string]</td>
<td>客户端证书私钥路径</td>
<td>默认为 <strong>~/.docker/key.pem</strong></td>
</tr>
<tr>
<td>--tlsverify</td>
<td>启用 <strong>TLS</strong> 加密并验证客户端证书</td>
<td></td>
</tr>
<tr>
<td>-v, --version</td>
<td>打印 <strong>docker</strong> 客户端版本信息</td>
<td> </td>
</tr>
</tbody>
</table>
<h3>1. 镜像仓库相关</h3>
<hr>
<h4>1.1 查找镜像</h4>
<blockquote>
<p><strong>docker search [ 条件 ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 查询三颗星及以上名字包含alpine的镜像</span>
docker search -f=stars=3 alpine</pre></div>
<h4>1.2 获取镜像</h4>
<blockquote>
<p><strong>docker pull [ 仓库 ]:[ tag ]</strong></p>
</blockquote>
<p>仓库格式为 <strong>[仓库url]/[用户名]/[应用名]</strong> , 除了官方仓库外的第三方仓库要指定 <strong>url</strong>, 用户名就是在对应仓库下建立的账户, 一般只有应用名的仓库代表 <strong>官方镜像</strong>, 如 <strong>ubuntu</strong>、<strong>tomcat</strong> 等, 而 <code>tag</code> 表示镜像的版本号, 不指定时默认为 <code>latest</code></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 获取alpine Linux 的镜像</span>
docker pull alpine</pre></div>
<h4>1.3 推送镜像到仓库</h4>
<blockquote>
<p><strong>docker push [ 镜像名 ]:[ tag ]</strong></p>
</blockquote>
<p>当然, 需要先登录</p>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker push alpine
The push refers to a repository [docker.io/library/alpine]
3fb66f713c9f: Layer already exists
errors:
denied: requested access to the resource is denied(没有权限, 需要登录帐号)
unauthorized: authentication required</pre></div>
<h4>1.4 登录/退出第三方仓库</h4>
<blockquote>
<p><strong>docker [ login/logout ] [ 仓库地址 ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 登录</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker login daocloud.io
Username (username): username
Password:
Login Succeeded
<span class="pl-c"><span class="pl-c">#</span> 退出</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker <span class="pl-c1">logout</span> daocloud.io
Removing login credentials <span class="pl-k">for</span> daocloud.io</pre></div>
<h3>2. 本地镜像</h3>
<hr>
<h4>2.1 查看本地镜像</h4>
<blockquote>
<p><strong>docker images</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
alpine              latest              a41a7446062d        14 hours ago        3.97MB
hello-world         latest              48b5124b2768        4 months ago        1.84kB</pre></div>
<h4>2.2 删除本地镜像</h4>
<blockquote>
<p><strong>docker rmi [ 镜像名 or 镜像 id ]</strong></p>
</blockquote>
<p>如果用 <strong>镜像 id</strong> 作为参数, 可以只输入前几位, 能唯一确定即可 ( 可以同时删除多个镜像, 空格隔开 )。此外, 如果已经使用该 <strong>镜像</strong> 启动了 <strong>容器</strong> 需要先删除 <strong>容器</strong>。</p>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker rmi a41
Untagged: alpine:latest
Untagged: alpine@sha256:0b94d1d1b5eb130dd0253374552445b39470653fb1a1ec2d81490948876e462c
Deleted: sha256:a41a7446062d197dd4b21b38122dcc7b2399deb0750c4110925a7dd37c80f118
Deleted: sha256:3fb66f713c9fa9debcdaa58bb9858bd04c17350d9614b7a250ec0ee527319e59</pre></div>
<h4>2.3 查看镜像详情</h4>
<blockquote>
<p><strong>docker inspect [ 镜像名 or 镜像 id ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker inspect a41
[
    {
        <span class="pl-s"><span class="pl-pds">"</span>Id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>sha256:a41a7446062d197dd4b21b38122dcc7b2399deb0750c4110925a7dd37c80f118<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>RepoTags<span class="pl-pds">"</span></span>: [
            <span class="pl-s"><span class="pl-pds">"</span>alpine:latest<span class="pl-pds">"</span></span>
        ],
        <span class="pl-s"><span class="pl-pds">"</span>RepoDigests<span class="pl-pds">"</span></span>: [
            <span class="pl-s"><span class="pl-pds">"</span>alpine@sha256:0b94d1d1b5eb130dd0253374552445b39470653fb1a1ec2d81490948876e462c<span class="pl-pds">"</span></span>
        ],
        <span class="pl-s"><span class="pl-pds">"</span>Parent<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>Comment<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>Created<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2017-05-25T23:33:22.029729271Z<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>Container<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>19ee1cd90c07eb7b3c359aaec3706e269a871064cca47801122444cef51c5038<span class="pl-pds">"</span></span>,
    ......
        }
    }
]
</pre></div>
<h4>2.4 打包本地镜像, 使用压缩包来完成迁移</h4>
<blockquote>
<p><strong>docker save [ 镜像名 ] &gt; [ 文件路径 ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 默认为文件流输出</span>
docker save alpine <span class="pl-k">&gt;</span> /usr/anyesu/docker/alpine.img

<span class="pl-c"><span class="pl-c">#</span> 或者使用 '-o' 选项指定输出文件路径</span>
docker save -o /usr/anyesu/docker/alpine.img alpine</pre></div>
<h4>2.5 导入镜像压缩包</h4>
<blockquote>
<p><strong>docker load &lt; [ 文件路径 ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 默认从标准输入读取</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker load <span class="pl-k">&lt;</span> /usr/anyesu/docker/alpine.img
3fb66f713c9f: Loading layer [<span class="pl-k">==================================================&gt;</span>]  4.221MB/4.221MB
Loaded image: alpine:latest

<span class="pl-c"><span class="pl-c">#</span> 用 '-i' 选项指定输入文件路径</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker load -i /usr/anyesu/docker/alpine.img
Loaded image: alpine:latest
Loaded image ID: sha256:665ffb03bfaea7d8b7472edc0a741b429267db249b1fcead457886e861eae25f
Loaded image ID: sha256:a41a7446062d197dd4b21b38122dcc7b2399deb0750c4110925a7dd37c80f118</pre></div>
<h4>2.6 修改镜像tag</h4>
<blockquote>
<p><strong>docker tag [ 镜像名 or 镜像 id ] [ 新镜像名 ]:[ 新 tag ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker tag a41 anyesu/alpine:1.0
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
anyesu/alpine       1.0                 a41a7446062d        15 hours ago        3.97MB
alpine              latest              a41a7446062d        15 hours ago        3.97MB
hello-world         latest              48b5124b2768        4 months ago        1.84kB</pre></div>
<h3>3. 容器相关</h3>
<hr>
<h4>3.1 创建、启动容器并执行相应的命令</h4>
<blockquote>
<p><strong>docker run [ 参数 ] [ 镜像名 or 镜像 id ] [ 命令 ]</strong></p>
</blockquote>
<p>如果没有指定命令时就执行 <strong>镜像</strong> 中默认的命令, 创建 <strong>镜像</strong> 的时候可设置默认命令。另外要注意的一点, 启动 <strong>容器</strong> 后要执行一个前台进程 ( 就是能在控制台不断输出的或者一直等待的那种程序, 如 <strong>tomcat</strong> 的 <strong>catalina.sh</strong> ) 才能使 <strong>容器</strong> 保持运行状态, 否则, 命令执行完 <strong>容器</strong> 就关闭了, 像下面这个例子执行完就直接结束了。</p>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker run hello-world

Hello from Docker<span class="pl-k">!</span>
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="pl-s"><span class="pl-pds">"</span>hello-world<span class="pl-pds">"</span></span> image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/</pre></div>
<h4>run 命令常用选项</h4>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>后台运行容器, 并返回容器ID；不指定时, 启动后开始打印日志, <code>Ctrl + C</code> 退出命令同时会关闭容器</td>
</tr>
<tr>
<td>-i</td>
<td>以交互模式运行容器, 通常与 <strong>-t</strong> 同时使用；</td>
</tr>
<tr>
<td>-t</td>
<td>为容器重新分配一个伪输入终端, 通常与 <strong>-i</strong> 同时使用</td>
</tr>
<tr>
<td>--name "anyesu-container"</td>
<td>为容器指定一个别名, 不指定时随机生成</td>
</tr>
<tr>
<td>-h docker-anyesu</td>
<td>设置容器的主机名, 默认随机生成</td>
</tr>
<tr>
<td>--dns 8.8.8.8</td>
<td>指定容器使用的 <strong>DNS</strong> 服务器, 默认和宿主机一致</td>
</tr>
<tr>
<td>-e docker_host=172.17.0.1</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>--cpuset="0-2" or --cpuset="0,1,2"</td>
<td>绑定容器到指定 <strong>CPU</strong> 运行</td>
</tr>
<tr>
<td>-m 100M</td>
<td>设置容器使用内存最大值</td>
</tr>
<tr>
<td>--net bridge</td>
<td>指定容器的网络连接类型, 支持 <strong>bridge</strong> / <strong>host</strong> / <strong>none</strong> / <strong>container</strong> 四种类型</td>
</tr>
<tr>
<td>--ip 172.18.0.13</td>
<td>为容器分配固定 <strong>ip</strong> ( 需要使用自定义网络 )</td>
</tr>
<tr>
<td>--expose 8081 --expose 8082</td>
<td>开放一个端口或一组端口, 会覆盖镜像设置中开放的端口</td>
</tr>
<tr>
<td>-p [宿主机端口]:[容器内端口]</td>
<td>宿主机到容器的端口映射, 可指定宿主机的要监听的 <strong>ip</strong>, 默认为 <strong>0.0.0.0</strong></td>
</tr>
<tr>
<td>-P</td>
<td>注意是大写的, 宿主机随机指定一组可用的端口映射容器 <strong>expose</strong> 的所有端口</td>
</tr>
<tr>
<td>-v [宿主机目录路径]:[容器内目录路径]</td>
<td>挂载宿主机的指定目录 ( 或文件 ) 到容器内的指定目录 ( 或文件 )</td>
</tr>
<tr>
<td>--add-host [主机名]:[ip]</td>
<td>为容器 <strong>hosts</strong> 文件追加 <strong>host</strong> , 默认会在 <strong>hosts</strong> 文件最后追加内容：<code>[主机名]:[容器ip]</code></td>
</tr>
<tr>
<td>--volumes-from [其他容器名]</td>
<td>将其他容器的数据卷添加到此容器</td>
</tr>
<tr>
<td>--link [其他容器名]:[在该容器中的别名]</td>
<td>添加链接到另一个容器, 在本容器 <strong>hosts</strong> 文件中加入关联容器的记录, 效果类似于 <strong>--add-host</strong></td>
</tr>
</tbody>
</table>
<p><strong>一个较完整的例子：</strong></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 创建一个名为anyesu_net、网段为172.18.0.0的网桥(docker默认创建的网段为172.17.0.0)</span>
docker network create --subnet=172.18.0.0/16 anyesu_net

<span class="pl-c"><span class="pl-c">#</span> 创建并启动一个配置复杂的容器</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker run -d --name anyesu-container -h docker-anyesu --dns 8.8.8.8 -e docker_host=172.18.0.1 -e docker_host2=172.18.0.2 --net anyesu_net --ip 172.18.0.13 --expose 8081 --expose 8082 -P -p 8000:8000 -p 8001:8001 -v /usr/anyesu:/usr/anyesu --add-host anyesu_host:172.18.0.1 tomcat:7
912e6632161de0783a057aa02380e676753f66cfb367ef1686d4d09cdc931659
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                                                                                         NAMES
912e6632161d        tomcat:7              <span class="pl-s"><span class="pl-pds">"</span>catalina.sh run<span class="pl-pds">"</span></span>   6 seconds ago       Up 5 seconds        0.0.0.0:8000-8001-<span class="pl-k">&gt;</span>8000-8001/tcp, 0.0.0.0:32783-<span class="pl-k">&gt;</span>8080/tcp, 0.0.0.0:32782-<span class="pl-k">&gt;</span>8081/tcp, 0.0.0.0:32781-<span class="pl-k">&gt;</span>8082/tcp   anyesu-container
 </pre></div>
<blockquote>
<p><strong>单字符选项可以合并, 如 <code>-i -t</code> 可以合并为 <code>-it</code></strong></p>
</blockquote>
<h4>3.2 查看运行中的容器</h4>
<div class="highlight highlight-source-shell"><pre>docker ps</pre></div>
<p>加 <code>-a</code> 选项可查看所有的 <strong>容器</strong></p>
<h4>3.3 开启/停止/重启容器</h4>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 关闭容器(发送SIGTERM信号,做一些'退出前工作',再发送SIGKILL信号)</span>
docker stop anyesu-container
<span class="pl-c"><span class="pl-c">#</span> 强制关闭容器(默认发送SIGKILL信号, 加-s参数可以发送其他信号)</span>
docker <span class="pl-c1">kill</span> anyesu-container
<span class="pl-c"><span class="pl-c">#</span> 启动容器</span>
docker start anyesu-container
<span class="pl-c"><span class="pl-c">#</span> 重启容器</span>
docker restart anyesu-container</pre></div>
<h4>3.4 删除容器</h4>
<blockquote>
<p><strong>docker rm [ 容器名 or 容器 id ]</strong></p>
</blockquote>
<p>可以指定多个容器一起删除, 加 <code>-f</code> 选项可强制删除正在运行的 <strong>容器</strong></p>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                                                                                                         NAMES
fd7a6c1ba0f0        tomcat              <span class="pl-s"><span class="pl-pds">"</span>catalina.sh run<span class="pl-pds">"</span></span>   20 seconds ago       Up 18 seconds       0.0.0.0:32798-<span class="pl-k">&gt;</span>8080/tcp, 0.0.0.0:32797-<span class="pl-k">&gt;</span>8081/tcp, 0.0.0.0:32796-<span class="pl-k">&gt;</span>8082/tcp                                     musing_newton
61941bea1c87        tomcat              <span class="pl-s"><span class="pl-pds">"</span>catalina.sh run<span class="pl-pds">"</span></span>   About a minute ago   Up About a minute   0.0.0.0:8000-8001-<span class="pl-k">&gt;</span>8000-8001/tcp, 0.0.0.0:32795-<span class="pl-k">&gt;</span>8080/tcp, 0.0.0.0:32794-<span class="pl-k">&gt;</span>8081/tcp, 0.0.0.0:32793-<span class="pl-k">&gt;</span>8082/tcp   anyesu-container
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker rm musing_newton anyesu-container -f
musing_newton
anyesu-container</pre></div>
<h4>3.5 查看容器详情</h4>
<blockquote>
<p><strong>docker inspect [ 容器名 or 容器 id ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>docker inspect anyesu-container</pre></div>
<h4>3.6 查看容器中正在运行的进程</h4>
<blockquote>
<p><strong>docker top [ 容器名 or 容器 id ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker top anyesu-container
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                31769               31752               1                   00:26               <span class="pl-k">?</span>                   00:00:03            /docker-java-home/jre/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</pre></div>
<h4>3.7 将容器保存为镜像</h4>
<blockquote>
<p><strong>docker commit [ 容器名 or 容器 id ] [ 镜像名 ]:[ tag ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre>ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker commit anyesu-container anyesu/tomcat:1.0
sha256:582fcffd3209a2478e2179c9381a1ef67e0df9ba95aba713875c0857f5dae4e5
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
anyesu/tomcat       1.0                 582fcffd3209        2 seconds ago       334MB
alpine              latest              a41a7446062d        17 hours ago        3.97MB
tomcat              latest              3695a0fe8320        2 days ago          334MB
hello-world         latest              48b5124b2768        4 months ago        1.84kB</pre></div>
<h4>3.8 使用 Dockerfile 构建镜像</h4>
<blockquote>
<p><strong>docker build -t [ 镜像名 ]:[ tag ] -f [ DockerFile 名 ] [ DockerFile 所在目录 ]</strong></p>
</blockquote>
<p>数据是实时更新的, <a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">点击</a> 查看详细用法。</p>
<h3>4. 硬件资源相关</h3>
<hr>
<h4>4.1 显示容器硬件资源使用情况</h4>
<blockquote>
<p><strong>docker stats [ 选项 ] [ 0个或多个正在运行容器 ]</strong></p>
</blockquote>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 不指定容器时显示所有正在运行的容器</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker stats
CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
9bb9d6bed6e6        0.00%               20.57MiB / 864.5MiB   2.38%               104kB / 1.99MB      4.9MB / 4.1kB       11</pre></div>
<h4>4.2 更新容器的硬件资源限制</h4>
<blockquote>
<p><strong>docker update [ 选项 ]</strong></p>
</blockquote>
<p>这个操作可能会输出下面的错误内容：</p>
<blockquote>
<p>Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap</p>
</blockquote>
<p><a href="https://segmentfault.com/q/1010000002888521#a-1020000002890127" rel="nofollow">解决办法</a></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> /etc/default/grub</span>
sudo vi /etc/default/grub

<span class="pl-c"><span class="pl-c">#</span> 添加内核启动参数</span>
GRUB_CMDLINE_LINUX=<span class="pl-s"><span class="pl-pds">"</span>...   cgroup_enable=memory swapaccount=1<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">#</span> 更新 grub</span>
sudo update-grub

<span class="pl-c"><span class="pl-c">#</span> 重启</span>
sudo reboot</pre></div>
<p>注意是在 <strong>GRUB_CMDLINE_LINUX</strong> 项 <strong>追加</strong> 上述参数内容, 我试过简单粗暴的在文件末尾添加下面内容, 这么做会覆盖原有的启动参数, 导致网络连接失败。网络坏了, <strong>ssh</strong> 都连不上了, 幸好可以在 <strong>腾讯云</strong> 的网页控制台登录, 修改内容重启就好了。所以呢, 这一步操作一定要慎重。</p>
<h4>4.3 使用压力测试工具 <code>stress</code> 验证效果</h4>
<p>使用已有的 <strong>stress</strong> 镜像 <a href="https://hub.docker.com/r/progrium/stress" rel="nofollow">progrium/stress</a>, 开两个终端, 在其中一个终端中执行下面的命令</p>
<div class="highlight highlight-source-shell"><pre>docker run -m 100m --rm -it progrium/stress --cpu 2 --io 1 --vm 10 --vm-bytes 9M</pre></div>
<p>在另一个终端执行 <code>docker stats</code> 进行监控</p>
<div class="highlight highlight-source-shell"><pre>CONTAINER           CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS
9eb0                88.42%              92.22MiB / 100MiB   92.22%              0B / 0B             1.65MB / 2.88MB     14</pre></div>
<p>再开一个终端执行</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 9eb0为容器id开头, 请根据实际情况替换。内存限制只能调大不能调小</span>
docker update -m 200m 9eb0</pre></div>
<h5>相关文章:</h5>
<ul>
<li><a href="http://www.cnblogs.com/liuyansheng/p/6113512.html" rel="nofollow">docker容器的参数如何指定配额</a></li>
<li><a href="http://www.cnblogs.com/ilinuxer/p/6648681.html" rel="nofollow">设置Docker容器中Java应用的内存限制</a></li>
<li><a href="http://blog.csdn.net/candcplusplus/article/details/53728507" rel="nofollow">Docker 运行时资源限制</a></li>
<li><a href="http://blog.csdn.net/s1070/article/details/52301410" rel="nofollow">Docker内存限制</a></li>
</ul>
<h3>基础子命令列表</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>attach</td>
<td>进入运行中的容器, 显示该容器的控制台界面。注意, 从该指令退出会导致容器关闭</td>
</tr>
<tr>
<td>build</td>
<td>根据 <strong>Dockerfile</strong> 文件构建镜像</td>
</tr>
<tr>
<td>commit</td>
<td>提交容器所做的改为为一个新的镜像</td>
</tr>
<tr>
<td>cp</td>
<td>在容器和宿主机之间复制文件</td>
</tr>
<tr>
<td>create</td>
<td>根据镜像生成一个新的容器</td>
</tr>
<tr>
<td>diff</td>
<td>展示容器相对于构建它的镜像内容所做的改变</td>
</tr>
<tr>
<td>events</td>
<td>实时打印服务端执行的事件</td>
</tr>
<tr>
<td>exec</td>
<td>在已运行的容器中执行命令</td>
</tr>
<tr>
<td>export</td>
<td>导出容器到本地快照文件</td>
</tr>
<tr>
<td>history</td>
<td>显示镜像每层的变更内容</td>
</tr>
<tr>
<td>images</td>
<td>列出本地所有镜像</td>
</tr>
<tr>
<td>import</td>
<td>导入本地容器快照文件为镜像</td>
</tr>
<tr>
<td>info</td>
<td>显示 <strong>Docker</strong> 详细的系统信息</td>
</tr>
<tr>
<td>inspect</td>
<td>查看容器或镜像的配置信息, 默认为 <strong>json</strong> 数据</td>
</tr>
<tr>
<td>kill</td>
<td><strong>-s</strong> 选项向容器发送信号, 默认为 <strong>SIGKILL</strong> 信号 ( 强制关闭 )</td>
</tr>
<tr>
<td>load</td>
<td>导入镜像压缩包</td>
</tr>
<tr>
<td>login</td>
<td>登录第三方仓库</td>
</tr>
<tr>
<td>logout</td>
<td>退出第三方仓库</td>
</tr>
<tr>
<td>logs</td>
<td>打印容器的控制台输出内容, <strong>-f</strong> 选项可以持续输出</td>
</tr>
<tr>
<td>pause</td>
<td>暂停容器</td>
</tr>
<tr>
<td>port</td>
<td>容器端口映射列表</td>
</tr>
<tr>
<td>ps</td>
<td>列出正在运行的容器, <strong>-a</strong> 选项显示所有容器</td>
</tr>
<tr>
<td>pull</td>
<td>从镜像仓库拉取镜像</td>
</tr>
<tr>
<td>push</td>
<td>将镜像推送到镜像仓库</td>
</tr>
<tr>
<td>rename</td>
<td>重命名容器名</td>
</tr>
<tr>
<td>restart</td>
<td>重启容器</td>
</tr>
<tr>
<td>rm</td>
<td>删除已停止的容器, <strong>-f</strong> 选项可强制删除正在运行的容器</td>
</tr>
<tr>
<td>rmi</td>
<td>删除镜像 ( 必须先删除该镜像构建的所有容器 )</td>
</tr>
<tr>
<td>run</td>
<td>根据镜像生成并进入一个新的容器</td>
</tr>
<tr>
<td>save</td>
<td>打包本地镜像, 使用压缩包来完成迁移</td>
</tr>
<tr>
<td>search</td>
<td>查找镜像</td>
</tr>
<tr>
<td>start</td>
<td>启动关闭的容器</td>
</tr>
<tr>
<td>stats</td>
<td>显示容器对资源的使用情况 ( 内存、CPU、磁盘等 )</td>
</tr>
<tr>
<td>stop</td>
<td>关闭正在运行的容器</td>
</tr>
<tr>
<td>tag</td>
<td>修改镜像 <strong>tag</strong></td>
</tr>
<tr>
<td>top</td>
<td>显示容器中正在运行的进程 ( 相当于容器内执行 <strong>ps -ef</strong> 命令 )</td>
</tr>
<tr>
<td>unpause</td>
<td>恢复暂停的容器</td>
</tr>
<tr>
<td>update</td>
<td>更新容器的硬件资源限制 ( 内存、CPU 等 )</td>
</tr>
<tr>
<td>version</td>
<td>显示 <strong>Docker</strong> 客户端和服务端版本信息</td>
</tr>
<tr>
<td>wait</td>
<td>阻塞当前命令直到对应的容器被关闭, 容器关闭后打印结束代码</td>
</tr>
<tr>
<td>daemon</td>
<td>这个子命令已 <strong>过期</strong>, 将在 <strong>Docker 17.12</strong> 之后的版本中移出, 直接使用 <strong>dockerd</strong></td>
</tr>
</tbody>
</table>
<h3>用于管理的子命令列表</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>container</td>
<td>管理容器</td>
</tr>
<tr>
<td>image</td>
<td>管理镜像</td>
</tr>
<tr>
<td>network</td>
<td>管理容器网络 ( 默认为 <strong>bridge</strong>、<strong>host</strong>、<strong>none</strong> 三个网络配置)</td>
</tr>
<tr>
<td>plugin</td>
<td>管理插件</td>
</tr>
<tr>
<td>system</td>
<td>管理系统资源。其中, <strong>docker system prune</strong> 命令用于清理没有使用的镜像、容器、数据卷以及网络</td>
</tr>
<tr>
<td>volume</td>
<td>管理数据卷</td>
</tr>
<tr>
<td>swarm</td>
<td>管理 <strong>Swarm</strong> 模式</td>
</tr>
<tr>
<td>service</td>
<td>管理 <strong>Swarm</strong> 模式下的服务</td>
</tr>
<tr>
<td>node</td>
<td>管理 <strong>Swarm</strong> 模式下的 <strong>Docker</strong> 集群中的节点</td>
</tr>
<tr>
<td>secret</td>
<td>管理 <strong>Swarm</strong> 模式下的敏感数据</td>
</tr>
<tr>
<td>stack</td>
<td><strong>Swarm</strong> 模式下利用 <strong>compose-file</strong> 管理服务</td>
</tr>
</tbody>
</table>
<h4>说明</h4>
<p>其中 <strong>container</strong> 、<strong>image</strong> 、<strong>system</strong> 一般用前面的简化指令即可。<strong>Swarm</strong> 模式用来管理 <strong>Docker</strong> 集群, 它将一群 <strong>Docker</strong> 宿主机变成一个单一的虚拟的主机, 实现对多台物理机的集群管理。</p>
<ul>
<li><a href="https://www.jianshu.com/p/47fa426ff767" rel="nofollow">使用 Docker Swarm 管理 Docker 集群</a></li>
<li><a href="https://my.oschina.net/tantexian/blog/785740" rel="nofollow">初试Docker swarm命令</a></li>
<li><a href="https://yq.aliyun.com/articles/91396" rel="nofollow">优雅地实现安全的容器编排 - Docker Secrets</a></li>
<li><a href="https://segmentfault.com/a/1190000008469023" rel="nofollow">解读1.13.1 | 探究Docker Stack和可对接网络</a></li>
</ul>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/74f29cf5a999" rel="nofollow">Docker 学习总结</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/7c9e2247cfbd">http://www.jianshu.com/p/7c9e2247cfbd</a></h4>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Docker 学习总结]]></title>
            <link>https://anyesu.github.io/blog/articles/9</link>
            <guid>9</guid>
            <pubDate>Fri, 26 Apr 2019 13:55:34 GMT</pubDate>
            <description><![CDATA[前言 Docker 火了很长时间了，有幸体验了一段时间，平常主要用于测试环境的项目一键部署，体验不错，值得推荐。本来想着就写一篇文章总结下 Docker 的一些使用场景和踩过的坑，最后写完发现篇幅过长不方便阅读，就拆分成几篇作为一个系列，在本文最后给出传送门，有兴趣的同学可以了解下。 简介 ( 官方网站 ) 什么是 Docker ？ Docker 是一种容器技术，它可以将应用和环境等进行打包，形成]]></description>
            <content:encoded><![CDATA[<h3>前言</h3>
<hr>
<p><strong>Docker</strong> 火了很长时间了，有幸体验了一段时间，平常主要用于测试环境的项目一键部署，体验不错，值得推荐。本来想着就写一篇文章总结下 <strong>Docker</strong> 的一些使用场景和踩过的坑，最后写完发现篇幅过长不方便阅读，就拆分成几篇作为一个系列，在本文最后给出传送门，有兴趣的同学可以了解下。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/99e3a015ca9bec47f1fed4e9b071afa087715fed/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653064393739633831383535616265312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/99e3a015ca9bec47f1fed4e9b071afa087715fed/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653064393739633831383535616265312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="图片来自Docker官网" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-e0d979c81855abe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>简介 ( <a href="https://www.docker.com" rel="nofollow">官方网站</a> )</h3>
<hr>
<p><a href="https://www.qcloud.com/community/article/597293" rel="nofollow">什么是 Docker ？</a></p>
<blockquote>
<p>Docker 是一种容器技术，它可以将应用和环境等进行打包，形成一个独立的，类似于手机APP形式的「应用」，这个应用可以直接被分发到任意一个支持 Docker 的环境中，通过简单的命令即可启动运行。Docker 是一种最流行的容器化实现方案。和虚拟化技术类似，它极大的方便了应用服务的部署；又与虚拟化技术不同，它以一种更轻量的方式实现了应用服务的打包。使用 Docker 可以让每个应用彼此相互隔离，在同一台机器上同时运行多个应用，不过他们彼此之间共享同一个操作系统。Docker 的优势在于，它可以在更细的粒度上进行资源的管理，也比虚拟化技术更加节约资源。</p>
</blockquote>
<p>看到这个概念，立马想到了 <strong>虚拟机</strong>，两者有点像，下面给出官网的对比图，直观感受下二者的区别 ( <a href="http://blog.csdn.net/cbl709/article/details/43955687" rel="nofollow">参考</a> )</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/85cb935f02ec9b66c16cc69c2f9c95236fe071c2/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643632343538396537613234363265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/85cb935f02ec9b66c16cc69c2f9c95236fe071c2/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643632343538396537613234363265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Docker与虚拟机对比图" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-d624589e7a2462e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>简单的说，<strong>Docker</strong> 可以共享物理机的硬件和系统资源，而 <strong>虚拟机</strong> 要对硬件进行虚拟化并且需要额外的资源开销用于运行虚拟的操作系统导致资源利用率低、性能差。在一台物理机上同时启动多个 <strong>Docker</strong> 容器或多个 <strong>虚拟机</strong> 就能有鲜明的对比了。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/20d7763a90eac20e069f27aaf8a6836a5688d471/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373832616133356564303961313237642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/20d7763a90eac20e069f27aaf8a6836a5688d471/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373832616133356564303961313237642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="图片来自网络" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-782aa35ed09a127d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>目前国内有好几家提供 <strong>Docker</strong> 云服务平台：<a href="https://www.daocloud.io" rel="nofollow">道客云</a>、<a href="https://www.tenxcloud.com" rel="nofollow">时速云</a>、<a href="http://www.alauda.cn" rel="nofollow">灵雀云</a>、<a href="http://csphere.sxl.cn" rel="nofollow">希云</a> 等，本人使用过道客云和时速云，界面类似于阿里云的控制台 ( <strong>阿里云</strong> 上也有 <strong>容器服务</strong> )，功能上包含了 <strong>镜像仓库</strong>、<strong>云服务器管理</strong>，<strong>持续集成</strong> 等等。虽然这几个平台的功能都是围绕 <strong>Docker</strong> 展开的，但业务侧重点也都有所不同，大家自己把玩吧。一般 <strong>个人版</strong> 是免费的，对于个人小项目的管理绰绰有余了，至于收费的 <strong>企业版</strong> 没用过就不发表意见了。</p>
<h3>Docker 的特点和优势</h3>
<hr>
<p>结合前段时间的使用体验，主要归纳为以下几点：</p>
<h5>1. 可移植性，一次配置，随处移植</h5>
<p>开发环境搭建绝对是开发过程中最令人头痛的环节，费时费劲费脑不说，开发到一半环境突然坏了，简直是灾难啊。</p>
<ul>
<li>比如说有这样的场景，<strong>工具1</strong> 只能运行在 <strong>系统A</strong> 上，<strong>工具2</strong> 只能运行在 <strong>系统B</strong>上，然而残酷的需求是 <strong>工具1</strong> 和 <strong>工具2</strong> 都必须得用...</li>
<li>再比如说，来了一个新同事，准备大展身手帮忙配环境，结果出现各种神奇的问题，各种 <strong>运行不了</strong>，内心也是崩溃得不要不要的...</li>
</ul>
<p>使用 <strong>Docker</strong> 可以将每个工具和相关的配置打包成镜像，这样就可以方便的 <strong>共享</strong>、<strong>备份</strong>、<strong>还原</strong> 了。当然，这种方法更适合长期在 <strong>Linux</strong> 环境下开发的同学，本人作为 <strong>Windows</strong> 重度用户想想就行了。还记得以前上学那会儿，很多开发工具都是指名道姓要运行在 <strong>xxx系统</strong> 上，想到装 <strong>虚拟机</strong>，各种乱七八糟的配置，对硬件的要求也比较奇葩等等，还没开始就想放弃了，最重要的是还不一定能成功！！！现在用了 <strong>Docker</strong> 之后，这些都不是事儿！</p>
<h5>2. 标准化应用发布和使用</h5>
<p><strong>Linux</strong> 各种五花八门的发行版本还是比较多的，开发好的应用可能不能如愿的兼容各个发行版本，更何况每个发行版本基本有一套专属的指令体系和软件包管理体系，对于小白来说真是心塞。使用了 <strong>Docker</strong> 之后，容器将应用与 <strong>物理机</strong> 操作系统隔离，内部使用独立的操作系统 ( <strong>内核</strong> 还是共享的 )，所以不管移植到哪个平台上始终可以运行在内部的操作系统之上，开发过程中也就可以专门针对一个最熟悉的操作系统进行配置和性能优化，大大减小学习成本和运维成本。另外，将应用和环境作为一个整体 ( <strong>镜像</strong> )，还有一个好处就是，通过统一的 <strong>Docker</strong> 命令实现对不同应用的 <strong>标准化</strong> 管理，<strong>镜像仓库</strong> 中每一个 <strong>镜像</strong> 就是一个应用 ( 好比在 <strong>应用商店</strong> 下载手机 <strong>APP</strong> )，获取 <strong>镜像</strong> 之后你不需要特别了解环境怎么配置，通过什么脚本或指令来启动，怎么管理开机启动的等等，这些问题都交给 <strong>Docker</strong> ，你只需了解相关的 <strong>Docker</strong> 命令就可以快乐地玩耍了。</p>
<h5>3. 资源利用率高，启动迅速</h5>
<p>启动 <strong>Docker</strong> 容器运行应用相当于是运行本地进程，相比 <strong>虚拟机</strong> 既可充分利用硬件性能，又节约启动时间，操作也简便。</p>
<h5>4. 持续集成</h5>
<p>配合 <strong>持续集成</strong> 工具如 <strong>Jenkins</strong>，<strong>版本控制</strong> 工具如 <strong>Git</strong>、<strong>SVN</strong>，<strong>项目构建</strong> 工具如 <strong>Maven</strong> 可以实现 <strong>一键发布</strong> 或者 <strong>自动化构建</strong>，结束人肉运维的惨淡人生。就拿 <strong>Tomcat</strong> 来说，没有彻底重启的功能，只能靠自己写 <a href="http://blog.csdn.net/zsw12013/article/details/51835282" rel="nofollow">脚本</a> 杀进程，有时又会莫名其妙关闭 ( 大部分原因还是代码没写好 )，这又需要写脚本定时监控重启 <strong>Tomcat</strong>。针对这两个痛点，这时 <strong>Docker</strong> 就派上了用场，对于 <strong>Docker</strong> 来说，重启容器即等价于重启应用，而且 <strong>Docker</strong> 自身可以很方便地设置开机启动容器和自动重启容器保证服务不中断。</p>
<h5>5. 隔离性</h5>
<p>作为一枚小白，对于 <strong>Linux</strong> 平台上应用的安装真心看不懂，有的可以通过平台的包管理工具安装，有的只能通过源码安装，安装后目录难找就算了，有时候一些配置文件要么遍地开花要么根本找不到，而且貌似也没有纯净卸载的选项，残留各种碎片。<strong>Docker</strong> 的思想就类似于 <strong>集装箱</strong>，整合零碎的东西于一个整体之内，简化操作步骤，同时可以隔离内外环境，内部应用不入侵外部操作系统环境，外部操作系统不干扰内部应用运行，而这个隔离也可以有效解决应用之间的冲突。当然，这个隔离性还是取决于实际的使用情况, 错误地使用 <strong>数据卷</strong> 和其他 <strong>特殊配置</strong> 都会破坏 <strong>容器</strong> 和 <strong>宿主机</strong> 之间的和谐。</p>
<h5>6. 子服务器搭建</h5>
<p>可能手头有一台高性能的服务器，自己一个人使用且用途也不大的话显得太浪费，这时就可以构建几个容器限制 <strong>内存</strong>、<strong>CPU</strong>、<strong>磁盘</strong> 等配置后分享给其他人使用，这相当于多开了几台虚拟的服务器，容器内性能并没有打多少折扣而且容器与容器之间，容器与物理机之间都是相互独立不干扰的。写到这里忽然想到，我买的阿里云 <strong>ECS</strong> 会不会也只是一个 <strong>Docker</strong> 容器呢？就算不是也应该是类似的存在吧。</p>
<h3>Docker 涉及到的一些关键概念 ( <a href="http://www.cnblogs.com/wish123/p/5573098.html" rel="nofollow">参考</a> )</h3>
<hr>
<h5>1. 镜像</h5>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1647b1dbba0b5ad9ec5352376ed5281dbdaf1cd8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d396335653936323131626164653162612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/1647b1dbba0b5ad9ec5352376ed5281dbdaf1cd8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d396335653936323131626164653162612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="图片来自网络" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-9c5e96211bade1ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>有装过 <strong>操作系统</strong> 的朋友可能想到了系统镜像（ <strong>ISO文件</strong> ），个人觉得就是一回事，就是程序的安装包，是一个包含了应用程序和其运行时环境的只读文件。镜像需要以一个 <strong>Linux</strong> 发行版作为基础运行环境，在此之上构建自己的应用。镜像的结构为一层一层的文件系统，每一层包含了所做的修改内容，所有层次的修改合并就构成了最终的镜像内容，因此，镜像是可以继承的，子镜像是在父镜像的基础上做一定的修改得到的。有一点要注意的是，即使在后面的层次中删除了某些文件，但它们仍然存在于之前的层次之中而并不会减小镜像大小，理论上层次增加就会导致镜像占用大小增加。因此，自己构建的镜像应尽可能减少层次，每一层的修改只保留必要的文件，删除临时文件。另外，由于这种层次结构，镜像文件的拉取是一个增量的过程，每次只下载不存在的层级数据，而不必每次下载完整的镜像文件，大大减少了迁移过程中网络传输的数据量。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/7ae50d883cf8ae3f24097e60f6ca0ce09d85532f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d363036623062636362323132653465302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/7ae50d883cf8ae3f24097e60f6ca0ce09d85532f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d363036623062636362323132653465302e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="图片来自网络" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-606b0bccb212e4e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h5>2. 容器</h5>
<p>既然说 <strong>镜像</strong> 是安装包，那么 <strong>容器</strong> 就是运行中的程序，这才是等价于 <strong>虚拟机</strong> 的存在。之前说 <strong>镜像</strong> 是由一层层文件系统构成的，不过它们都是只读的，启动 <strong>容器</strong> 之后会在它们之上构建一层 <strong>读写层</strong>，<strong>容器</strong> 运行过程中的一切修改都会保存在当中，将 <strong>读写层</strong> 保存起来就构建出了新的 <strong>镜像</strong> ( <code>docker commit</code> )。</p>
<h5>3. 镜像仓库</h5>
<p>相当于就是手机 <strong>APP</strong> 的应用商店，在这里我们可以下载前人构建的 <strong>镜像</strong>，即可直接使用应用，也可以基于这些镜像构建针对自有业务的个性化镜像。<strong>镜像仓库</strong> 的作用体现在 <strong>版本控制</strong>、<strong>资源共享</strong>、<strong>权限管理</strong>。</p>
<h3>Docker 的安装</h3>
<hr>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/4610d1627364cde75d344682a0a8748bd58a7f78/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d356462663737623066363864616165652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/4610d1627364cde75d344682a0a8748bd58a7f78/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d356462663737623066363864616165652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="截图来自Docker官网" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-5dbf77b0f68daaee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>通过上面官网的截图可以看出 <strong>Docker</strong> 基本支持各个平台了，这里就推荐下 <strong>daocloud</strong> 上关于 <strong>Docker</strong> 在 <strong>Linux</strong> 系统上的 <a href="http://get.daocloud.io/#install-docker" rel="nofollow">安装方式</a></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 安装</span>
sudo curl -sSL https://get.daocloud.io/docker <span class="pl-k">|</span> sh

<span class="pl-c"><span class="pl-c">#</span> 非root帐号下安装完启动可能会报错，需要执行下面的步骤</span>
<span class="pl-c"><span class="pl-c">#</span> 新建docker用户组</span>
sudo groupadd docker
<span class="pl-c"><span class="pl-c">#</span> 将当前账户加入docker用户组</span>
sudo gpasswd -a <span class="pl-smi">${USER}</span> docker
重启docker
sudo service docker restart
<span class="pl-c"><span class="pl-c">#</span> 刷新docker组成员</span>
newgrp - docker

<span class="pl-c"><span class="pl-c">#</span> 查看版本</span>
ubuntu@VM-84-201-ubuntu:<span class="pl-k">~</span>$ docker version
Client:
 Version:      17.05.0-ce
 API version:  1.29
 Go version:   go1.7.5
 Git commit:   89658be
 Built:        Thu May  4 22:10:54 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.05.0-ce
 API version:  1.29 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   89658be
 Built:        Thu May  4 22:10:54 2017
 OS/Arch:      linux/amd64
 Experimental: <span class="pl-c1">false</span></pre></div>
<p><a href="http://blog.csdn.net/styshoo/article/details/65423647" rel="nofollow">关于Docker版本</a></p>
<p>针对不同发行版，卸载方式也有所不同</p>
<h5>1. Ubuntu|Debian</h5>
<div class="highlight highlight-source-shell"><pre>sudo apt-get -y remove docker docker-engine</pre></div>
<h5>2. RHEL|CentOS</h5>
<div class="highlight highlight-source-shell"><pre>sudo yum remove docker \
docker-ce \
docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-selinux \
docker-engine-selinux \
docker-engine</pre></div>
<h5>3. Fedora</h5>
<div class="highlight highlight-source-shell"><pre>sudo dnf remove docker \
docker-common \
container-selinux \
docker-selinux \
docker-engine</pre></div>
<p>卸载 <strong>Docker</strong> 后, <strong>/var/lib/docker/</strong> 目录下会保留原 <strong>Docker</strong> 的镜像,网络,存储卷等文件. 如果需要全新安装 <strong>Docker</strong>, 需要删除 <strong>/var/lib/docker/</strong> 目录。</p>
<div class="highlight highlight-source-shell"><pre>sudo rm -rf /var/lib/docker/</pre></div>
<p>由于经常需要从官方镜像仓库获取镜像，为了解决网络问题，可以使用 <strong>daoCloud</strong> 提供的 <a href="https://www.daocloud.io/mirror#accelerator-doc" rel="nofollow">Docker 加速器</a></p>
<div class="highlight highlight-source-shell"><pre>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh <span class="pl-k">|</span> sh -s http://024e63b8.m.daocloud.io</pre></div>
<h3>关于 Docker 改名</h3>
<hr>
<p>关于改名，指的是原先的 <strong>Docker</strong> 开源项目改名成了 <strong>Moby</strong> 项目, 而 <strong>Docker</strong> 成了注册商标, 只用于 <strong>Docker</strong> 公司的商业产品 <strong>Docker EE</strong> 和 <strong>Docker CE</strong> 等。</p>
<h5>相关链接:</h5>
<p><a href="https://www.zhihu.com/question/58805021" rel="nofollow">对于 Docker 改名 Moby ，大家怎么看？</a><br>
<a href="https://yq.aliyun.com/articles/74437" rel="nofollow">Docker 改名啦？什么是 Moby Project</a></p>
<h3><a href="http://www.jianshu.com/nb/13876015" rel="nofollow">系列文章</a></h3>
<hr>
<h4><a href="http://www.jianshu.com/p/7c9e2247cfbd" rel="nofollow">Docker 常用指令详解</a></h4>
<h4><a href="http://www.jianshu.com/p/a0892512f86c" rel="nofollow">使用 Dockerfile 构建镜像</a></h4>
<h4><a href="http://www.jianshu.com/p/ee8e7d2eb645" rel="nofollow">使用 Docker Compose 构建容器</a></h4>
<h4><a href="http://www.jianshu.com/p/7ba1a93e6de4" rel="nofollow">Docker Daemon 连接方式详解</a></h4>
<h4><a href="http://www.jianshu.com/p/f510aaa470cc" rel="nofollow">Docker 下的网络模式</a></h4>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/74f29cf5a999">http://www.jianshu.com/p/74f29cf5a999</a></h4>]]></content:encoded>
            <enclosure url="http://upload-images.jianshu.io/upload_images/1836534-e0d979c81855abe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Windows10内置Linux子系统初体验]]></title>
            <link>https://anyesu.github.io/blog/articles/8</link>
            <guid>8</guid>
            <pubDate>Fri, 08 Mar 2019 08:35:25 GMT</pubDate>
            <description><![CDATA[前言 前段时间，机子上的 win10 又偷偷摸摸升级到了一周年正式版，比较无奈。不过之前听闻这个版本已经支持内置的 Linux 子系统，于是就怀着好奇心试玩了一把。虽然期间遇到了很多问题，但总体来说这个子系统体验还不错，在这里就分享一些关键步骤和遇到的问题，剩下的大家自己折腾吧。。 启用 Linux 子系统 系统升级到一周年正式版及以上(1607) 依次在 设置 - 更新与安全 - 针对开发人员 ]]></description>
            <content:encoded><![CDATA[<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/b70d666072b9486bdde908844f640aec7386da05/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d336465313131323839346131366464612e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/b70d666072b9486bdde908844f640aec7386da05/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d336465313131323839346131366464612e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="WSL" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-3de1112894a16dda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>前言</h3>
<hr>
<p>前段时间，机子上的 <strong>win10</strong> 又偷偷摸摸升级到了一周年正式版，比较无奈。不过之前听闻这个版本已经支持内置的 <strong>Linux 子系统</strong>，于是就怀着好奇心试玩了一把。虽然期间遇到了很多问题，但总体来说这个子系统体验还不错，在这里就分享一些关键步骤和遇到的问题，剩下的大家自己折腾吧。。</p>
<h3>启用 Linux 子系统</h3>
<hr>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/7be7042efdcbc00777abd08a0e054663c1ae93bb/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303564386538356333626135346136302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/7be7042efdcbc00777abd08a0e054663c1ae93bb/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303564386538356333626135346136302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="设置(16215版之后不再需要开发人员模式)" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-05d8e85c3ba54a60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/02c0ae821f1392fa10fabf9d16470307b3718634/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373830663634323362643531363066322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/02c0ae821f1392fa10fabf9d16470307b3718634/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d373830663634323362643531363066322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Windows功能" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-780f6423bd5160f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/70c7c12d453980f9ae1352b6fea01232fc816045/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303562626665636139633266376161652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/70c7c12d453980f9ae1352b6fea01232fc816045/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303562626665636139633266376161652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="安装ing..." data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-05bbfeca9c2f7aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<blockquote>
<ol>
<li>
<p>系统升级到一周年正式版及以上(1607)</p>
</li>
<li>
<p>依次在 <code>设置</code> - <code>更新与安全</code> - <code>针对开发人员</code> 选项中，启用"<strong>开发人员模式</strong>"</p>
</li>
<li>
<p>在资源管理器中打开 <code>控制面板\所有控制面板项\程序和功能</code> , 打开 <code>启用或关闭 Windows功能</code> , 勾选 <code>适用于Linux的Windows子系统(Beta)</code></p>
</li>
<li>
<p>重启电脑</p>
</li>
<li>
<p>命令行运行 <code>lxrun /install /y</code> 开始安装<br>
安装速度取决于网络情况，下载的文件在 <code>%localappdata%\lxss</code> 目录下 <code>lxss.tar.gz</code> (181M)，解压后大概500M, <code>rootfs</code> 目录即为子系统根目录。</p>
</li>
<li>
<p>命令行运行 <code>bash</code> 进入<strong>Ubuntu</strong><br>
默认使用的 <code>root</code> 帐号登录，通过指令 <code>passwd</code> 设置密码。</p>
</li>
</ol>
<ul>
<li><strong>注：本文脚本均在root帐号下操作，因此建议使用root帐号</strong></li>
</ul>
<ol start="7">
<li>毕竟爱折腾，难免会把子系统环境(lxss目录)玩坏掉，因此干正事前最好先备份下以便快速还原。注意，不要直接右键复制或者打包，可能会导致文件权限丢失的。<br>
<code>xcopy %localappdata%\lxss %localappdata%\lxss.bak /E</code></li>
<li>当然，如果你比较任性也可以不执行上一步的备份操作，通过命令行运行 <code>lxrun /uninstall /full</code> 轻松卸载子系统，重复上面的步骤即可重装，不过要注意下载速度时好时坏哦。</li>
</ol>
</blockquote>
<p>通过上面的步骤，已经启用了 <strong>win10</strong> 自带的 <strong>Linux 子系统</strong> ( <strong>WSL</strong> )，感觉逼格提升了不少。当然，怎么能满足于此呢，接下来就要做一些环境的配置和进一步的挖掘。</p>
<h3>更换数据源 ( <a href="http://blog.csdn.net/sunnyliqian/article/details/50179915" rel="nofollow">参考</a> )</h3>
<hr>
<p>在 <strong>Ubuntu</strong> 下我们可以通过 <a href="http://www.cnblogs.com/xiangzi888/archive/2012/03/18/2405075.html" rel="nofollow">apt-get 命令</a> 很方便的安装/卸载软件，由于默认的软件包仓库是位于国外的，安装软件的时候就可能遇到各种网络问题或者下载到的一些资源不完整，因此就需要切换数据源为国内的镜像站点来改善。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1.备份原来的数据源配置文件</span>
cp /etc/apt/sources.list /etc/apt/sources.list_backup
<span class="pl-c"><span class="pl-c">#</span> 2.编辑数据源配置文件</span>
vi /etc/apt/sources.list</pre></div>
<p>在这里我使用的是阿里云的数据源：</p>
<pre><code>deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse
</code></pre>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 3.更新配置</span>
apt-get update</pre></div>
<p>注：14986版之后更新了内核，第三方的镜像站可能找不到软件包资源，需要切换回官方的源。经测试 <a href="http://mirrors.ustc.edu.cn/help/ubuntu.html" rel="nofollow">中科大的源</a> 可用</p>
<div class="highlight highlight-source-shell"><pre>dist=<span class="pl-s"><span class="pl-pds">`</span>lsb_release -cs<span class="pl-pds">`</span></span>
cat <span class="pl-k">&gt;</span> /etc/apt/sources.list <span class="pl-s"><span class="pl-k">&lt;&lt;</span><span class="pl-k">EOF</span></span>
<span class="pl-s">deb https://mirrors.ustc.edu.cn/ubuntu/ ${dist} main restricted universe multiverse</span>
<span class="pl-s">deb https://mirrors.ustc.edu.cn/ubuntu/ ${dist}-updates main restricted universe multiverse</span>
<span class="pl-s">deb https://mirrors.ustc.edu.cn/ubuntu/ ${dist}-backports main restricted universe multiverse</span>
<span class="pl-s">deb https://mirrors.ustc.edu.cn/ubuntu/ ${dist}-security main restricted universe multiverse</span>
<span class="pl-s"><span class="pl-k">EOF</span></span></pre></div>
<h3>与 Windows 通讯</h3>
<hr>
<p>目前 <strong>子系统</strong> 与 <strong>Windows</strong> 之间通过以下两种方式进行通讯</p>
<blockquote>
<ol>
<li>通过 <code>tcp</code> 协议进行通讯（简单点说就是用网络，端口都是通的）</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>通过 <code>/mnt/【盘符】/目录</code> 的方式访问Windows目录<br>
试过在Windows的资源管理器中直接对子系统环境目录下的文件所做的修改不能被子系统所识别，因此需要在bash下进行操作。</li>
</ol>
</blockquote>
<p><a href="https://blogs.msdn.microsoft.com/commandline/2016/11/17/do-not-change-linux-files-using-windows-apps-and-tools/" rel="nofollow">在任何情况下，请勿使用Windows应用程序，工具，脚本，控制台等创建或修改Linux文件</a></p>
<h3>安装 zsh</h3>
<hr>
<blockquote>
<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href="https://github.com/robbyrussell/oh-my-zsh%E3%80%82%E8%BF%99%E7%8E%A9%E6%84%8F%E5%B0%B1%E5%83%8F%E3%80%8CX%E5%A4%A9%E5%8F%AB%E4%BD%A0%E5%AD%A6%E4%BC%9A">https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会</a> C++」系列，可以让你神功速成，而且是真的。</p>
</blockquote>
<p><strong>zsh</strong> 就是一款强大的虚拟终端，网上也都推荐使用 <a href="https://github.com/robbyrussell/oh-my-zsh">oh my zsh</a> 来管理配置 , 不过对我来说还是不够傻瓜。于是，参考一篇 <a href="https://www.zhihu.com/question/21418449/answer/300879747" rel="nofollow">文章</a> 使用 <strong>zsh</strong> 的 <a href="https://github.com/zsh-users/antigen">包管理器 antigen</a> 来管理所有功能，文章中还给了现成的配置。</p>
<ul>
<li>安装 <strong>zsh</strong></li>
</ul>
<div class="highlight highlight-source-shell"><pre>sudo apt-get -y install zsh</pre></div>
<ul>
<li>设置终端的 <strong>shell</strong> 环境默认为 <strong>zsh</strong>，输入以下命令（ 需要 <strong>重启</strong> ）</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 加 sudo 是修改 root 帐号的默认 shell</span>
chsh -s <span class="pl-s"><span class="pl-pds">`</span>which zsh<span class="pl-pds">`</span></span></pre></div>
<ul>
<li>如果上面命令无效，修改 <strong>~/.bashrc</strong> 文件, 在开头添加：</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-k">if</span> [ <span class="pl-k">-t</span> 1 ]<span class="pl-k">;</span> <span class="pl-k">then</span>
    <span class="pl-c1">exec</span> zsh
<span class="pl-k">fi</span></pre></div>
<ul>
<li>安装 <strong>antigen</strong></li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 修改配置 ~/.zshrc（如果切换帐号后无法使用 zsh 则把该用户的配置文件再配一遍）</span>
curl -L https://raw.githubusercontent.com/skywind3000/vim/30b702725847bac4708de34664bb68454b54e0c0/etc/zshrc.zsh <span class="pl-k">&gt;</span> <span class="pl-k">~</span>/.zshrc

<span class="pl-c"><span class="pl-c">#</span> 修改主题, 参考：https://github.com/robbyrussell/oh-my-zsh/wiki/themes</span>
<span class="pl-c"><span class="pl-c">#</span> 如果需要主题一直生效需要添加到 ~/.zshrc 中</span>
antigen theme ys

<span class="pl-c"><span class="pl-c">#</span> 配置修改完重新执行 zsh</span></pre></div>
<ul>
<li>如果出现警告：<strong>zsh compinit: insecure directories, run compaudit for list.</strong></li>
</ul>
<div class="highlight highlight-source-shell"><pre>chmod -R 755 <span class="pl-k">~</span>/.antigen</pre></div>
<ul>
<li>
<p><a href="https://www.jianshu.com/p/f867f786b584" rel="nofollow">按键补齐</a> ( <a href="https://blog.csdn.net/Piasy/article/details/37347521" rel="nofollow">解决zsh中无法正常使用home和end等键的问题</a> )</p>
<p>在 <strong>~/.zshrc</strong> 文件末尾添加下面的内容</p>
</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> key bindings</span>
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[1~<span class="pl-pds">"</span></span> beginning-of-line
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[4~<span class="pl-pds">"</span></span> end-of-line
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[5~<span class="pl-pds">"</span></span> beginning-of-history
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[6~<span class="pl-pds">"</span></span> end-of-history

<span class="pl-c"><span class="pl-c">#</span> for rxvt</span>
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[8~<span class="pl-pds">"</span></span> end-of-line
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[7~<span class="pl-pds">"</span></span> beginning-of-line
<span class="pl-c"><span class="pl-c">#</span> for non RH/Debian xterm, can't hurt for RH/DEbian xterm</span>
bindkey <span class="pl-s"><span class="pl-pds">"</span>\eOH<span class="pl-pds">"</span></span> beginning-of-line
bindkey <span class="pl-s"><span class="pl-pds">"</span>\eOF<span class="pl-pds">"</span></span> end-of-line
<span class="pl-c"><span class="pl-c">#</span> for freebsd console</span>
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[H<span class="pl-pds">"</span></span> beginning-of-line
bindkey <span class="pl-s"><span class="pl-pds">"</span>\e[F<span class="pl-pds">"</span></span> end-of-line
<span class="pl-c"><span class="pl-c">#</span> completion in the middle of a line</span>
bindkey <span class="pl-s"><span class="pl-pds">'</span>^i<span class="pl-pds">'</span></span> expand-or-complete-prefix

<span class="pl-c"><span class="pl-c">#</span> Fix numeric keypad  </span>
<span class="pl-c"><span class="pl-c">#</span> 0 . Enter  </span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Op<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[On<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[OM<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>^M<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> 1 2 3  </span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Oq<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Or<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Os<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> 4 5 6  </span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ot<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ou<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ov<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>6<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> 7 8 9  </span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ow<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>7<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ox<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>8<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Oy<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>9<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">#</span> + - * /  </span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Ol<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Om<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Oj<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>
bindkey -s <span class="pl-s"><span class="pl-pds">"</span>^[Oo<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span></pre></div>
<h3>安装 autojump ( <a href="https://linux.cn/article-3401-1.html" rel="nofollow">用法参考</a> )</h3>
<hr>
<blockquote>
<p>autojump 是一个命令行工具，它允许你可以直接跳转到你喜爱的目录，而不受当前所在目录的限制。意思就是可以让你更快地切换目录，而不用频繁地使用 cd/tab 等命令。</p>
</blockquote>
<ul>
<li>安装</li>
</ul>
<div class="highlight highlight-source-shell"><pre>sudo apt-get install autojump</pre></div>
<ul>
<li><strong>zsh</strong> 下运行报错:</li>
</ul>
<div class="highlight highlight-source-shell"><pre>$ autojump
Please <span class="pl-c1">source</span> the correct autojump file <span class="pl-k">in</span> your shell<span class="pl-s"><span class="pl-pds">'</span>s</span>
<span class="pl-s">startup file. For more information, please reinstall autojump</span>
<span class="pl-s">and read the post installation instructions.</span></pre></div>
<p>参照文章 <a href="https://www.jianshu.com/p/0d4d5c0c31a1" rel="nofollow">Mac终端增强技能</a> 和 <a href="http://macshuo.com/?p=676" rel="nofollow">终极 Shell</a> 找到解决办法：</p>
<blockquote>
<p>在 <code>~/.zshrc</code> 中安装插件 <code>brew install autojump</code> 再重新进入 zsh</p>
</blockquote>
<p>由于本文使用 <strong>antigen</strong> 作为 <strong>zsh</strong> 的包管理器，所以实际操作是在 <code>~/.zshrc</code> 中添加 <code>antigen bundle autojump</code></p>
<h3>使用 bash 客户端软件 cmder ( <a href="http://blog.csdn.net/u010053050/article/details/52388663" rel="nofollow">参考</a> )</h3>
<hr>
<p><strong>Windows</strong> 自带的 <strong>命令提示符 cmd</strong> 并不是很好用（ 文本选中、复制粘贴等等操作 ），在这里使用 <strong>cmder</strong> 作为替代品，体验效果很好。去 <a href="http://cmder.net/" rel="nofollow">cmder 官网</a> 下载 <a href="https://github.com/cmderdev/cmder/releases/download/v1.3.2/cmder_mini.zip">mini版</a>（ 完整版附带了模拟的 <strong>bash</strong> 环境，由于已经安装 <strong>Linux 子系统</strong>，就不再需要了）解压即可使用。</p>
<ul>
<li>
<h5>设置启动 <strong>cmder</strong> 时直接运行 bash:</h5>
</li>
</ul>
<pre><code>1. 进入 "Settings &gt; Startup",
2. 选择 "Startup options &gt; Command line"，输入 "bash -cur_console:p"
</code></pre>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/38f36c493894d19d025b52bc3910a1e379866262/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303761656537356461646632313131362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/38f36c493894d19d025b52bc3910a1e379866262/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303761656537356461646632313131362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="启动直接运行bash" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-07aee75dadf21116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<ul>
<li>
<h5>通过软件底部的加号按钮新开标签页并进入 bash</h5>
</li>
</ul>
<pre><code>1. 进入 "Settings &gt; Startup &gt; Tasks",
2. 选择 "bash::bash"，将指令修改为 'cmd /c "bash" -cur_console:p -new_console:d:%USERPROFILE%'
</code></pre>
<p><strong>文中给的 cmder 是 1.3.2 版本的，最新的 1.3.6 版本已经默认集成了 WSL 的 Task，就不用这一步的配置了</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/885182e5b0a0fc8e43f89aaad82e9929be0170ef/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393730346136366436346637616331302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/885182e5b0a0fc8e43f89aaad82e9929be0170ef/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d393730346136366436346637616331302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="新标签页" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-9704a66d64f7ac10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<ul>
<li>
<h5>设置配色主题</h5>
</li>
</ul>
<pre><code>1. 进入 "Settings &gt; Features &gt; Colors",
2. "Schemes" 项下拉选择 "&lt;ubuntu&gt;"
</code></pre>
<p><code>小贴士：将 cmder 目录添加到环境变量 path 中或者复制快捷方式到 "C:\Windows\System32" 目录下，就可通过 win + R 快捷键快速打开了</code></p>
<h3>运行图形界面程序 ( <a href="http://blog.csdn.net/syrchina/article/details/52170440" rel="nofollow">参考</a> )</h3>
<hr>
<p>什么！<strong>Linux</strong> 不是就这么个黑白界面的窗口吗？是的，你没看错，就是图形界面，这里用到的是 <strong>Xserver</strong> 这个东东，至于原理什么的各位自行度娘吧。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/348f26560a5b14ff6ee858f925bac665ae09e266/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653335343665333836333531383731632e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/348f26560a5b14ff6ee858f925bac665ae09e266/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653335343665333836333531383731632e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Xming" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-e3546e386351871c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<blockquote>
<ol>
<li>
<p>安装Xming <a href="https://sourceforge.net/projects/xming/files/latest/download11" rel="nofollow">下载地址</a></p>
</li>
<li>
<p>安装完直接打开 <code>Xming</code> 即可</p>
</li>
<li>
<p>安装一个 <code>firefox</code> 测试<br>
<code>apt-get install firefox</code></p>
</li>
<li>
<p>运行(在程序指令前加上"DISPLAY=:0 ")<br>
<code>DISPLAY=:0 firefox</code></p>
</li>
<li>
<p><a href="http://www.cnblogs.com/carlsplace/p/5990568.html" rel="nofollow">简化配置</a><br>
每次运行程序都要输入 <code>DISPLAY=:0</code> 挺累的，执行下列指令后重启bash即可省去这个步骤<br>
<code>echo "export DISPLAY=:0.0" &gt;&gt; ~/.bashrc</code></p>
</li>
</ol>
<p>PS：很多小伙伴反映说打开Xming没反应，这是正常现象 ( 详见<a href="https://www.jianshu.com/p/bc38ed12da1d#comment-20826096" rel="nofollow">评论区33楼</a> )。Xming是一个在后台运行的服务，在任务栏显示一个 <code>X</code> 的小图标即表示启动成功，无需其他操作了。要想看到画面，需要在wsl或其他远程Linux机器上使用 <code>DISPLAY=:0 </code> 命令启动带图形界面的程序。在这里简单分析下我理解的原理：1. Xming 启动 Xserver服务用于监听；2. wsl启动程序后把界面数据发送给 Xserver；3. Xserver 接收到数据进行绘制，于是在win下就看到了图形界面。还有困惑的话请移步至下方的 vnc 版块，比Xming效果要好，类似与 win 下 <code>远程桌面连接</code> 的效果。</p>
</blockquote>
<h3>Sublime Text 3 安装</h3>
<hr>
<p>既然都可以运行图形界面了，编辑器也要换成可视化的，毕竟 <strong>vim</strong> 还是不太适合我。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">cd</span> /
<span class="pl-c"><span class="pl-c">#</span> 下载</span>
wget https://download.sublimetext.com/sublime-text_build-3126_amd64.deb
<span class="pl-c"><span class="pl-c">#</span> 安装</span>
dpkg -i sublime-text_build-3126_amd64.deb
<span class="pl-c"><span class="pl-c">#</span> 运行</span>
subl</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/15acbc1d0c2d2463e520e2df41a9b8cab42d022f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333866363161643730613566333533392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/15acbc1d0c2d2463e520e2df41a9b8cab42d022f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333866363161643730613566333533392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="什么鬼，报错了！" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-38f61ad70a5f3539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>应该是少了什么依赖包，嗯，安装下搞定。</p>
<div class="highlight highlight-source-shell"><pre>apt-get -y install libgtk2.0-0</pre></div>
<h3>启动 xfce 桌面环境 ( <a href="http://jingyan.baidu.com/article/546ae1851c6ac81149f28c9a.html" rel="nofollow">参考</a> )</h3>
<hr>
<p>图形界面程序都能运行了，不试试 <strong>ubuntu</strong> 的桌面环境怎么能甘心，于是又是噼里啪啦一顿搜索。一开始参照这篇 <a href="http://winaero.com/blog/run-ubuntu-unity-on-windows-10/" rel="nofollow">国外的教程</a> 折腾了许久，每次运行总是报一个 <strong>composite</strong> 的插件没加载进来，各种软件包安装一通还是不行，后来实在失去耐心就放弃了这条路。后来看到好像有人成功运行了 <strong>xfce</strong> , 但没有具体步骤，只能自己一顿摸索，结果还真误打误撞成功了。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1.安装xfce4</span>
apt-get install -y xfce4
<span class="pl-c"><span class="pl-c">#</span> 2.安装xubuntu桌面及附带应用</span>
apt-get install -y xubuntu-desktop
<span class="pl-c"><span class="pl-c">#</span> 3.启动</span>
xfce4-session</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c5f230cc3bcf2ec01d70bd94fefa99a42dff0299/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353463663939323834346664323438362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/c5f230cc3bcf2ec01d70bd94fefa99a42dff0299/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353463663939323834346664323438362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="启动报错了" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-54cf992844fd2486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>解决办法: ( <a href="https://zhuanlan.zhihu.com/p/21577512?refer=MSFaith" rel="nofollow">参考</a> )</p>
<div class="highlight highlight-source-shell"><pre>sed -i <span class="pl-s"><span class="pl-pds">'</span>s$&lt;listen&gt;.*&lt;/listen&gt;$&lt;listen&gt;tcp:host=localhost,port=0&lt;/listen&gt;$<span class="pl-pds">'</span></span> /etc/dbus-1/session.conf</pre></div>
<p>再次尝试打开，现在可以看到 <strong>Xming</strong> 打开了三个窗口，分别是桌面、任务栏、菜单栏。逼格是提升了不少，不过确实很卡。</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1fb7893358ff40e8fe5e7a84a41b08681998f935/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d356663396437616433663837646166352e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/1fb7893358ff40e8fe5e7a84a41b08681998f935/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d356663396437616433663837646166352e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="xfce4" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-5fc9d7ad3f87daf5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>使用 <a href="https://www.realvnc.com/en/connect/download/vnc/linux/" rel="nofollow">VNC</a> 进行远程桌面控制 ( <a href="https://jingyan.baidu.com/article/d2b1d102b85a825c7e37d405.html" rel="nofollow">安装方法</a> )</h3>
<hr>
<blockquote>
<p>感谢 <a href="https://www.jianshu.com/p/bc38ed12da1d#comment-20600481" rel="nofollow">@lizr_4bf0</a> 的提示，使用 <code>VNC</code> 来代替 <code>Xming</code> 以解决 <code>Xming</code> 下很卡的问题。</p>
</blockquote>
<ul>
<li><strong>wsl</strong> 下安装 <a href="https://www.linuxidc.com/Linux/2017-03/141936.htm" rel="nofollow">vnc4server</a></li>
</ul>
<div class="highlight highlight-source-shell"><pre>apt-get install -y vnc4server</pre></div>
<ul>
<li><strong>wsl</strong> 下启动 <strong>vncserver</strong> ( 安装后首次启动需要设置访问密码 )</li>
</ul>
<div class="highlight highlight-source-shell"><pre>vncserver</pre></div>
<ul>
<li>
<p>在 <strong>win10</strong> 的 <strong>VNC Viewer</strong> 中访问 <strong>127.0.0.1:1</strong><br>
注意：如果连接 <strong>VNC Viewer</strong> 时报错请 <a href="http://www.cnblogs.com/kerrycode/p/6055126.html" rel="nofollow">参考</a></p>
</li>
<li>
<p><strong>VNC Viewer</strong> 中只显示一个终端窗口的问题</p>
</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 修改xstartup, 将 x-window-manager 替换为刚才安装的 xfce4-session</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>s$x-window-manager$xfce4-session$<span class="pl-pds">'</span></span> <span class="pl-k">~</span>/.vnc/xstartup
<span class="pl-c"><span class="pl-c">#</span> 重启 vncserver</span>
vncserver -kill :1
vncserver :1</pre></div>
<p><strong>注意: 如果没安装 xfce4，那么至少安装一个终端 ( 比如: apt install -y gnome-terminal ) 用于启动, 不然 vnc 就是空白的, 什么都干不了</strong></p>
<ul>
<li><a href="http://blog.csdn.net/yingyujianmo/article/details/45201097" rel="nofollow">分辨率设置</a></li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 先关闭</span>
vncserver -kill :1
<span class="pl-c"><span class="pl-c">#</span> 再启动并设置分辨率(注意是小写的x)</span>
vncserver -geometry 1366x768 :1</pre></div>
<h3>在子系统上运行nginx</h3>
<hr>
<p>因工作项目中用到了 <strong>ssi</strong> 技术，而已经 <strong>Windows</strong> 上已经编译好的 <strong>nginx</strong> 是不支持相对路径引用的（ <a href="http://www.cnblogs.com/jyb2014/p/4026654.html" rel="nofollow">需要修改源码重新编译</a> ），只能委屈求全用着 <strong>Apache</strong> 。不过既然现在都能跑 <strong>Linux</strong> 了，那就试试在 <strong>Linux</strong> 上运行 <strong>nginx</strong>，然后在 <strong>Windows</strong> 上进行调用。</p>
<h5>1. 通过 apt-get 方式安装</h5>
<div class="highlight highlight-source-shell"><pre>sudo apt-get install nginx
<span class="pl-c"><span class="pl-c">#</span> 启动报错了:</span>
nginx: [emerg] <span class="pl-en">bind</span>() to [::]:80 failed (98: Address already <span class="pl-k">in</span> use)
<span class="pl-c"><span class="pl-c">#</span> 80端口实际没被占用，那应该就是ipv6的问题，将其禁用: </span>
vim /etc/nginx/sites-available/default
<span class="pl-c"><span class="pl-c">#</span> 找到default_server ipv6only=on;注释掉</span>
<span class="pl-c"><span class="pl-c">#</span> 再次启动没报错，不过浏览器无法访问，80端口也没被使用，查看error.log</span>
cat /var/log/nginx/error.log
<span class="pl-c"><span class="pl-c">#</span> 看到错误信息：</span>
ioctl(FIOASYNC) failed <span class="pl-k">while</span> spawning <span class="pl-s"><span class="pl-pds">"</span>worker process<span class="pl-pds">"</span></span> (22: Invalid argument)</pre></div>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 解决方法：禁用master进程模式</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>1 a\master_process off;<span class="pl-pds">'</span></span> /etc/nginx/nginx.conf</pre></div>
<p>再次启动，终于没报错了，在 <strong>Windows</strong> 中打开浏览器访问 <strong>127.0.0.1</strong>，还真的试验成功了，不过 <strong>nginx</strong> 版本 ( <code>1.4.6</code> ) 有点老。</p>
<h5>2. 通过编译源码的方式安装</h5>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1.安装依赖包</span>
apt-get -y install build-essential autoconf libtool libxml2-dev openssl libcurl4-openssl-dev libbz2-dev libjpeg-dev libpng12-dev libfreetype6-dev libldap2-dev libmcrypt-dev libmysqlclient-dev libxslt1-dev libxt-dev libpcre3-dev libreadline-dev
<span class="pl-c"><span class="pl-c">#</span> 2.下载源码</span>
wget http://tengine.taobao.org/download/tengine-2.1.1.tar.gz
<span class="pl-c"><span class="pl-c">#</span> 3.解压</span>
tar -zxvf tengine-2.1.1.tar.gz
<span class="pl-c"><span class="pl-c">#</span> 4.进入目录</span>
<span class="pl-c1">cd</span> tengine-2.1.1
<span class="pl-c"><span class="pl-c">#</span> 修改源码...</span>
<span class="pl-c"><span class="pl-c">#</span> 5.配置</span>
./configure --prefix=/usr/anyesu/nginx
<span class="pl-c"><span class="pl-c">#</span> 6.编译&amp;安装</span>
make <span class="pl-k">&amp;&amp;</span> make install
<span class="pl-c"><span class="pl-c">#</span> 7.修改配置文件</span>
sed -i <span class="pl-s"><span class="pl-pds">'</span>1 a\master_process off;<span class="pl-pds">'</span></span> /usr/anyesu/nginx/conf/nginx.conf
<span class="pl-c"><span class="pl-c">#</span> 8.启动</span>
/usr/anyesu/sbin/nginx</pre></div>
<p>上面的步骤，我试了两台电脑，其中一台报错：</p>
<blockquote>
<p><em>nginx: [emerg] invalid port in resolver "fec0:0:0:ffff::1" in /usr/anyesu/nginx/conf/nginx.conf:123</em></p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/aabe8ebbffa49f8959498ac4c6697dd28fc1b46d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656663313565653032626263386133362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/aabe8ebbffa49f8959498ac4c6697dd28fc1b46d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656663313565653032626263386133362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="/etc/resolv.conf" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-efc15ee02bbc8a36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>出现的 <code>fec0:0:0:ffff::1</code> 是个什么鬼，度娘了一番，貌似是 <strong>dns</strong>，打开 <strong>dns</strong> 配置文件 <code>/etc/resolv.conf</code> 果然发现了这东西，应该是 <strong>Windows</strong> 下只分配了 <strong>1</strong> 个 <strong>dns</strong>，所以 <strong>Linux</strong> 就给了这么两个默认值的吧。将它们注释掉，重新启动 <strong>nginx</strong>，成功运行 <a href="http://tengine.taobao.org" rel="nofollow">Tengine/2.1.1</a> 。</p>
<p><code>注意，每次重启 bash 都会重置 dns 配置的</code></p>
<h3>启用 ssh ( <a href="http://blog.csdn.net/donglynn/article/details/53505495" rel="nofollow">参考</a> )</h3>
<hr>
<p>本地可以通过命令行打开 <strong>bash</strong>，如果要远程访问（ 如同访问线上服务器一样 ），那么就需要启用 <strong>ssh</strong> 。</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1.安装ssh(一般不需要这步)</span>
apt-get install openssh-server
<span class="pl-c"><span class="pl-c">#</span> 2.修改配置文件</span>
cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
vim /etc/ssh/sshd_config
<span class="pl-c"><span class="pl-c">#</span>=======(修改以下选项内容)=========#</span>
<span class="pl-c"><span class="pl-c">#</span> Port 23（22端口已被占用）        #</span>
<span class="pl-c"><span class="pl-c">#</span> (取消注释)ListenAddress 0.0.0.0 #</span>
<span class="pl-c"><span class="pl-c">#</span> UsePrivilegeSeparation no      #</span>
<span class="pl-c"><span class="pl-c">#</span> PermitRootLogin yes            #</span>
<span class="pl-c"><span class="pl-c">#</span> （注释）StrictModes yes         #</span>
<span class="pl-c"><span class="pl-c">#</span> PasswordAuthentication yes     #</span>
<span class="pl-c"><span class="pl-c">#</span>================================#</span>
<span class="pl-c"><span class="pl-c">#</span> 3.启动ssh</span>
service ssh start
<span class="pl-c"><span class="pl-c">#</span> 4.如果提示“sshd error: could not load host key”，则用下面的命令重新生成</span>
rm /etc/ssh/ssh<span class="pl-k">*</span>key
dpkg-reconfigure openssh-server</pre></div>
<p>使用终端工具访问，这里我用的是 <strong>WinSCP + PuTTY</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d8ee207ff42e8b6fe27ff8e283a17e0d4450436c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333162363636643439666137646239642e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/d8ee207ff42e8b6fe27ff8e283a17e0d4450436c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d333162363636643439666137646239642e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="WinSCP" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-31b666d49fa7db9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1f35adf7f3cfb46f76770717fa309827a7543235/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d646637306263623434343561373737392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/1f35adf7f3cfb46f76770717fa309827a7543235/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d646637306263623434343561373737392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="PuTTY" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-df70bcb4445a7779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>WSL 开机启动</h3>
<hr>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/4f1b1adee421d49ef898a48b06c47b6ea759a9e9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653237383663346331323437343064392e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/4f1b1adee421d49ef898a48b06c47b6ea759a9e9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d653237383663346331323437343064392e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="任务管理器" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-e2786c4c124740d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>打开任务管理器我们可以发现，在运行子系统的时候，后台其实有一个名为 <strong>bash</strong> 的进程在运行，我们每开一个命令行窗口就会多一个 <strong>bash.exe</strong>，如果我们把所有的 <strong>bash.exe</strong> 都关闭, 则这个 <strong>bash</strong> 进程就跟着关闭了（相当于是子系统关机了），跟着之前在子系统中打开的程序如 <strong>nginx</strong>、<strong>sshd</strong> 等也随之关闭了。为了让 <strong>Linux</strong> 程序能够在后台继续运行，这里通过 <strong>vbs</strong> 脚本在后台打开一个 <strong>bash.exe</strong> 来保证 <strong>bash</strong> 进程一直开着。当然，还可以通过 <strong>Windows</strong> 的计划任务实现开机启动 <strong>WSL</strong> 并打开其中的程序。<br>
<code>注：目前1803版本中关闭 bash.exe 不会再关闭打开的 Linux 进程了，也就是说不需要再在后台维持一个 bash.exe</code></p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 1.新建开机启动脚本</span>
vim /usr/anyesu/boot.sh
<span class="pl-c"><span class="pl-c">#</span> 2.编辑</span>
<span class="pl-c"><span class="pl-c">#</span>================================================================</span>
<span class="pl-c"><span class="pl-c">#</span> #!/bin/sh</span>
<span class="pl-c"><span class="pl-c">#</span> /usr/anyesu/nginx/sbin/nginx</span>
<span class="pl-c"><span class="pl-c">#</span> service ssh start</span>
<span class="pl-c"><span class="pl-c">#</span> $SHELL  #这句很重要，挂起当前脚本进程,进而维持base.exe一直打开</span>
<span class="pl-c"><span class="pl-c">#</span>================================================================</span>
<span class="pl-c"><span class="pl-c">#</span> 3.设置权限</span>
chmod 777 /usr/anyesu/boot.sh
<span class="pl-c"><span class="pl-c">#</span> 4.创建vbs脚本(D:\linux\wsl.vbs)</span>
<span class="pl-c"><span class="pl-c">#</span>==========================================</span>
<span class="pl-c"><span class="pl-c">#</span> Set ws = CreateObject("Wscript.Shell") </span>
<span class="pl-c"><span class="pl-c">#</span> ws.run "bash /usr/anyesu/boot.sh",vbhide</span>
<span class="pl-c"><span class="pl-c">#</span>==========================================</span>
<span class="pl-c"><span class="pl-c">#</span> 5.创建计划任务</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/de0b424102eee49e6ce58277921bf89f40796613/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326631363735643636326436316266622e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/de0b424102eee49e6ce58277921bf89f40796613/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d326631363735643636326436316266622e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="计划任务" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-2f1675d662d61bfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/38a9c1e7d5aa3534dbaa019dca4a34ca60a5f7e4/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d376564656132343438376536373630352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/38a9c1e7d5aa3534dbaa019dca4a34ca60a5f7e4/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d376564656132343438376536373630352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="创建基本任务" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-7edea24487e67605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/9aa3234761cc2a9950b782f086908b7401ddba3d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613834386664326530393634343637612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/9aa3234761cc2a9950b782f086908b7401ddba3d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613834386664326530393634343637612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="设置任务名称" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-a848fd2e0964467a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1789a8468d156af0e171cd6a965026de5ab1b513/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643765303936663863383361626466372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/1789a8468d156af0e171cd6a965026de5ab1b513/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d643765303936663863383361626466372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="设置任务触发条件——用户登录" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-d7e096f8c83abdf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/6933f3174041cd5559bb9dabafe686a9f80f4b38/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613035633864633036333532623133622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/6933f3174041cd5559bb9dabafe686a9f80f4b38/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613035633864633036333532623133622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="设置任务操作——启动" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-a05c8dc06352b13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/dff9cfb3c93c790dd6faf0c31be9647ff1aa11dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656665386335626534303032343665392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/dff9cfb3c93c790dd6faf0c31be9647ff1aa11dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656665386335626534303032343665392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="设置任务操作——运行vbs脚本" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-efe8c5be400246e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/af356b1abedfe1a2bb23cfb3e08649d9bf27bc5a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616131633466316533336663616330332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/af356b1abedfe1a2bb23cfb3e08649d9bf27bc5a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d616131633466316533336663616330332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="运行计划任务" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-aa1c4f1e33fcac03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>使 WSL 支持 32位程序</h3>
<hr>
<ul>
<li>参考 <a href="https://github.com/Microsoft/WSL/issues/2468#issuecomment-374904520" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2468/hovercard">issue#2468</a> ( <a href="https://github.com/Microsoft/WSL/issues/2468#issuecomment-435650594" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/2468/hovercard">中文</a> )<br>
<code>注: 依赖包可能无法自动安装, 自己手动安装下</code></li>
</ul>
<h3>使用 Docker</h3>
<hr>
<p>由于篇幅较多，单独写了一篇文章 —— <a href="https://www.jianshu.com/p/20ebdbf68744" rel="nofollow">WSL 中 Docker 使用总结</a> 。</p>
<h3>关于 Linux 发行版本</h3>
<hr>
<ul>
<li>
<h4><a href="http://www.cnblogs.com/leehavin/p/5751762.html" rel="nofollow">升级Ubuntu版本至Xenial(16.04)</a></h4>
</li>
<li>
<h4><a href="http://115.com/1000079591/T998027.html" rel="nofollow">使用openSUSE替换Ubuntu</a></h4>
</li>
</ul>
<div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> 打开cmd，进入bash</span>
bash
<span class="pl-c1">cd</span> /
<span class="pl-c"><span class="pl-c">#</span> 下载openSUSE</span>
wget -O openSUSE-42.2.tar.xz https://github.com/openSUSE/docker-containers-build/blob/openSUSE-42.2/docker/openSUSE-42.2.tar.xz<span class="pl-k">?</span>raw=true
<span class="pl-c"><span class="pl-c">#</span> 解压</span>
xz -d /openSUSE-42.2.tar.xz
mkdir rootfs
tar -C rootfs -xvf openSUSE-42.2.tar
<span class="pl-c"><span class="pl-c">#</span> 退出bash,返回cmd</span>
<span class="pl-c1">exit</span>
<span class="pl-c"><span class="pl-c">#</span> 进入子系统所在路径</span>
<span class="pl-c1">cd</span> %localappdata%<span class="pl-cce">\l</span>xss
<span class="pl-c"><span class="pl-c">#</span> 备份ubuntu用户空间（看下任务管理器中bash是不是彻底关闭了）</span>
rename rootfs rootfs.ubuntu
<span class="pl-c"><span class="pl-c">#</span> 使用openSUSE用户空间替换默认用户空间</span>
move rootfs.ubuntu<span class="pl-cce">\r</span>ootfs rootfs
<span class="pl-c"><span class="pl-c">#</span> 设置默认登录用户</span>
lxrun /setdefaultuser root
<span class="pl-c"><span class="pl-c">#</span> 重新进入bash</span>
bash
<span class="pl-c"><span class="pl-c">#</span>查看发行版本</span>
cat /etc/issue</pre></div>
<h3>官方资料</h3>
<hr>
<ul>
<li>
<h4><a href="https://github.com/Microsoft/BashOnWindows">github</a></h4>
</li>
<li>
<h4><a href="https://blogs.msdn.microsoft.com/commandline/" rel="nofollow">博客</a></h4>
</li>
<li>
<h4><a href="https://msdn.microsoft.com/en-us/commandline/wsl/release_notes" rel="nofollow">insider build 的更新记录</a></h4>
</li>
<li>
<p><a href="https://github.com/MicrosoftDocs/WSL">Windows Subsystem for Linux (WSL) Documentation</a></p>
</li>
</ul>
<h3>2017-11-21追加</h3>
<hr>
<p>最近系统又被强更到了 <strong>1709 版本 ( 16299.64 )</strong>，发现几点变化做个记录:</p>
<ol>
<li>
<p><strong>ping</strong> 命令已经可以正常使用了</p>
</li>
<li>
<p><strong>nginx</strong> 的 <strong>master</strong> 模式也能正常使用不会报错了</p>
</li>
<li>
<p>发现 <strong>nginx</strong>、<strong>ssh</strong> 之类的，能正常启动不报错但怎么也无法绑定端口。后来查了 <strong>github</strong>上的 <a href="https://github.com/Microsoft/WSL/issues/1554#issuecomment-341407417" data-hovercard-type="issue" data-hovercard-url="/microsoft/WSL/issues/1554/hovercard">issues</a> 发现是<strong>wegame ( 原 tgp )</strong> 的锅，原因是使用了一个 <strong>win10</strong> 上已失效的特性，<strong>wegame</strong> 的开发表示会尽快修复。临时解决办法：<strong>删除</strong>文件 <code>%systemroot%\system32\drivers\QMTgpNetflow764.sys</code> 后重启 <strong>bash</strong>，如无法删除先关闭应用或卸载再重装 <strong>wegame</strong> ( 最好<strong>重启</strong>电脑 )，<strong>重装</strong> 后先 <strong>删除</strong> <code>QMTgpNetflow764.sys</code> 再运行 <strong>wegame</strong>。</p>
</li>
<li>
<p>内核升级为 <code>4.4.0-43-Microsoft</code> 了, 带上了微软的标记，推测是这个原因导致很多软件包无法正常安装了。后来发现应该是阿里云的数据源未同步的原因，加上 <strong>Ubuntu</strong> 自带的源 ( 即文中最初备份的内容 ) 即可解决。</p>
</li>
<li>
<p><a href="https://blogs.msdn.microsoft.com/commandline/2017/10/11/whats-new-in-wsl-in-windows-10-fall-creators-update/" rel="nofollow">Windows 10 Fall Creators Update (1709) 中 WSL 的新功能 ( 官方博客 )</a></p>
</li>
</ol>
<h3>2017-11-30追加</h3>
<hr>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/c995d05e87e863b102fa2896ada360f9dce0c7b8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d633334656562383337363832653236362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/c995d05e87e863b102fa2896ada360f9dce0c7b8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d633334656562383337363832653236362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="应用商店" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-c34eeb837682e266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>目前 <strong>1709 版本 ( 16299.64 )</strong>  已经可以在商店中搜索安装多个不同版本的子系统了，根路径为 <code>%localappdata%\Packages\【根据子系统名找到对应的应用文件夹】\LocalState\rootfs</code> 。同时还新增了两个命令行工具: <code>wsl.exe</code> 和 <code>wslconfig.exe</code> 。</p>
<p>其中 <code>wsl.exe</code> 应该等价于 <code>bash.exe</code> , 两者之间的细微差别暂时还没发现。至于 <code>wslconfig.exe</code> 的作用主要为 ( <a href="https://blogs.msdn.microsoft.com/commandline/2017/11/28/a-guide-to-invoking-wsl" rel="nofollow">参考</a> )：</p>
<blockquote>
<p><strong>1. 查看安装所有已安装的子系统: <code>wslconfig /l</code></strong></p>
<pre><code>适用于 Linux 的 Windows 子系统:
Ubuntu (默认)
Legacy
</code></pre>
<p>其中 <code>Ubuntu</code> 是商店中下载的版本，<code>Legacy</code> 是按老方法安装的默认wsl。</p>
<p><strong>2. 切换bash.exe默认使用的子系统: <code>wslconfig /s &lt;DistributionName&gt;</code></strong><br>
其中 <code>&lt;DistributionName&gt;</code> 替换为 <code>Ubuntu</code> 或 <code>Legacy</code> , 或者其他已安装的子系统。</p>
<p><strong>3. 卸载已安装的子系统: <code>wslconfig /u &lt;DistributionName&gt;</code></strong><br>
同上替换 <code>&lt;DistributionName&gt;</code> 。经测试发现，此 <code>"卸载"</code> 并不会卸载商店中安装的 <code>Ubuntu</code> 应用, 即再次执行该应用又会重新安装了。</p>
</blockquote>
<h3>2018-10-11追加</h3>
<hr>
<p>官方博客中给出了命令行方式来安装指定版本的 <strong>WSL</strong> ( <a href="https://blogs.msdn.microsoft.com/commandline/2018/05/15/build-2018-recap/" rel="nofollow">参考</a> )<br>
以 <strong>管理员权限</strong> 启动 <strong>PowerShell</strong> ( 快捷键 <code>WIN + X</code> 调出 ) 执行下面命令</p>
<ul>
<li>启用 <strong>WSL</strong> 特性</li>
</ul>
<div class="highlight highlight-source-powershell"><pre><span class="pl-c"><span class="pl-c">#</span> 会提示重启电脑<span class="pl-c"></span></span>
<span class="pl-c1">Enable-WindowsOptionalFeature</span> <span class="pl-k">-</span>Online <span class="pl-k">-</span>FeatureName Microsoft<span class="pl-k">-</span>Windows<span class="pl-k">-</span>Subsystem<span class="pl-k">-</span>Linux</pre></div>
<ul>
<li>安装 <strong>Ubuntu</strong></li>
</ul>
<div class="highlight highlight-source-powershell"><pre><span class="pl-c"><span class="pl-c">#</span> 下载安装包<span class="pl-c"></span></span>
<span class="pl-c1">Invoke-WebRequest</span> <span class="pl-k">-</span>Uri https:<span class="pl-k">//</span>aka.ms<span class="pl-k">/</span>wsl<span class="pl-k">-</span>ubuntu<span class="pl-k">-</span><span class="pl-c1">1604</span> <span class="pl-k">-</span>OutFile ~<span class="pl-k">/</span>Ubuntu.appx <span class="pl-k">-</span>UseBasicParsing
<span class="pl-c"><span class="pl-c">#</span> 安装<span class="pl-c"></span></span>
<span class="pl-c1">Add-AppxPackage</span> <span class="pl-k">-</span>Path ~<span class="pl-k">/</span>Ubuntu.appx
<span class="pl-c"><span class="pl-c">#</span> 启动<span class="pl-c"></span></span>
<span class="pl-c1">Ubuntu.exe</span></pre></div>
<ul>
<li>安装 <strong>SLES</strong></li>
</ul>
<div class="highlight highlight-source-powershell"><pre><span class="pl-c"><span class="pl-c">#</span> 下载安装包<span class="pl-c"></span></span>
<span class="pl-c1">Invoke-WebRequest</span> <span class="pl-k">-</span>Uri https:<span class="pl-k">//</span>aka.ms<span class="pl-k">/</span>wsl<span class="pl-k">-</span>sles<span class="pl-k">-</span><span class="pl-c1">12</span> <span class="pl-k">-</span>OutFile ~<span class="pl-k">/</span>SLES.appx <span class="pl-k">-</span>UseBasicParsing
<span class="pl-c"><span class="pl-c">#</span> 安装<span class="pl-c"></span></span>
<span class="pl-c1">Add-AppxPackage</span> <span class="pl-k">-</span>Path ~<span class="pl-k">/</span>SLES.appx
<span class="pl-c"><span class="pl-c">#</span> 启动<span class="pl-c"></span></span>
<span class="pl-c1">sles-12.exe</span></pre></div>
<ul>
<li>安装 <strong>openSUSE</strong></li>
</ul>
<div class="highlight highlight-source-powershell"><pre><span class="pl-c"><span class="pl-c">#</span> 下载安装包<span class="pl-c"></span></span>
<span class="pl-c1">Invoke-WebRequest</span> <span class="pl-k">-</span>Uri https:<span class="pl-k">//</span>aka.ms<span class="pl-k">/</span>wsl<span class="pl-k">-</span>opensuse<span class="pl-k">-</span><span class="pl-c1">42</span> <span class="pl-k">-</span>OutFile ~<span class="pl-k">/</span>openSUSE.appx <span class="pl-k">-</span>UseBasicParsing
<span class="pl-c"><span class="pl-c">#</span> 安装<span class="pl-c"></span></span>
<span class="pl-c1">Add-AppxPackage</span> <span class="pl-k">-</span>Path ~<span class="pl-k">/</span>openSUSE.appx
<span class="pl-c"><span class="pl-c">#</span> 启动<span class="pl-c"></span></span>
<span class="pl-c1">opensuse-42.exe</span></pre></div>
<h3>写在最后</h3>
<hr>
<p><strong>WSL</strong> 折腾完有一段时间了，只是一直没时间记录下来（也许是懒吧）。在此之前，由于工作需要，偶尔兼职运维的角色，折腾下服务器什么的，就很业余的学习了一些 <strong>Linux</strong> 指令。以前装过 <strong>vmware</strong> ，体验不是很好就不想装了，所以写 <strong>shell</strong> 脚本、编译源码什么的都是在公司测试服务器上练习的，现在有了 <strong>WSL</strong> 之后就可以在自己本地练习了 ( 肆意折腾，哈哈哈 )。使用方面，体验和使用终端工具连接远程服务器是差不多的；性能方面，子系统( <strong>bash</strong> 进程 ) 本身是不占多少内存的，启动程序几乎相当于启动 <strong>Windows</strong> 程序了，不显示图形界面内存都占用比较小，肯定优于"印象中的虚拟机"。总的来说，<strong>WSL</strong> 还是比较值得推荐去折腾的，也比较适合新手学习 <strong>Linux</strong>，虽然我也只是个小白⊙﹏⊙</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="http://www.jianshu.com/p/bc38ed12da1d">http://www.jianshu.com/p/bc38ed12da1d</a></h4>]]></content:encoded>
            <enclosure url="http://upload-images.jianshu.io/upload_images/1836534-3de1112894a16dda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/jpg"/>
        </item>
        <item>
            <title><![CDATA[pjax使用小结]]></title>
            <link>https://anyesu.github.io/blog/articles/7</link>
            <guid>7</guid>
            <pubDate>Fri, 08 Mar 2019 07:52:36 GMT</pubDate>
            <description><![CDATA[前言 上周看到一篇文章在分析简书 我的主页 页面 3 个 tab 页切换的 bug，起先以为是寻常的样式 bug 而已没怎么在意，后来在文章中看到 pjax 这个术语，长得和 ajax 有点像，遂去了解了下。 简介 虽然传统的 ajax 方式可以异步无刷新改变页面内容，但无法改变页面 URL，因此有种方案是在内容发生改变后通过改变 URL 的 hash 的方式获得更好的可访问性（如 https:/]]></description>
            <content:encoded><![CDATA[<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1b558654cc1ae33c74d123226cb867e08613355c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656166353932313963623063326235332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/1b558654cc1ae33c74d123226cb867e08613355c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d656166353932313963623063326235332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="pjax" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-eaf59219cb0c2b53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h3>前言</h3>
<hr>
<p>上周看到一篇文章在分析简书 <a href="http://www.jianshu.com/users/c5327915649c/latest_articles" rel="nofollow">我的主页</a> 页面 3 个 tab 页切换的 <strong>bug</strong>，起先以为是寻常的样式 <strong>bug</strong> 而已没怎么在意，后来在文章中看到 <strong>pjax</strong> 这个术语，长得和 <strong>ajax</strong> 有点像，遂去了解了下。</p>
<h3>简介</h3>
<hr>
<p>虽然传统的 <strong>ajax</strong> 方式可以异步无刷新改变页面内容，但无法改变页面 <strong>URL</strong>，因此有种方案是在内容发生改变后通过改变 <strong>URL</strong> 的 <strong>hash</strong> 的方式获得更好的可访问性（如 <a rel="nofollow" href="https://liyu365.github.io/BG-UI/tpl/#page/desktop.html">https://liyu365.github.io/BG-UI/tpl/#page/desktop.html</a>），但是 <strong>hash</strong> 的方式有时候不能很好的处理浏览器的前进、后退，而且常规代码要切换到这种方式还要做不少额外的处理。而 <strong>pjax</strong> 的出现就是为了解决这些问题，简单的说就是对 <strong>ajax</strong> 的加强。</p>
<blockquote>
<p>pjax 结合 pushState 和 ajax 技术， 不需要重新加载整个页面就能从服务器加载 Html 到你当前页面，这个 ajax 请求会有永久链接、title 并支持浏览器的回退/前进按钮。</p>
</blockquote>
<p><strong>pjax</strong> 项目地址在  <a href="https://github.com/defunkt/jquery-pjax">https://github.com/defunkt/jquery-pjax</a> 。 实际的效果见： <a rel="nofollow" href="http://pjax.herokuapp.com">http://pjax.herokuapp.com</a> 没有勾选 <strong>pjax</strong> 的时候点击链接是跳转的， 勾选了之后链接都是变成了 <strong>ajax</strong> 刷新（实际效果如下图的请求内容对比）。<br>
<a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/d694ba31a3bb1275a76441cbba77c26055acaf2b/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d366336386465656164663062393261362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/d694ba31a3bb1275a76441cbba77c26055acaf2b/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d366336386465656164663062393261362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="不使用pjax" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-6c68deeadf0b92a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/8acc164e8a90292476e8343e89765016a4e77310/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303565626164366136396531616366652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/8acc164e8a90292476e8343e89765016a4e77310/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d303565626164366136396531616366652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="使用pjax" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-05ebad6a69e1acfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<h6>优点：</h6>
<ul>
<li>减轻服务端压力</li>
</ul>
<blockquote>
<p>按需请求，每次只需加载页面的部分内容，而不用重复加载一些公共的资源文件和不变的页面结构，大大减小了数据请求量，以减轻对服务器的带宽和性能压力，还大大提升了页面的加载速度。</p>
</blockquote>
<ul>
<li>优化页面跳转体验</li>
</ul>
<blockquote>
<p>常规页面跳转需要重新加载画面上的内容，会有明显的闪烁，而且往往和跳转前的页面没有连贯性，用户体验不是很好。如果再遇上页面比较庞大、网速又不是很好的情况，用户体验就更加雪上加霜了。使用pjax后，由于只刷新部分页面，切换效果更加流畅，而且可以定制过度动画，在等待页面加载的时候体验就比较舒服了。</p>
</blockquote>
<h6>缺点：</h6>
<ul>
<li><strong>不支持一些低版本的浏览器(如IE系列)</strong></li>
</ul>
<blockquote>
<p>pjax使用了pushState来改变地址栏的url，这是html5中history的新特性，在某些旧版浏览器中可能不支持。不过pjax会进行判断，功能不适用的时候会执行默认的页面跳转操作。</p>
</blockquote>
<ul>
<li><strong>使服务端处理变得复杂</strong></li>
</ul>
<blockquote>
<p>要做到普通请求返回完整页面，而pjax请求只返回部分页面，服务端就需要做一些特殊处理，当然这对于设计良好的后端框架来说，添加一些统一处理还是比较容易的，自然也没太大问题。另外，即使后台不做处理，设置pjax的fragment参数来达到同样的效果。</p>
</blockquote>
<p>综合来看，<strong>pajx</strong> 的优点很强势，缺点也几乎可以忽略，还是非常值得推荐的，尤其是类似博客这种大部分情况下只有主体内容变化的网站。关键它使用简单、学习成本小，即时全站只有极个别页面能用得到，尝试下没什么损失。<strong>pjax</strong> 的 <strong>github</strong> 主页介绍的已经很详细了，想了解更多可以看下源码。</p>
<h3>用法</h3>
<hr>
<ol>
<li>引入 jquery 和 <a href="https://raw.github.com/defunkt/jquery-pjax/master/jquery.pjax.js">jquery.pjax.js</a></li>
<li>注册事件</li>
</ol>
<div class="highlight highlight-source-js"><pre><span class="pl-c">/**</span>
<span class="pl-c">  * 方式一 按钮父节点监听事件</span>
<span class="pl-c">  *</span>
<span class="pl-c">  * <span class="pl-k">@param</span> selector  触发点击事件的按钮</span>
<span class="pl-c">  * <span class="pl-k">@param</span> container 展示刷新内容的容器，也就是会被替换的部分</span>
<span class="pl-c">  * <span class="pl-k">@param</span> options   参数</span>
<span class="pl-c">  */</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">pjax</span><span class="pl-kos">(</span><span class="pl-s1">selector</span><span class="pl-kos">,</span> <span class="pl-kos">[</span><span class="pl-s1">container</span><span class="pl-kos">]</span><span class="pl-kos">,</span> <span class="pl-s1">options</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">// 方式二 直接对按钮监听，可以不用指定容器，使用按钮的data-pjax属性值查找容器</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-s">"a[data-pjax]"</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">pjax</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">// 方式三 常规的点击事件监听方式</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">on</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s">'a'</span><span class="pl-kos">,</span> <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-c1">pjax</span><span class="pl-kos">.</span><span class="pl-c1">click</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">on</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s">'a'</span><span class="pl-kos">,</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
	<span class="pl-k">var</span> <span class="pl-s1">container</span> <span class="pl-c1">=</span> <span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">closest</span><span class="pl-kos">(</span><span class="pl-s">'[data-pjax-container]'</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-c1">pjax</span><span class="pl-kos">.</span><span class="pl-en">click</span><span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">,</span> <span class="pl-s1">container</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">// 下列是源码中介绍的其他用法，由于本人暂时没有那些需求暂时没深究，有兴趣的各位自己试试看哈</span>
<span class="pl-c">// 表单提交</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">on</span><span class="pl-kos">(</span><span class="pl-s">'submit'</span><span class="pl-kos">,</span> <span class="pl-s">'form'</span><span class="pl-kos">,</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">var</span> <span class="pl-s1">container</span> <span class="pl-c1">=</span> <span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">closest</span><span class="pl-kos">(</span><span class="pl-s">'[data-pjax-container]'</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-c1">pjax</span><span class="pl-kos">.</span><span class="pl-en">submit</span><span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">,</span> <span class="pl-s1">container</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-c">// 加载内容到指定容器</span>
<span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-en">pjax</span><span class="pl-kos">(</span><span class="pl-kos">{</span> <span class="pl-c1">url</span>: <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">href</span><span class="pl-kos">,</span> <span class="pl-c1">container</span>: <span class="pl-s">'#main'</span> <span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-c">// 重新当前页面容器的内容</span>
<span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-c1">pjax</span><span class="pl-kos">.</span><span class="pl-en">reload</span><span class="pl-kos">(</span><span class="pl-s">'#container'</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<h3>options默认参数说明</h3>
<hr>
<table role="table">
<thead>
<tr>
<th>参数名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeout</td>
<td>650</td>
<td><code>ajax</code> 超时时间（单位 <code>ms</code> ），超时后会执行默认的页面跳转，所以超时时间不应过短，不过一般不需要设置</td>
</tr>
<tr>
<td>push</td>
<td>true</td>
<td>使用 <code>window.history.pushState</code> 改变地址栏 <code>url</code>（ 会添加新的历史记录 ）</td>
</tr>
<tr>
<td>replace</td>
<td>false</td>
<td>使用 <code>window.history.replaceState</code> 改变地址栏 <code>url</code>（ 不会添加历史记录 ）</td>
</tr>
<tr>
<td>maxCacheLength</td>
<td>20</td>
<td>缓存的历史页面个数（ <code>pjax</code> 加载新页面前会把原页面的内容缓存起来，缓存加载后其中的脚本会再次执行 ）</td>
</tr>
<tr>
<td>version</td>
<td></td>
<td>是一个函数，返回当前页面的pjax-version，即页面中 <code>&lt;meta http-equiv="x-pjax-version"&gt;</code> 标签内容。使用 <code>response.setHeader("X-PJAX-Version", "")</code> 设置与当前页面不同的版本号，可强制页面跳转而不是局部刷新。</td>
</tr>
<tr>
<td>scrollTo</td>
<td>0</td>
<td>页面加载后垂直滚动距离（ 与原页面保持一致可使过度效果更平滑 ）</td>
</tr>
<tr>
<td>type</td>
<td>"GET"</td>
<td><code>ajax</code> 的参数，<code>http</code> 请求方式</td>
</tr>
<tr>
<td>dataType</td>
<td>"html"</td>
<td><code>ajax</code> 的参数，响应内容的 <code>Content-Type</code></td>
</tr>
<tr>
<td>container</td>
<td></td>
<td>用于查找容器的 <code>CSS 选择器</code>，[container] 参数没有指定时使用</td>
</tr>
<tr>
<td>url</td>
<td>link.href</td>
<td>要跳转的连接，默认 <code>a 标签</code>的 <code>href</code> 属性</td>
</tr>
<tr>
<td>target</td>
<td>link</td>
<td><code>pjax</code> 事件参数 <code>e</code> 的 <code>relatedTarget</code> 属性，默认为点击的 <code>a 标签</code></td>
</tr>
<tr>
<td>fragment</td>
<td></td>
<td>使用响应内容的指定部分（ <code>CSS 选择器</code> ）填充页面，服务端不进行处理导致全页面请求的时候需要使用该参数，简单的说就是对请求到的页面做截取</td>
</tr>
</tbody>
</table>
<p>除了上述参数外，<strong>ajax</strong> 的一些参数也是可以设置在这里的，不过一般没什么必要。</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c">// ajax 最终参数: </span>
<span class="pl-s1">options</span> <span class="pl-c1">=</span> <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-en">extend</span><span class="pl-kos">(</span><span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-kos">{</span><span class="pl-kos">}</span><span class="pl-kos">,</span> <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-c1">ajaxSettings</span><span class="pl-kos">,</span> <span class="pl-s1">pjax</span><span class="pl-kos">.</span><span class="pl-c1">defaults</span><span class="pl-kos">,</span> <span class="pl-s1">options</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<h3>pjax失效情况</h3>
<hr>
<p>会有一些情况导致 <strong>pjax</strong> 失效，下面结合源码分析下（省略部分无关代码）</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">handleClick</span><span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">,</span> <span class="pl-s1">container</span><span class="pl-kos">,</span> <span class="pl-s1">options</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    ...
    
    <span class="pl-c">// 1. 点击事件的事件源不是a标签。使用a标签可以做到对旧版本浏览器的兼容，所以不建议使用其他标签注册事件</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">link</span><span class="pl-kos">.</span><span class="pl-c1">tagName</span><span class="pl-kos">.</span><span class="pl-en">toUpperCase</span><span class="pl-kos">(</span><span class="pl-kos">)</span> !== <span class="pl-s">'A'</span><span class="pl-kos">)</span>
        <span class="pl-k">throw</span> <span class="pl-s">"$.fn.pjax or $.pjax.click requires an anchor element"</span>

    <span class="pl-c">// 2. 使用鼠标滚轮点击(新标签页打开)</span>
    <span class="pl-c">// 点击超链接的同时按下Shift、Ctrl、Alt和Meta（在Windows键盘中是Windows键，在苹果机中是Cmd键）</span>
    <span class="pl-c">// 作用分别代表新窗口打开、新标签打开（不切换标签）、下载、新标签打开（切换标签）</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-c1">which</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">1</span> <span class="pl-c1">||</span> <span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-c1">metaKey</span> <span class="pl-c1">||</span> <span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-c1">ctrlKey</span> <span class="pl-c1">||</span> <span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-c1">shiftKey</span> <span class="pl-c1">||</span> <span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-c1">altKey</span><span class="pl-kos">)</span>
        <span class="pl-k">return</span>

    <span class="pl-c">// 3. 跨域（网络通讯协议，域名不一致）</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">location</span><span class="pl-kos">.</span><span class="pl-c1">protocol</span> !== <span class="pl-s1">link</span><span class="pl-kos">.</span><span class="pl-c1">protocol</span> <span class="pl-c1">||</span> <span class="pl-s1">location</span><span class="pl-kos">.</span><span class="pl-c1">hostname</span> !== <span class="pl-s1">link</span><span class="pl-kos">.</span><span class="pl-c1">hostname</span><span class="pl-kos">)</span>
        <span class="pl-k">return</span>

    <span class="pl-c">// 4. 当前页面的锚点定位</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">link</span><span class="pl-kos">.</span><span class="pl-c1">href</span><span class="pl-kos">.</span><span class="pl-en">indexOf</span><span class="pl-kos">(</span><span class="pl-s">'#'</span><span class="pl-kos">)</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">-</span><span class="pl-c1">1</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">stripHash</span><span class="pl-kos">(</span><span class="pl-s1">link</span><span class="pl-kos">)</span> <span class="pl-c1">==</span> <span class="pl-en">stripHash</span><span class="pl-kos">(</span><span class="pl-s1">location</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
        <span class="pl-k">return</span>

    <span class="pl-c">// 5. 已经阻止元素发生默认的行为（url跳转）</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-en">isDefaultPrevented</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
        <span class="pl-k">return</span>

    ...

    <span class="pl-k">var</span> <span class="pl-s1">clickEvent</span> <span class="pl-c1">=</span> <span class="pl-s1">$</span><span class="pl-kos">.</span><span class="pl-en">Event</span><span class="pl-kos">(</span><span class="pl-s">'pjax:click'</span><span class="pl-kos">)</span>
    <span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-s1">link</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">trigger</span><span class="pl-kos">(</span><span class="pl-s1">clickEvent</span><span class="pl-kos">,</span> <span class="pl-kos">[</span><span class="pl-s1">opts</span><span class="pl-kos">]</span><span class="pl-kos">)</span>

    <span class="pl-c">// 6. pjax:click事件回调中已经阻止元素发生默认的行为（url跳转）</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span>!<span class="pl-s1">clickEvent</span><span class="pl-kos">.</span><span class="pl-en">isDefaultPrevented</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-en">pjax</span><span class="pl-kos">(</span><span class="pl-s1">opts</span><span class="pl-kos">)</span>
        <span class="pl-s1">event</span><span class="pl-kos">.</span><span class="pl-en">preventDefault</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-c">// 阻止url跳转</span>
        <span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-s1">link</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">trigger</span><span class="pl-kos">(</span><span class="pl-s">'pjax:clicked'</span><span class="pl-kos">,</span> <span class="pl-kos">[</span><span class="pl-s1">opts</span><span class="pl-kos">]</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span></pre></div>
<p><strong>除了上述情况之外，还有下列几种情况：</strong></p>
<ul>
<li><strong>ajax</strong> 请求失败，或者 timeout 后请求被中止</li>
<li>当前页面的 <code>X-PJAX-Version</code> 和请求的新页面版本不一致</li>
<li>请求得到完整的页面（包含 <strong>html</strong> 标签）却没设置 <code>fragment</code> 参数</li>
</ul>
<h3>事件</h3>
<hr>
<h5>1. 点击链接后触发的一系列事件， 除了 <code>pjax:click</code> 和 <code>pjax:clicked</code> 的事件源是点击的按钮，其他事件的事件源都是要替换内容的容器。可以在 <code>pjax:start</code> 事件触发时开始过度动画，在 <code>pjax:end</code> 事件触发时结束过度动画。</h5>
<table role="table">
<thead>
<tr>
<th>事件名</th>
<th align="center">支持取消</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pjax:click</td>
<td align="center"><code>✔</code></td>
<td>options</td>
<td>点击按钮时触发。可调用 <code>e.preventDefault();</code> 取消<code>pjax</code></td>
</tr>
<tr>
<td>pjax:beforeSend</td>
<td align="center"><code>✔</code></td>
<td>xhr, options</td>
<td><code>ajax</code> 执行 <code>beforeSend</code> 函数时触发，可在回调函数中设置额外的请求头参数。可调用 <code>e.preventDefault();</code> 取消 <code>pjax</code></td>
</tr>
<tr>
<td>pjax:start</td>
<td align="center"></td>
<td>xhr, options</td>
<td><code>pjax</code> 开始（与服务器连接建立后触发）</td>
</tr>
<tr>
<td>pjax:send</td>
<td align="center"></td>
<td>xhr, options</td>
<td><code>pjax:start</code> 之后触发</td>
</tr>
<tr>
<td>pjax:clicked</td>
<td align="center"></td>
<td>options</td>
<td><code>ajax</code> 请求开始后触发</td>
</tr>
<tr>
<td>pjax:beforeReplace</td>
<td align="center"></td>
<td>contents, options</td>
<td><code>ajax</code> 请求成功，内容替换渲染前触发</td>
</tr>
<tr>
<td>pjax:success</td>
<td align="center"></td>
<td>data, status, xhr, options</td>
<td>内容替换成功后触发</td>
</tr>
<tr>
<td>pjax:timeout</td>
<td align="center"><code>✔</code></td>
<td>xhr, options</td>
<td><code>ajax</code> 请求超时后触发。可调用 <code>e.preventDefault();</code> 继续等待 <code>ajax</code> 请求结束</td>
</tr>
<tr>
<td>pjax:error</td>
<td align="center"><code>✔</code></td>
<td>xhr, textStatus, error, options</td>
<td><code>ajax</code> 请求失败后触发。默认失败后会跳转 url，如要阻止跳转可调用 <code>e.preventDefault();</code></td>
</tr>
<tr>
<td>pjax:complete</td>
<td align="center"></td>
<td>xhr, textStatus, options</td>
<td><code>ajax</code> 请求结束后触发，不管成功还是失败</td>
</tr>
<tr>
<td>pjax:end</td>
<td align="center"></td>
<td>xhr, options</td>
<td><code>pjax</code> 所有事件结束后触发</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：<br>
<code>pjax:beforeReplace</code> 事件前 <strong>pjax</strong> 会调用 <code>extractContainer</code> 函数处理页面内容，即以 <code>script[src]</code> 的形式引入的 <code>js</code> 脚本不会被重复加载，有必要可以改下<strong>源码</strong>。</li>
</ul>
<h5>2. 浏览器前进/后退导航时触发的事件（暂时没做过多研究）</h5>
<table role="table">
<thead>
<tr>
<th>事件名</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pjax:popstate</td>
<td></td>
<td>页面导航方向: 'forward'/'back'（前进/后退）</td>
</tr>
<tr>
<td>pjax:start</td>
<td>null, options</td>
<td><code>pjax</code> 开始</td>
</tr>
<tr>
<td>pjax:beforeReplace</td>
<td>contents, options</td>
<td>内容替换渲染前触发，如果缓存了要导航页面的内容则使用缓存，否则使用 <code>pjax</code> 加载</td>
</tr>
<tr>
<td>pjax:end</td>
<td>null, options</td>
<td><code>pjax</code> 结束</td>
</tr>
</tbody>
</table>
<h3>服务端配置</h3>
<hr>
<p>我的项目是 <strong>Spring MVC + velocity</strong> 的组合，这里就以此为例子，其他语言和框架的服务端可以参考下这里的思路。<br>
项目中使用的视图解析器是 <code>org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver</code> 这个类，好处是可以使用模版技术，每个页面可以只写主体内容，公共部分统一写在模版里面，是不是和 <strong>pjax</strong> 绝配哈！<strong>pjax.js</strong> 默认会在请求头加入 <code>X_PJAX</code> 字段，并置为 <code>true</code>，所以以此来判断是否 <strong>pjax</strong> 请求。对于普通的请求使用常规的模版，<strong>pjax</strong> 请求则使用空模版或者特定的模版。</p>
<ul>
<li>常规模版内容：</li>
</ul>
<pre lang="velocity"><code>&lt;!doctype html&gt;
&lt;html&gt;
	#set($basePath = "screen/contain")
	&lt;head&gt;
		&lt;meta http-equiv="x-pjax-version" content="$!{X-PJAX-Version}"/&gt;
		#parse("$basePath/html-head.vm")
	&lt;/head&gt;
	&lt;body&gt;
		&lt;section id="container"&gt;
			#parse("$basePath/frame-head.vm")
			#parse("$basePath/frame-left.vm")
			&lt;section id="main-content"&gt;
			    &lt;section class="wrapper"&gt;
			        $screen_content ##页面内容
			    &lt;/section&gt;
			&lt;/section&gt;
			#parse("$basePath/frame-bottom.vm")
		&lt;/section&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>添加 <strong>SpringMVC</strong> 中的 <code>Interceptor 拦截器</code>，用于后端渲染前插入 <strong>pjax</strong> 处理</li>
</ul>
<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">PjaxInterceptor</span> <span class="pl-k">extends</span> <span class="pl-e">HandlerInterceptorAdapter</span> {

	<span class="pl-k">@Value</span>(<span class="pl-s"><span class="pl-pds">"</span>${X-PJAX-Version}<span class="pl-pds">"</span></span>)
	<span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-c1">X_PJAX_VERSION</span>;

	<span class="pl-c"><span class="pl-c">/**</span></span>
<span class="pl-c">	 * Controller 方法调用之后，页面渲染前执行</span>
<span class="pl-c">	 * </span>
<span class="pl-c">	 * <span class="pl-k">@param</span> request</span>
<span class="pl-c">	 * <span class="pl-k">@param</span> response</span>
<span class="pl-c">	 * <span class="pl-k">@param</span> handler</span>
<span class="pl-c">	 * <span class="pl-k">@param</span> modelAndView</span>
<span class="pl-c">	 * <span class="pl-k">@throws</span> Exception</span>
<span class="pl-c">	 <span class="pl-c">*/</span></span>
	<span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">postHandle</span>(<span class="pl-smi">HttpServletRequest</span> <span class="pl-v">request</span>, <span class="pl-smi">HttpServletResponse</span> <span class="pl-v">response</span>, <span class="pl-smi">Object</span> <span class="pl-v">handler</span>, <span class="pl-smi">ModelAndView</span> <span class="pl-v">modelAndView</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
		<span class="pl-k">if</span> (modelAndView <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
			<span class="pl-k">boolean</span> isPajx <span class="pl-k">=</span> <span class="pl-smi">Boolean</span><span class="pl-k">.</span>parseBoolean(request<span class="pl-k">.</span>getHeader(<span class="pl-s"><span class="pl-pds">"</span>X-PJAX<span class="pl-pds">"</span></span>));<span class="pl-c"><span class="pl-c">//</span> 值为true表示pjax请求，这是重点</span>
			<span class="pl-smi">ModelMap</span> model <span class="pl-k">=</span> modelAndView<span class="pl-k">.</span>getModelMap();
			model<span class="pl-k">.</span>addAttribute(<span class="pl-s"><span class="pl-pds">"</span>X-PJAX-Version<span class="pl-pds">"</span></span>, <span class="pl-c1">X_PJAX_VERSION</span>);<span class="pl-c"><span class="pl-c">//</span> 设置当前页面的pjax版本</span>
			<span class="pl-k">if</span> (isPajx) {
				model<span class="pl-k">.</span>addAttribute(<span class="pl-s"><span class="pl-pds">"</span>layout<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>layout_pjax.vm<span class="pl-pds">"</span></span>);<span class="pl-c"><span class="pl-c">//</span> 指定pjax请求时使用的模版</span>
				<span class="pl-c"><span class="pl-c">//</span> 在vm页面中通过 #set($layout = 'xxx.vm') 的方式指定模版</span>
				response<span class="pl-k">.</span>setHeader(<span class="pl-s"><span class="pl-pds">"</span>X-PJAX-Version<span class="pl-pds">"</span></span>, <span class="pl-c1">X_PJAX_VERSION</span>);<span class="pl-c"><span class="pl-c">//</span> 响应内容的pjax版本，有新模版发布时，通过配置文件修改版本来强制页面刷新</span>
			}
		}
	}
}</pre></div>
<ul>
<li>xml 配置</li>
</ul>
<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">mvc</span><span class="pl-ent">:</span><span class="pl-ent">interceptors</span>&gt;
    &lt;<span class="pl-ent">mvc</span><span class="pl-ent">:</span><span class="pl-ent">interceptor</span>&gt;
        &lt;<span class="pl-ent">mvc</span><span class="pl-ent">:</span><span class="pl-ent">mapping</span> <span class="pl-e">path</span>=<span class="pl-s"><span class="pl-pds">"</span>/**<span class="pl-pds">"</span></span>/&gt;
        &lt;<span class="pl-ent">bean</span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>pjaxInterceptor<span class="pl-pds">"</span></span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>xxx.PjaxInterceptor<span class="pl-pds">"</span></span>/&gt;
    &lt;/<span class="pl-ent">mvc</span><span class="pl-ent">:</span><span class="pl-ent">interceptor</span>&gt;
&lt;/<span class="pl-ent">mvc</span><span class="pl-ent">:</span><span class="pl-ent">interceptors</span>&gt;</pre></div>
<ul>
<li>pjax 请求模版页面：<strong>layout_pjax.vm</strong></li>
</ul>
<pre lang="velocity"><code>&lt;title&gt;$!{title}&lt;/title&gt;
$screen_content
</code></pre>
<p>模版中使用 <code>title</code> 标签，这样执行 <strong>pjax</strong> 请求时不仅地址栏 <strong>url</strong> 会变化，而且浏览器标签的标题内容也会变化。</p>
<p>针对没有服务端处理的方案如下：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c">// fragment一般同container一致</span>
<span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">pjax</span><span class="pl-kos">(</span><span class="pl-s">'a[data-pjax]'</span><span class="pl-kos">,</span> <span class="pl-s">'#main-content .wrapper'</span><span class="pl-kos">,</span> <span class="pl-kos">{</span><span class="pl-c1">fragment</span>: <span class="pl-s">'#main-content .wrapper'</span><span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<h3>插件伴侣——<a href="http://ricostacruz.com/nprogress" rel="nofollow">NProgress</a></h3>
<hr>
<p>比较漂亮的一款进度条插件，用法十分简单，很适合做pjax的过度动画，详细用法在该项目 <a href="https://github.com/rstacruz/nprogress">github</a> 上有介绍</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/9d40cd0602b0ce5f39faef62b72fa17730450a34/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353961333936653037633731386134322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/9d40cd0602b0ce5f39faef62b72fa17730450a34/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d353961333936653037633731386134322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="NProgress" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-59a396e07c718a42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<ul>
<li>示例：</li>
</ul>
<div class="highlight highlight-source-js"><pre><span class="pl-en">$</span><span class="pl-kos">(</span><span class="pl-smi">document</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">on</span><span class="pl-kos">(</span><span class="pl-s">'pjax:start'</span><span class="pl-kos">,</span> <span class="pl-v">NProgress</span><span class="pl-kos">.</span><span class="pl-c1">start</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">on</span><span class="pl-kos">(</span><span class="pl-s">'pjax:end'</span><span class="pl-kos">,</span> <span class="pl-v">NProgress</span><span class="pl-kos">.</span><span class="pl-c1">done</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<h3>结语</h3>
<hr>
<p>虽然个人还是比较喜欢造轮子（有成就感），不怎么喜欢用插件（一般插件使用复杂，文档少学习成本大，还不如自己写），但看了 <strong>pjax</strong> 的源码后感觉真要自己也使用 <strong>pushState + ajax</strong> 的方式简单的实现它的功能，还是要踩不少坑的，所以为什么要放着这么个易用又精致的<strong>小轮子</strong>不用呢？我的项目是一个管理系统，统一的 <strong>左侧菜单 + 右侧table</strong> 的布局，每个页面都需要一个独立访问的 <strong>url</strong>，非常适合使用 <strong>pjax</strong>。由于使用的 <strong>velocity</strong> 模版技术，集成 <strong>pjax</strong> 就是分分钟的事，不仅对原先的代码完全没影响，还提升了加载速度，页面过度效果更好，再用上了 <strong>NProgress</strong>，感觉逼格又上升不少，哈哈。</p>
<p>前段时间工作比较忙好久没写文章了，这段时间有点闲下来就抽空学了些新东西记录下，对于这次的学习成果还是比较满意的。( *^_^* )</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/557cad38e7dd">https://www.jianshu.com/p/557cad38e7dd</a></h4>]]></content:encoded>
            <enclosure url="http://upload-images.jianshu.io/upload_images/1836534-eaf59219cb0c2b53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[UWP不归路——自定义后退事件管理]]></title>
            <link>https://anyesu.github.io/blog/articles/6</link>
            <guid>6</guid>
            <pubDate>Fri, 08 Mar 2019 07:31:26 GMT</pubDate>
            <description><![CDATA[在 UWP 中可以调用如下方法对后退按钮进行事件处理，比如页面导航，退出全屏，双击退出等等。 // 注册后退事件 SystemNavigationManager.GetForCurrentView().BackRequested += PageBackRequested; // 后退事件处理 private void PageBackRequested(object sender, BackReq]]></description>
            <content:encoded><![CDATA[<p><a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/e965bc92ffcb581bb75ac325b10406a1312d2bf7/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613866353336396235326362653164642e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/e965bc92ffcb581bb75ac325b10406a1312d2bf7/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313833363533342d613866353336396235326362653164642e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="双击退出" data-canonical-src="http://upload-images.jianshu.io/upload_images/1836534-a8f5369b52cbe1dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"></a></p>
<p>在 <strong>UWP</strong> 中可以调用如下方法对后退按钮进行事件处理，比如页面导航，退出全屏，双击退出等等。</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> 注册后退事件</span>
<span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">+=</span> <span class="pl-smi">PageBackRequested</span>;

<span class="pl-c"><span class="pl-c">//</span> 后退事件处理</span>
<span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">PageBackRequested</span>(<span class="pl-k">object</span> <span class="pl-smi">sender</span>, <span class="pl-en">BackRequestedEventArgs</span> <span class="pl-smi">e</span>)
{
    <span class="pl-smi">e</span>.<span class="pl-smi">Handled</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;<span class="pl-c"><span class="pl-c">//</span> 阻止后面注册的事件继续执行</span>
    <span class="pl-c"><span class="pl-c">//</span> TODO</span>
}

<span class="pl-c"><span class="pl-c">//</span> 注销</span>
<span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">-=</span> <span class="pl-smi">PageBackRequested</span>;</pre></div>
<p>  通过上面的调用已经可以对后退按钮定制不同的点击效果，但是，还存在一个问题。应用中肯定会有很多的页面，每个页面对于后退按钮的处理需求肯定会有所不同，多次注册后退事件（连续注册不注销）是难免的，注册后退事件实际上是把每个事件处理依次加入到一个事件队列中去，每当点击后退按钮的时候，就会按照先后顺序依次执行事件处理，因此就会存在后面处理和前面的处理产生冲突导致无法实现预期中的效果，还需要做一些费劲的特殊处理才能正常使用。</p>
<p>  所以可以做一个简单的封装，实现只处理最后注册的事件</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> <span class="pl-en">System</span>;
<span class="pl-k">using</span> <span class="pl-en">System</span>.<span class="pl-en">Collections</span>;
<span class="pl-k">using</span> <span class="pl-en">Windows</span>.<span class="pl-en">UI</span>.<span class="pl-en">Core</span>;

<span class="pl-k">namespace</span> <span class="pl-en">indi</span>.<span class="pl-en">anyesu</span>.<span class="pl-en">UWP</span>.<span class="pl-en">Core</span>.<span class="pl-en">Managers</span>
{
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> 自定义后退事件管理:</span>
    <span class="pl-c"><span class="pl-c">//</span>     允许只调用最后注册的后退事件，而SystemNavigationManager的后退事件是按顺序依次执行的。</span>
    <span class="pl-k">public</span> <span class="pl-k">sealed</span> <span class="pl-k">class</span> <span class="pl-en">BackEventManager</span>
    {

        <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-en">Stack</span> <span class="pl-smi">BackEventStack</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Stack</span>();

        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> 注册后退事件</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">Register</span>(<span class="pl-en">EventHandler</span>&lt;<span class="pl-en">BackRequestedEventArgs</span>&gt; <span class="pl-smi">PageBackRequested</span>)
        {
            <span class="pl-k">if</span> (<span class="pl-smi">BackEventStack</span>.<span class="pl-smi">Count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>)
            {
                <span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">-=</span> <span class="pl-smi">BackEventStack</span>.<span class="pl-en">Peek</span>() <span class="pl-k">as</span> <span class="pl-en">EventHandler</span>&lt;<span class="pl-en">BackRequestedEventArgs</span>&gt;;
            }
            <span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">+=</span> <span class="pl-smi">PageBackRequested</span>;<span class="pl-c"><span class="pl-c">//</span> 注册到系统自带的后退事件队列</span>
            <span class="pl-smi">BackEventStack</span>.<span class="pl-en">Push</span>(<span class="pl-smi">PageBackRequested</span>);
        }

        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> 注销最后注册的后退事件</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">Unregister</span>(<span class="pl-en">EventHandler</span>&lt;<span class="pl-en">BackRequestedEventArgs</span>&gt; <span class="pl-smi">PageBackRequested</span>)
        {
            <span class="pl-k">if</span> (<span class="pl-smi">BackEventStack</span>.<span class="pl-smi">Count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>)
            {
                <span class="pl-k">var</span> <span class="pl-smi">top</span> <span class="pl-k">=</span> <span class="pl-smi">BackEventStack</span>.<span class="pl-en">Peek</span>() <span class="pl-k">as</span> <span class="pl-en">EventHandler</span>&lt;<span class="pl-en">BackRequestedEventArgs</span>&gt;;
                <span class="pl-k">if</span> (<span class="pl-smi">PageBackRequested</span>.<span class="pl-en">Equals</span>(<span class="pl-smi">top</span>))
                {
                    <span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">-=</span> <span class="pl-smi">PageBackRequested</span>;
                    <span class="pl-smi">BackEventStack</span>.<span class="pl-en">Pop</span>();
                    <span class="pl-k">if</span> (<span class="pl-smi">BackEventStack</span>.<span class="pl-smi">Count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>)
                    {
                        <span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">BackRequested</span> <span class="pl-k">+=</span> <span class="pl-smi">BackEventStack</span>.<span class="pl-en">Peek</span>() <span class="pl-k">as</span> <span class="pl-en">EventHandler</span>&lt;<span class="pl-en">BackRequestedEventArgs</span>&gt;;
                    }
                }
            }
        }
    }
}</pre></div>
<p>  主要思路是将所有注册的事件处理压入 <strong>BackEventStack</strong> 这个栈当中，保证系统自带的后退事件处理队列当中最多只有一个事件处理，即最后注册的那个。调用方法如下：</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">BackEventManager</span>.<span class="pl-en">Register</span>(<span class="pl-smi">PageBackRequested</span>);<span class="pl-c"><span class="pl-c">//</span> 注册后退事件</span>
<span class="pl-smi">BackEventManager</span>.<span class="pl-en">Unregister</span>(<span class="pl-smi">PageBackRequested</span>);<span class="pl-c"><span class="pl-c">//</span> 注销后退事件</span>
<span class="pl-c"><span class="pl-c">//</span> 注意: 最好保证注册和注销成对出现（如在页面的OnNavigatedTo方法中注册，OnNavigatedFrom方法中注销），避免出现冲突。</span></pre></div>
<p>  有了这个后退事件管理器之后，可以在 <strong>APP</strong> 初始化的时候完成后退事件的注册，实现一个统一的后退事件处理，特殊页面特殊处理，这样就不用到处贴代码了，维护起来更方便。<br>
在 <strong>App.xaml.cs</strong> 中修改 <strong>OnLaunched</strong> 方法，如下所示：</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">///</span> &lt;<span class="pl-ent"><span class="pl-ent">summary</span></span>&gt;</span>
<span class="pl-c"><span class="pl-c">///</span> 在应用程序由最终用户正常启动时进行调用。</span>
<span class="pl-c"><span class="pl-c">///</span> 将在启动应用程序以打开特定文件等情况下使用。</span>
<span class="pl-c"><span class="pl-c">///</span> &lt;/<span class="pl-ent"><span class="pl-ent">summary</span></span>&gt;</span>
<span class="pl-c"><span class="pl-c">///</span> &lt;<span class="pl-ent"><span class="pl-ent">param</span></span> <span class="pl-e"><span class="pl-e">name</span></span>=<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>&gt;有关启动请求和过程的详细信息。&lt;/<span class="pl-ent"><span class="pl-ent">param</span></span>&gt;</span>
<span class="pl-k">protected</span> <span class="pl-k">override</span> <span class="pl-k">async</span> <span class="pl-k">void</span> <span class="pl-en">OnLaunched</span>(<span class="pl-en">LaunchActivatedEventArgs</span> <span class="pl-smi">e</span>)
{
    <span class="pl-en">Frame</span> <span class="pl-smi">rootFrame</span> <span class="pl-k">=</span> <span class="pl-smi">Window</span>.<span class="pl-smi">Current</span>.<span class="pl-smi">Content</span> <span class="pl-k">as</span> <span class="pl-en">Frame</span>;
    <span class="pl-c"><span class="pl-c">//</span> 不要在窗口已包含内容时重复应用程序初始化，</span>
    <span class="pl-c"><span class="pl-c">//</span> 只需确保窗口处于活动状态</span>
    <span class="pl-k">if</span> (<span class="pl-smi">rootFrame</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> 创建要充当导航上下文的框架，并导航到第一页</span>
        <span class="pl-smi">rootFrame</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Frame</span>();
        <span class="pl-smi">rootFrame</span>.<span class="pl-smi">NavigationFailed</span> <span class="pl-k">+=</span> <span class="pl-smi">OnNavigationFailed</span>;
        <span class="pl-c"><span class="pl-c">//</span> 下面这句话是关键</span>
        <span class="pl-smi">rootFrame</span>.<span class="pl-smi">Navigated</span> <span class="pl-k">+=</span> <span class="pl-smi">OnNavigated</span>;<span class="pl-c"><span class="pl-c">//</span> 注册页面加载完毕事件</span>
        <span class="pl-k">if</span> (<span class="pl-smi">e</span>.<span class="pl-smi">PreviousExecutionState</span> <span class="pl-k">==</span> <span class="pl-smi">ApplicationExecutionState</span>.<span class="pl-smi">Terminated</span>)
        {
            <span class="pl-c"><span class="pl-c">//</span>TODO: 从之前挂起的应用程序加载状态</span>
        }
        <span class="pl-c"><span class="pl-c">//</span> 将框架放在当前窗口中</span>
        <span class="pl-smi">Window</span>.<span class="pl-smi">Current</span>.<span class="pl-smi">Content</span> <span class="pl-k">=</span> <span class="pl-smi">rootFrame</span>;
    }
    <span class="pl-k">if</span> (<span class="pl-smi">rootFrame</span>.<span class="pl-smi">Content</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> 当导航堆栈尚未还原时，导航到第一页，</span>
        <span class="pl-c"><span class="pl-c">//</span> 并通过将所需信息作为导航参数传入来配置</span>
        <span class="pl-smi">rootFrame</span>.<span class="pl-en">Navigate</span>(<span class="pl-k">typeof</span>(<span class="pl-en">MainPage</span>), <span class="pl-smi">e</span>.<span class="pl-smi">Arguments</span>);
    }
    <span class="pl-c"><span class="pl-c">//</span> 如果是移动端，则设置可以设置顶部状态栏（电量、时间...）的颜色、是否显示</span>
    <span class="pl-k">if</span> (<span class="pl-smi">Windows</span>.<span class="pl-smi">Foundation</span>.<span class="pl-smi">Metadata</span>.<span class="pl-smi">ApiInformation</span>.<span class="pl-en">IsTypePresent</span>(<span class="pl-s"><span class="pl-pds">"</span>Windows.UI.ViewManagement.StatusBar<span class="pl-pds">"</span></span>))
    {
        <span class="pl-en">StatusBar</span> <span class="pl-smi">statusBar</span> <span class="pl-k">=</span> <span class="pl-smi">StatusBar</span>.<span class="pl-en">GetForCurrentView</span>();
        <span class="pl-c"><span class="pl-c">//</span> statusBar.ForegroundColor = Colors.White;// 设置背景色</span>
        <span class="pl-k">await</span> <span class="pl-smi">statusBar</span>.<span class="pl-en">HideAsync</span>();<span class="pl-c"><span class="pl-c">//</span> 隐藏状态栏</span>
    }
    <span class="pl-smi">Window</span>.<span class="pl-smi">Current</span>.<span class="pl-en">Activate</span>();<span class="pl-c"><span class="pl-c">//</span> 确保当前窗口处于活动状态</span>
}
<span class="pl-c"><span class="pl-c">//</span> 在OnNavigated方法中进行事件的注册和控制后退按钮的显示与否</span>
<span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">OnNavigated</span>(<span class="pl-k">object</span> <span class="pl-smi">sender</span>, <span class="pl-en">NavigationEventArgs</span> <span class="pl-smi">e</span>)
{
    <span class="pl-c"><span class="pl-c">//</span>显示标题栏后退按钮</span>
    <span class="pl-c"><span class="pl-c">//</span>SystemNavigationManager.GetForCurrentView().AppViewBackButtonVisibility = ((Frame)sender).CanGoBack ? AppViewBackButtonVisibility.Visible : AppViewBackButtonVisibility.Collapsed;</span>
    <span class="pl-smi">SystemNavigationManager</span>.<span class="pl-en">GetForCurrentView</span>().<span class="pl-smi">AppViewBackButtonVisibility</span> <span class="pl-k">=</span> <span class="pl-smi">AppViewBackButtonVisibility</span>.<span class="pl-smi">Visible</span>;<span class="pl-c"><span class="pl-c">//</span> 在PC客户端左上角显示后退按钮</span>
    <span class="pl-smi">BackEventManager</span>.<span class="pl-en">Register</span>(<span class="pl-smi">PageBackRequested</span>);<span class="pl-c"><span class="pl-c">//</span> 注册后退事件</span>
}</pre></div>
<p>  这里最关键的一句就是 <code>rootFrame.Navigated += OnNavigated;</code> 在 <strong>PageBackRequested</strong> 方法中做了统一的后退事件处理，比如在我的应用中，我希望显示 <strong>MainPage</strong> 时后退按钮能够双击彻底退出应用，显示其他页面时后退按钮能够处理正常的页面后退导航，具体处理如下：</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span> <span class="pl-k">void</span> <span class="pl-en">PageBackRequested</span>(<span class="pl-k">object</span> <span class="pl-smi">sender</span>, <span class="pl-en">BackRequestedEventArgs</span> <span class="pl-smi">e</span>)
{
    <span class="pl-smi">e</span>.<span class="pl-smi">Handled</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
    <span class="pl-en">GoBack</span>();
}
<span class="pl-c"><span class="pl-c">///</span> &lt;<span class="pl-ent"><span class="pl-ent">summary</span></span>&gt;</span>
<span class="pl-c"><span class="pl-c">///</span> 自定义全局后退事件处理</span>
<span class="pl-c"><span class="pl-c">///</span> &lt;/<span class="pl-ent"><span class="pl-ent">summary</span></span>&gt;</span>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">async</span> <span class="pl-k">void</span> <span class="pl-en">GoBack</span>()
{
    <span class="pl-k">var</span> <span class="pl-smi">rootFrame</span> <span class="pl-k">=</span> <span class="pl-smi">Window</span>.<span class="pl-smi">Current</span>.<span class="pl-smi">Content</span> <span class="pl-k">as</span> <span class="pl-en">Frame</span>;<span class="pl-c"><span class="pl-c">//</span> App的根Frame</span>
    <span class="pl-k">if</span> (<span class="pl-smi">rootFrame</span> <span class="pl-k">==</span> <span class="pl-c1">null</span>)
    {
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">if</span> (<span class="pl-smi">rootFrame</span>.<span class="pl-smi">CurrentSourcePageType</span> <span class="pl-k">==</span> <span class="pl-k">typeof</span>(<span class="pl-en">MainPage</span>))<span class="pl-c"><span class="pl-c">//</span> 判断rootFrame 当前页面类型是否为MainPage</span>
    {
        <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">IsQuit</span>)<span class="pl-c"><span class="pl-c">//</span> IsQuit表示是否已点击了后退按钮，用来处理双击事件</span>
        {
            <span class="pl-smi">IsQuit</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
            <span class="pl-k">await</span> (<span class="pl-smi">rootFrame</span>.<span class="pl-smi">Content</span> <span class="pl-k">as</span> <span class="pl-en">MainPage</span>).<span class="pl-en">showMessage</span>(<span class="pl-s"><span class="pl-pds">"</span>再按一次返回键退出<span class="pl-pds">"</span></span>, <span class="pl-smi">Colors</span>.<span class="pl-smi">Red</span>);<span class="pl-c"><span class="pl-c">//</span> 异步调出页面的提示框</span>
            <span class="pl-smi">IsQuit</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-smi">Current</span>.<span class="pl-en">Exit</span>();<span class="pl-c"><span class="pl-c">//</span> 彻底退出App</span>
        }
    }
    <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-smi">rootFrame</span>.<span class="pl-smi">CanGoBack</span>)
    {
        <span class="pl-smi">rootFrame</span>.<span class="pl-en">GoBack</span>();
    }
}</pre></div>
<p>在MainPage中</p>
<div class="highlight highlight-text-xml"><pre>public async Task showMessage(string msg, Color color)
{
    Hint.Text = msg;// 设置提示框文本内容
    if (color != null)
    {
        if (color == Colors.Green)
        {
            color = Color.FromArgb(255, 91, 159, 82);
        }
        messageBorder.Background = new SolidColorBrush(color);// 设置提示框背景色
    }
    message.Visibility = Visibility.Visible;// 显示提示框
    await Task.Delay(1500);// 延时1500ms
    message.Visibility = Visibility.Collapsed;// 隐藏提示框
}

//以下为xaml内容，一个自定义的文本提示框
&lt;<span class="pl-ent">Grid</span> <span class="pl-e">x</span><span class="pl-e">:</span><span class="pl-e">Name</span>=<span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span> RelativePanel.AlignVerticalCenterWithPanel=<span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span> RelativePanel.AlignHorizontalCenterWithPanel=<span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span> <span class="pl-e">Visibility</span>=<span class="pl-s"><span class="pl-pds">"</span>Collapsed<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">Border</span> <span class="pl-e">x</span><span class="pl-e">:</span><span class="pl-e">Name</span>=<span class="pl-s"><span class="pl-pds">"</span>messageBorder<span class="pl-pds">"</span></span> <span class="pl-e">CornerRadius</span>=<span class="pl-s"><span class="pl-pds">"</span>10<span class="pl-pds">"</span></span> <span class="pl-e">Background</span>=<span class="pl-s"><span class="pl-pds">"</span>#5B9F52<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">Border</span>&gt;
    &lt;<span class="pl-ent">ScrollViewer</span> <span class="pl-e">VerticalAlignment</span>=<span class="pl-s"><span class="pl-pds">"</span>Center<span class="pl-pds">"</span></span> <span class="pl-e">MaxHeight</span>=<span class="pl-s"><span class="pl-pds">"</span>120<span class="pl-pds">"</span></span> <span class="pl-e">VerticalScrollBarVisibility</span>=<span class="pl-s"><span class="pl-pds">"</span>Auto<span class="pl-pds">"</span></span> <span class="pl-e">BorderThickness</span>=<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>&gt;
        &lt;<span class="pl-ent">TextBlock</span> <span class="pl-e">x</span><span class="pl-e">:</span><span class="pl-e">Name</span>=<span class="pl-s"><span class="pl-pds">"</span>Hint<span class="pl-pds">"</span></span> <span class="pl-e">Foreground</span>=<span class="pl-s"><span class="pl-pds">"</span>White<span class="pl-pds">"</span></span> RelativePanel.AlignHorizontalCenterWithPanel=<span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span> RelativePanel.AlignVerticalCenterWithPanel=<span class="pl-s"><span class="pl-pds">"</span>True<span class="pl-pds">"</span></span> <span class="pl-e">VerticalAlignment</span>=<span class="pl-s"><span class="pl-pds">"</span>Center<span class="pl-pds">"</span></span> <span class="pl-e">HorizontalAlignment</span>=<span class="pl-s"><span class="pl-pds">"</span>Center<span class="pl-pds">"</span></span> <span class="pl-e">TextAlignment</span>=<span class="pl-s"><span class="pl-pds">"</span>Center<span class="pl-pds">"</span></span> <span class="pl-e">Margin</span>=<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span> <span class="pl-e">TextWrapping</span>=<span class="pl-s"><span class="pl-pds">"</span>Wrap<span class="pl-pds">"</span></span> <span class="pl-e">Padding</span>=<span class="pl-s"><span class="pl-pds">"</span>10<span class="pl-pds">"</span></span> <span class="pl-e">MinWidth</span>=<span class="pl-s"><span class="pl-pds">"</span>120<span class="pl-pds">"</span></span> <span class="pl-e">MinHeight</span>=<span class="pl-s"><span class="pl-pds">"</span>30<span class="pl-pds">"</span></span> <span class="pl-e">FontFamily</span>=<span class="pl-s"><span class="pl-pds">"</span>Resources/FontAwesome.otf#FontAwesome<span class="pl-pds">"</span></span> <span class="pl-e">FontSize</span>=<span class="pl-s"><span class="pl-pds">"</span>16<span class="pl-pds">"</span></span>/&gt;
    &lt;/<span class="pl-ent">ScrollViewer</span>&gt;
&lt;/<span class="pl-ent">Grid</span>&gt;</pre></div>
<h3>总结</h3>
<hr>
<p>  在我的开发过程中，这个后退事件管理器已经基本满足所有需求了，不过每次执行后退事件的时候都很任性的抛弃了之前注册的事件，之后会考虑加入<strong>与前面注册的事件共存</strong>的方法并做一些优化，以便灵活地适应更多的通用需求。</p>
<hr>
<h4>转载请注明出处：<a rel="nofollow" href="https://www.jianshu.com/p/55d6cd6b632d">https://www.jianshu.com/p/55d6cd6b632d</a></h4>]]></content:encoded>
            <enclosure url="http://upload-images.jianshu.io/upload_images/1836534-a8f5369b52cbe1dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" length="0" type="image/jpg"/>
        </item>
    </channel>
</rss>